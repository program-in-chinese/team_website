[
  
    {
      "title"    : "中文命名之Hibernate+MySQL演示",
      "category" : "命名, Hibernate",
      "description" : "用一个简单例子演示Hibernate + MySQL基本功能中使用中文命名. Demostrate naming in Chinese in the basic features of Hibernate + MySQL.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/hibernate/2019/04/23/%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E4%B9%8BHibernate+MySQL%E6%BC%94%E7%A4%BA.html",
      "date"     : "2019-04-23 00:00:00 -0700",
      "content"  : "最近有个契机, 需要在一个给定开发环境中验证中文命名的可行性. 达成的例子源码在: HibernateExampleZh当前用的是Hibernate 3.3.2.GA. 之后测试了更多版本, 彩蛋见最后一部分.测试环境:  Windows 7 Pro 64bit, JDK 1.7.0_80, MySQL 5.5.62, Eclipse Kepler SR2  MacOS 10.13.6, JDK 1.8.0_45, MySQL 5.5.24, Eclipse 4.7.3a功能验证:运行com.codeinchinese.App, 在数据库表中插入一条记录并进行一次条件查询.数据库源码如下, 与前文相比, 多了索引.需修改hibernate.cfg.xml中的数据库用户/密码部分.DROP TABLE IF EXISTS `演示`.`客户`;CREATE TABLE  `演示`.`客户` (  `客户_ID` bigint(20) unsigned COLLATE utf8_unicode_ci NOT NULL AUTO_INCREMENT,  `姓名` varchar(45) COLLATE utf8_unicode_ci NOT NULL,  `创建日期` datetime COLLATE utf8_unicode_ci NOT NULL,  PRIMARY KEY (`客户_ID`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COLLATE utf8_unicode_ci;ALTER TABLE `演示`.`客户`ADD INDEX `姓名_索引` (`姓名` ASC) ;Java模型类public class 客户类 implements java.io.Serializable   private Long 客户_ID;  private String 姓名;  private Date 创建日期;  public 客户类()     public 客户类(String 姓名, Date 创建日期)       this.姓名 = 姓名;      this.创建日期 = 创建日期;    public Long get客户Id()       return this.客户_ID;    public void set客户Id(Long 客户Id)       this.客户_ID = 客户Id;    public String get姓名()       return this.姓名;    public void set姓名(String 姓名)       this.姓名 = 姓名;    public Date get创建日期()       return this.创建日期;    public void set创建日期(Date 创建日期)       this.创建日期 = 创建日期;    Override  public String toString()     return 客户_ID +   + 姓名 +   + 创建日期;  Hibernate映射文件客户.hbm.xmllt;hibernate-mappinggt;    lt;class name=com.codeinchinese.客户.模型.客户类 table=客户gt;        lt;id name=客户Id type=java.lang.Longgt;            lt;column name=客户_ID /gt;            lt;generator class=identity /gt;        lt;/idgt;        lt;property name=姓名 type=stringgt;            lt;column name=姓名 length=45 not-null=true /gt;        lt;/propertygt;        lt;property name=创建日期 type=timestampgt;            lt;column name=创建日期 length=19 not-null=true /gt;        lt;/propertygt;    lt;/classgt;lt;/hibernate-mappinggt;检查更多Hibernate版本经测试, 到4.2.21.Final都正常运行, 但从5.0.0.Final开始到最近的6.0.0.Alpha2, 都不支持模型类名的中文命名. 具体报错如下:Caused by: org.xml.sax.SAXParseException; lineNumber: 6; columnNumber: 58; cvc-pattern-valid: Value 'com.codeinchinese.客户.模型.客户类' is not facet-valid with respect to pattern '([a-zA-Z_][a-zA-Z#92;d_]*#92;.)*[a-zA-Z_][a-zA-Z#92;d_]*' for type 'ClassNameType'.    at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:203)    at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.error(ErrorHandlerWrapper.java:134)    at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:396)    at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:327)    at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:284)    at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidatorXSIErrorReporter.reportError(XMLSchemaValidator.java:452)    at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.reportSchemaError(XMLSchemaValidator.java:3230)    at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.processOneAttribute(XMLSchemaValidator.java:2825)    at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.processAttributes(XMLSchemaValidator.java:2762)    at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.handleStartElement(XMLSchemaValidator.java:2050)    at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.startElement(XMLSchemaValidator.java:740)    at com.sun.org.apache.xerces.internal.jaxp.validation.ValidatorHandlerImpl.startElement(ValidatorHandlerImpl.java:570)    at com.sun.xml.bind.v2.runtime.unmarshaller.ValidatingUnmarshaller.startElement(ValidatingUnmarshaller.java:101)    at com.sun.xml.bind.v2.runtime.unmarshaller.InterningXmlVisitor.startElement(InterningXmlVisitor.java:75)    at com.sun.xml.bind.v2.runtime.unmarshaller.StAXEventConnector.handleStartElement(StAXEventConnector.java:261)    at com.sun.xml.bind.v2.runtime.unmarshaller.StAXEventConnector.bridge(StAXEventConnector.java:130)    at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:460)修改为英文类名com.codeinchinese.customer.model.Customer后, 保留MySQL中文命名和Hibernate相关映射, 仍能运行.考虑到这是从版本4到5的功能退化, 而且在6.0版本并无修复的意思, 应该提issue反馈一下.参考Maven 3 + Hibernate 3.6 + Oracle 11g Example"
    } ,
  
    {
      "title"    : "为Jekyll+GitHub Pages添加全文搜索功能",
      "category" : "命名",
      "description" : "为Jekyll+GitHub Pages添加全文搜索功能",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2019/04/08/%E4%B8%BAJekyll+GitHub-Pages%E6%B7%BB%E5%8A%A0%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD.html",
      "date"     : "2019-04-08 00:00:00 -0700",
      "content"  : "动态演示如下:源码库: program-in-chinese/team_website找到此JS工具: christian-fei/Simple-Jekyll-Search, 按安装说明先完成了对题目/类别/日期的搜索, 本地运行不错. 再接再厉添加了对描述和全文(post.content)的搜索, 详见全文索引.json发现生成的json文件中, 特殊字符如引号使得json语法出错:发现前人对同样问题的解决方法“full-text search” donot work! · Issue #63 · christian-fei/Simple-Jekyll-Search, 另参考christian-fei/Simple-Jekyll-Search, 在_plugins下添加脚本特殊字符过滤.rb:module Jekyll  module C字符过滤器    def remove_chars_cn(输入)      输入.gsub! '#92;#92;','amp;#92;'      输入.gsub! /#92;t/, '    '      输入.gsub! '',''      输入.gsub! '',''      输入.gsub! '',''      输入.gsub! 'amp;',''      输入.gsub! '',''      输入.gsub! '',''      输入.gsub! '',''      输入    end  endendLiquid::Template.register_filter(Jekyll::C字符过滤器)module名称如果没有大写字母开头, 报语法错误如下, 猜测原因与Scala疑似中文命名问题后续类似, 不过Ruby好像将中文字符认作了非大写的:特殊字符过滤.rb:2: class/module name must be CONSTANT (SyntaxError)方法remove_chars_cn未能中文, 由于Jekyll的Liquid脚本语言貌似不支持Unicode标识符, 会报错:Liquid Warning: Liquid syntax error (line 6): Unexpected character 删 in  in 全文索引.json在本地运行通过后, 将包括插件在内的修改提交到GitHub后, 发现网站加载json文件时报错”invalid JSON”, 查看取json的请求响应内容后, 各种尝试后初步认定是插件未成功运行, 一通搜之后发现, GitHub Pages不支持任意插件的运行: jekyll plugin not work on github解决方法就是本地jekyll生成网站源码后, 将网站源码提交到repo里.参考Configuration Options在_config.yml中将输出目录改为docs:destination: docs再将原本的jekyll文件都移到repo根下, 运行生成后提交, 搞定."
    } ,
  
    {
      "title"    : "Java实现文本编辑时基于拼音输入的补全原型",
      "category" : "命名, IDE",
      "description" : "Java实现文本编辑时基于拼音输入的补全原型",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/ide/2019/04/02/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E6%97%B6%E5%9F%BA%E4%BA%8E%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E8%A1%A5%E5%85%A8%E5%8E%9F%E5%9E%8B.html",
      "date"     : "2019-04-02 00:00:00 -0700",
      "content"  : "续前文Java实现”命令式”简易文本编辑器原型. 效果如下:所在源码库同上文, 尚未和上文的编辑器右侧的命令区集成. 代码由How to show autocomplete as I type in JTextArea?修改得来.基本功能  英文输入至少一个匹配词典的字母后, 显示提示框  上下光标选中某提示项后按空格键自动替换  弹出提示框后, 如果继续键入, 提示框隐藏后, 根据新键入继续提示. 比如上面输入’t’后提示”退出”和”粘贴”两项, 继续输入’c’后就只显示”退出”IDE和中文输入法的深度集成是必然趋势. 虽然现在第三方的中文输入法可以解决”输入”的基本功能, 但在IDE自动补全/智能提示功能日益成为开发效率提升的必需辅助功能的现今, 只有实现了中文输入法和IDE补全/提示的集成, 中文编程才能更接近实用. 这早已在易语言开发环境中实现, 期待早日看到开源项目实现类似功能.源码简单说明监听文本框的按键输入, 并准备弹出提示框:    文本区.addKeyListener(new KeyListener()       Override      public void keyTyped(KeyEvent e)         随后显示提示();      ...    );弹出之前, 先获取此次输入的字符串, 并基于它生成/更新提示框:  private void 显示提示()     final int 文本位置 = 文本区.getCaretPosition();    Point 界面位置;    try       界面位置 = 文本区.modelToView(文本位置).getLocation();     catch (BadLocationException e2)       e2.printStackTrace();      return;        final String 提示源词 = 取提示源词(文本位置);    if (提示源词 == null)       return;        if (提示 == null)       提示 = new 提示框(文本区, 文本位置, 提示源词, 界面位置);     else       提示.更新(文本位置, 提示源词, 界面位置);      提示框部分, 由一个列表来管理提示项的选择, 文本的替换:  private JListlt;Stringgt; 创建提示列表(final String[] 提示列表)     JListlt;Stringgt; 列表 = new JListlt;gt;(提示列表);    列表.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY, 1));    列表.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);    列表.setSelectedIndex(0);    列表.addKeyListener(new KeyListener()       Override      public void keyTyped(KeyEvent e)         if (e.getKeyChar() == KeyEvent.VK_SPACE)           if (插入选择文本())             隐藏();                   else           隐藏();          文本区.requestFocusInWindow();          文本区.dispatchEvent(e);                    Override      public void keyPressed(KeyEvent e)         if (e.getKeyCode() == KeyEvent.VK_DOWN)           下移();         else if (e.getKeyCode() == KeyEvent.VK_UP)           上移();              ...    );    return 列表;  当然少不了一个字符-gt;中文词典(如下), 实际应用时需要基于拼音生成提示的算法  private static final HashMaplt;String, String[]gt; 提示词典 = new HashMaplt;gt;();  static     提示词典.put(xj, new String[] 新建);    提示词典.put(dk, new String[] 打开);    提示词典.put(bc, new String[] 保存);    提示词典.put(jq, new String[] 剪切);    提示词典.put(fz, new String[] 复制);    提示词典.put(nt, new String[] 粘贴);    提示词典.put(zt, new String[] 粘贴);    提示词典.put(tc, new String[] 退出);    提示词典.put(j, new String[] 新建, 剪切);    提示词典.put(t, new String[] 退出, 粘贴);  "
    } ,
  
    {
      "title"    : "Java实现&quot;命令式&quot;简易文本编辑器原型",
      "category" : "命名, IDE",
      "description" : "Java实现命令式简易文本编辑器原型",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/ide/2019/03/30/Java%E5%AE%9E%E7%8E%B0-%E5%91%BD%E4%BB%A4%E5%BC%8F-%E7%AE%80%E6%98%93%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8E%9F%E5%9E%8B.html",
      "date"     : "2019-03-30 00:00:00 -0700",
      "content"  : "源自早先想法, 打算从界面方向做些尝试. 找到个简单文本编辑器的实现: Simple Text Editor - Java Tutorials. 原本的菜单/按钮界面如下. 包括基本功能: 新建/打开/保存文件, 文本编辑与剪切/复制/粘贴.把所有菜单/按钮替换为命令输入后效果如下, 源码库在: program-in-chinese/simple-text-editor-in-Java. 与其他命令行工具一样, 省去界面元素的代价是输入较繁琐. 在文本和命令两处切换也有点麻烦.接下去试着实现命令输入的自动补全等等.实现源码如下. 不采用第三方库, 比较粗糙的代码180行.public class 文本编辑器 extends JFrame   private static final String 默认文件名 = 无名;  private JTextArea 文本区域 = new JTextArea(20, 120);  private JTextArea 命令文本区 = new JTextArea(5, 20);  private JFileChooser 对话框 = new JFileChooser(System.getProperty(user.dir));  private String 当前文件 = 默认文件名;  private String 当前命令 = ;  private boolean 已改 = false;  public static void main(String[] arg)     new 文本编辑器();    public 文本编辑器()     文本区域.setFont(new Font(Monospaced, Font.PLAIN, 12));    JScrollPane 文本区 = new JScrollPane(文本区域, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,        JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);    add(文本区, BorderLayout.CENTER);    命令文本区.setFont(new Font(Monospaced, Font.PLAIN, 12));    JScrollPane 命令区 = new JScrollPane(命令文本区, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,        JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);    add(命令区, BorderLayout.EAST);    setDefaultCloseOperation(EXIT_ON_CLOSE);    pack();    文本区域.addKeyListener(监听文本输入);    命令文本区.addKeyListener(命令监听);    setTitle(当前文件);    setVisible(true);    private KeyListener 监听文本输入 = new KeyAdapter()     Override    public void keyPressed(KeyEvent e)       已改 = true;      ;  private KeyListener 命令监听 = new KeyAdapter()     Override    public void keyPressed(KeyEvent e)       if (e.getKeyCode() == KeyEvent.VK_ENTER)         int 行数 = 命令文本区.getLineCount();        if (行数 == 1)           当前命令 = 命令文本区.getText();         else           try             int 上一行末位置 = 命令文本区.getLineEndOffset(行数 - 2);            当前命令 = 命令文本区.getText().substring(上一行末位置);           catch (BadLocationException e1)             // TODO Auto-generated catch block            e1.printStackTrace();                          执行(当前命令);            ;  private void 执行(String 当前命令)     switch (当前命令)       case 新建:        新建操作();        break;      case 打开:        打开操作();        break;      case 保存:        保存操作();        break;      case 另存:        另存文件为();        break;      case 退出:        退出操作();        break;      case 剪切:        文本区域.cut();        break;      case 复制:        文本区域.copy();        break;      case 粘贴:        文本区域.paste();        break;      default:        // TODO: 提示无此命令或显示帮助        break;        private void 新建操作()     保存旧文件();    文本区域.setText();    当前文件 = 默认文件名;    setTitle(当前文件);    已改 = false;    private void 打开操作()     保存旧文件();    if (对话框.showOpenDialog(null) == JFileChooser.APPROVE_OPTION)       读入文件(对话框.getSelectedFile().getAbsolutePath());        private void 保存操作()     if (!当前文件.equals(默认文件名))      保存文件(当前文件);    else      另存文件为();    private void 退出操作()     保存旧文件();    System.exit(0);    private void 另存文件为()     if (对话框.showSaveDialog(null) == JFileChooser.APPROVE_OPTION)      保存文件(对话框.getSelectedFile().getAbsolutePath());    private void 保存旧文件()     if (已改)       if (JOptionPane.showConfirmDialog(this, 保存  + 当前文件 +  吗?, 保存,          JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION)        保存文件(当前文件);        private void 读入文件(String 文件名)     try       FileReader 读 = new FileReader(文件名);      文本区域.read(读, null);      读.close();      当前文件 = 文件名;      setTitle(当前文件);      已改 = false;     catch (IOException e)       Toolkit.getDefaultToolkit().beep();      JOptionPane.showMessageDialog(this, 找不到  + 文件名);        private void 保存文件(String 文件名)     try       FileWriter 写 = new FileWriter(文件名);      文本区域.write(写);      写.close();      当前文件 = 文件名;      setTitle(当前文件);      已改 = false;     catch (IOException e)       参考adding a console to a JframeDetecting when user presses enter in JavaJava SWING JFrame Layouts Example"
    } ,
  
    {
      "title"    : "演示Eclipse插件实现代码提示和补全",
      "category" : "语言设计, IDE",
      "description" : "演示Eclipse插件实现代码提示和补全",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/ide/2019/03/21/%E6%BC%94%E7%A4%BAEclipse%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E5%92%8C%E8%A1%A5%E5%85%A8.html",
      "date"     : "2019-03-21 00:00:00 -0700",
      "content"  : "续上文重拾《 两周自制脚本语言 》- Eclipse插件实现语法高亮, 但仅达到了演示Eclipse本身功能的程度, 与石头语言并无直接联系. 源码库相同, 仍在同一插件. 演示效果如下:悬浮窗显示的是当前所在行内容. 而键入”新”字会弹出自动补全, 选项仅有”新建”一项. 再进一步的话, 两者都应该需要准确获取鼠标所在位置字段的语法信息, 即集成语法分析器的功能, 而那还只是第一步.由于仅作演示功能, 相关代码还较简短. 内容辅助处理器, 提供自动补全功能.  public static final String[] 所有建议 = new String[] 新建;  Override  public ICompletionProposal[] computeCompletionProposals(ITextViewer 视图, int 偏移)     IDocument 文件 = 视图.getDocument();    try       int 偏移所在行 = 文件.getLineOfOffset(偏移);      int 行头偏移 = 文件.getLineOffset(偏移所在行);      int 当前行文本长度 = 偏移 - 行头偏移;      String 当前行文本 = 文件.get(行头偏移, 当前行文本长度).toLowerCase();      return Arrays.asList(所有建议).stream()          .filter(建议 -gt; !视图.getDocument().get().contains(建议) amp;amp; 建议.toLowerCase().startsWith(当前行文本))          .map(建议 -gt; new CompletionProposal(建议, 行头偏移, 当前行文本长度, 建议.length()))          .toArray(ICompletionProposal[]::new);     catch (BadLocationException e)       e.printStackTrace();        return new ICompletionProposal[0];    Override  public char[] getCompletionProposalAutoActivationCharacters()     String keys = 新;    return keys.toCharArray();悬浮提供器  Override  public String getHoverInfo(ITextViewer 文本视图, IRegion 悬浮位置)     int 偏移 = 悬浮位置.getOffset();    IDocument 文件 = 文本视图.getDocument();    try       // 仅提取当前所在行, 如要取得当前鼠标所在词, 需进一步词法分析?      int 所在行 = 文件.getLineOfOffset(偏移);      IRegion 行信息 = 文件.getLineInformation(所在行);      int 行长 = 行信息.getLength();      int 行偏移 = 行信息.getOffset();      return 文件.get(行偏移, 行长);     catch (BadLocationException e)       e.printStackTrace();        return ;"
    } ,
  
    {
      "title"    : "重拾《 两周自制脚本语言 》- Eclipse插件实现语法高亮",
      "category" : "语言设计, IDE",
      "description" : "为《 两周自制脚本语言 》的语言",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/ide/2019/03/20/%E9%87%8D%E6%8B%BE-%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-Eclipse%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE.html",
      "date"     : "2019-03-20 00:00:00 -0700",
      "content"  : "源码库: program-in-chinese/stone-editor-eclipse参考:  FAQ How do I write an editor for my own language?  Deliver support for new languages in Eclipse IDE faster with Generic Editor and Language Servers - Red Hat Developer Blog  Vogella公司写的源码例子: vogellacompany/codeexamples-ide续前文重拾《 两周自制脚本语言 》- 中文关键字与原生函数, 开始想在VS Code下实现, 通过添加TextMate语法文件也基本达到了上面的效果, 但看着vscode的Java语法需要上千行JSON代码: java.tmLanguage.json, TypeScript的更夸张有五千行, 难以想象如何维护, 于是考察Eclipse下的实现方式.正好看到Eclipse 4.7版本之后改进了对新语言的插件开发的支持(Eclipse Project Oxygen (4.7) M3 News), 不用从头建一个定制编辑器, 而是对一个”通用文本编辑器”进行扩展, 来实现高亮, 悬浮提示, 辅助补全等等功能. 看了示例代码以Java为主, 应该比写JSON好维护一些.刚实现了开头的图示中的高亮功能, 直接上源码.下面定义了语法高亮的几个规则, 包括数字, 注释(StoneReconciler):public class StoneReconciler extends PresentationReconciler   Token 深红 = 字号(SWT.COLOR_DARK_RED);  Token 深绿 = 字号(SWT.COLOR_DARK_GREEN);  Token 蓝色 = 字号(SWT.COLOR_BLUE);  public StoneReconciler()     SingleLineRule 单引号 = new SingleLineRule(', ', 深红);    SingleLineRule 双引号 = new SingleLineRule(#92;, #92;, 深红);    NumberRule 数字 = new NumberRule(蓝色);    PatternRule 模式规则 = new PatternRule(//, null, 深绿, (char) 0, true);    石头语言用词规则 用词规则 = new 石头语言用词规则();    RuleBasedScanner 扫描器 = new RuleBasedScanner();    扫描器.setRules(new IRule[] 单引号, 双引号, 用词规则, 模式规则, 数字);    DefaultDamagerRepairer 修理器 = new DefaultDamagerRepairer(扫描器);    this.setDamager(修理器, IDocument.DEFAULT_CONTENT_TYPE);    this.setRepairer(修理器, IDocument.DEFAULT_CONTENT_TYPE);    private Token 字号(int 色号)     return new Token(new TextAttribute(Display.getCurrent().getSystemColor(色号)));  关键词高亮规则:public class 石头语言用词规则 extends WordRule   private static final ArrayListlt;Stringgt; 关键字 =      new ArrayListlt;gt;(Arrays.asList(每当, 如果, 否则, 类别, 定义));  private static final Color 深紫红 = Display.getCurrent().getSystemColor(SWT.COLOR_DARK_MAGENTA);  public 石头语言用词规则()     super(new 探测器());    for (String 词 : 关键字)       addWord(词, new Token(new TextAttribute(深紫红, null, SWT.BOLD)));      问题新建的默认插件对XML进行校验, 因此石头语言的语法会导致文件开头报校验错误”Content is not allowed in prolog”. 将ValidatorDocumentSetupParticipant中对XML解析的部分删去后不再报错. 但是, 老文件的错误不能自动消除, 应该与内容刷新或者自动校验有关. 之后对校验部分定制时进一步研究.参考: Eclipse Content is not allowed in prolog"
    } ,
  
    {
      "title"    : "重拾《 两周自制脚本语言 》- 中文关键字与原生函数",
      "category" : "语言设计, 命名",
      "description" : "为《 两周自制脚本语言 》添加中文关键字与原生函数",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E5%91%BD%E5%90%8D/2019/03/17/%E9%87%8D%E6%8B%BE-%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E4%B8%AD%E6%96%87%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0.html",
      "date"     : "2019-03-17 00:00:00 -0700",
      "content"  : "续前文重拾《 两周自制脚本语言 》- 支持中文标识符, 将当前的关键字改为中文. 基本是将语法分析器中的原本英文关键字改为中文. 如改while-gt;每当 · program-in-chinese/stone32c79b4:    Parser statement = statement0.or(            rule(IfStmnt.class).sep(IfStmnt.关键字_如果).ast(expr).ast(block)                               .option(rule().sep(IfStmnt.关键字_不然).ast(block)),            rule(While声明类.class).sep(While声明类.关键字).ast(expr).ast(block),            simple);下面是关键字对应表:while,每当if,如果else,否则class,类别extends,扩展def,定义fun,函数new,新建this,本体原生函数就是Java本身核心库函数. 比如System.out.println, 原本被封装为了print方法, System.currentTimeMillis被封装为了currentTime方法等. 将原环境类中的键值, 就是原英文方法名, 改为中文. 如print-gt;打印 · program-in-chinese/stone165d99e:append(env, 方法名_打印, 原生类.class, print, Object.class);为验证可行性, 仅汉化了两个API. 最好今后能够做到无需封装直接调用Java的静态方法.达成例程效果如下:类别 斐波那契类     值0 = 0    值1 = 1    定义 斐波那契 (n)         如果 n == 0             值0         否则             如果 n == 1                 本体.值1             否则                 本体.斐波那契(n-1) + 本体.斐波那契(n-2)                        时刻 = 当前时刻()斐 = 斐波那契类.新建斐.斐波那契 20耗时 = 当前时刻() - 时刻下面打算先参考为新语言编写Visual Studio Code语法高亮插件, 为它编写类似插件."
    } ,
  
    {
      "title"    : "重拾《 两周自制脚本语言 》- 支持中文标识符",
      "category" : "语言设计, 命名",
      "description" : "为《 两周自制脚本语言 》添加中文标识符支持.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E5%91%BD%E5%90%8D/2019/03/16/%E9%87%8D%E6%8B%BE-%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E6%A0%87%E8%AF%86%E7%AC%A6.html",
      "date"     : "2019-03-16 00:00:00 -0700",
      "content"  : "续前文将《 两周自制脚本语言 》测试中使用的接口中文化. 在将此脚本语言改为中文关键字之前, 需要先让它支持中文标识符.首先添加一个词法分析器测试:  Test  public void test读中文() throws 分析例外     词法分析器类 词法分析器 = 词法分析功用.新建词法分析器(中文变量1名 = 中文ok值);    词类 词1 = 词法分析器.读();    词类 词2 = 词法分析器.读();    词类 词3 = 词法分析器.读();    词法分析功用.词为标识符(中文变量1名, 词1);    词法分析功用.词为标识符(=, 词2);    词法分析功用.词为标识符(中文ok值, 词3);  预期的应该不能通过测试, 结果的确不成功, 但是”卡”住了而非报错. 调试后看到问题出在这段:        int lineNo = reader.getLineNumber();        Matcher matcher = pattern.matcher(line);        matcher.useTransparentBounds(true).useAnchoringBounds(false);        int pos = 0;        int endPos = line.length();        while (pos lt; endPos)             matcher.region(pos, endPos);            if (matcher.lookingAt())                 addToken(lineNo, matcher);                pos = matcher.end();                        else                throw new 分析例外(bad token at line  + lineNo);        改为中文命名以更易于理解:        int 行数 = reader.getLineNumber();        Matcher 匹配器 = 模式.matcher(行);        匹配器.useTransparentBounds(true).useAnchoringBounds(false);        int 头 = 0;        int 尾 = 行.length();        while (头 lt; 尾)             匹配器.region(头, 尾);            if (匹配器.lookingAt())                 添加词(行数, 匹配器);                头 = 匹配器.end();                        else                throw new 分析例外(bad token at line  + 行数);        看到进入死循环的直接原因是匹配器.lookingAt()虽然为true, 但头始终为0. 更深原因可自行研究原正则表达式.为了添加中文标识符支持, 需要使正则表达式能够匹配中文字符, 参考Detecting if NSString contains chinese characters将原模式中的[A-Z_a-z][A-Z_a-z0-9]*改为[#92;#92;pscript=HanA-Z_a-z][#92;#92;pscript=HanA-Z_a-z0-9]*. 之后开头的词法分析器测试通过.为检验更复杂一些的源码, 对第九章的原本测试用源码使用中文命名:class 位置类     经 = 纬 = 0    def 到达 (经度, 纬度)         经 = 经度; 纬 = 纬度;    位置 = 位置类.new位置.到达(3, 4)位置.经 = 10和 = 位置.经 + 位置.纬测试通过~ 源码提交在此"
    } ,
  
    {
      "title"    : "将《 两周自制脚本语言 》测试中使用的接口中文化",
      "category" : "语言设计, 命名",
      "description" : "为《 两周自制脚本语言 》添加的JUnit测试代码中调用的非核心库API进行汉化.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E5%91%BD%E5%90%8D/2019/03/15/%E5%B0%86-%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E6%B5%8B%E8%AF%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%87%E5%8C%96.html",
      "date"     : "2019-03-15 00:00:00 -0700",
      "content"  : "续前文为《 两周自制脚本语言 》添加中文测试代码. 之前在手工翻译Vue.js源码:尝试重命名标识符与文本时, 采用的顺序是从主程序入口开始. 这次从自己编写的测试代码开始, 一是较为熟悉代码, 二是测试驱动开发的思路.在过程中, 基本依托Eclipse的”重命名”功能, 尚未发现功能上的问题.在修改eval方法名时, 一开始只重命名了ASTreeEx中的, 后发觉需要将ASTree的所有子类中的eval一并重命名. 其他子类递归调用的API也如此. GluonJ的机制如下(摘自原书), 开发时需要注意.  eval 方法 看似 定义 于 ASTreeEx 类 中， 其实 该类 的 定义 将被 替换， eval 方法 实际上 将由 ASTree 类 定义。 其他 类 的 eval 方法 同样 如此。翻译的中英对应在词典:类名:Lexer,词法分析器类Token,词类BasicParser,基本语法分析器类ASTree,语法树类BinaryExpr,二元表达式类ASTLeaf,语法树叶类WhileStmnt,While声明类ParseException,分析例外BasicInterpreter,基本解释器类BasicEnv,基本环境类BasicEvaluator,基本求值器类FuncInterpreter,函数解释器类FuncParser,函数语法分析器类NestedEnv,嵌套环境类FuncEvaluator,函数求值器类ClosureInterpreter,闭包解释器类ClosureParser,闭包语法分析器类ClosureEvaluator,闭包求值器类NativeInterpreter,原生解释器类NativeEvaluator,原生求值器类Natives,原生类ClassEvaluator,类求值器类ClassInterpreter,类解释器类ClassParser,类语法分析器类ArrayEvaluator,数组求值器类EnvOptimizer,环境优化器类InlineCache,内联缓存类ObjOptimizer,对象优化器类VmInterpreter,虚拟机解释器类StoneVMEnv,虚拟机环境类VmEvaluator,虚拟机求值器类TypedInterpreter,带类型解释器类TypeEnv,类型环境类TypedParser,带类型语法分析器类TypedNatives,带类型原生类ToJava,变Java类InferFuncTypes,推导函数类型类TypeException,类型例外TypeInfo,类型信息类Environment,环境类NullStmnt,空声明类ASTreeEx,语法树扩展类ASTreeOptEx,语法树优化扩展类EnvEx2,环境扩展类2TypeChecker,类型检查器类ASTreeTypeEx,语法树类型扩展类方法名:Lexer.read,读ASTree.numChildren,子个数ASTree.child,子ASTLeaf.token,词Lexer.peek,瞄ASTree.parse,分析Natives.environment,环境*.eval,求值*.lookup,查找*.symbols,所有符号*.typeCheck,类型检查Token.getText,取文本Token.isNumber,为数Token.isIdentifier,为标识符"
    } ,
  
    {
      "title"    : "5分钟入门LingaScript-尝鲜中文版TypeScript",
      "category" : "命名, 教程",
      "description" : "基于TypeScript官方入门文档, 用中文版TypeScript LingaScript重写示例代码.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2019/03/15/5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8LingaScript-%E5%B0%9D%E9%B2%9C%E4%B8%AD%E6%96%87%E7%89%88TypeScript.html",
      "date"     : "2019-03-15 00:00:00 -0700",
      "content"  : "续前文转载: 中文輸進去，程式出得來，開發者發大財 -LingaScript:中文化TypeScript, 虽然其中例程使用了繁体中文语法, 但它同时也支持简体中文语法.注: 此文中VS Code的TypeScript环境设置为了中文, 因此错误信息也是中文. 方法见VS Code 有哪些必不可少的设置项？ 这是VS Code提供的功能.按照前文5分钟入门CTS-尝鲜中文版TypeScript的过程, 对它的简体版lingascript-cn进行实测.源码库: program-in-chinese/LingaScript_cn_in_5_min采用本地安装, 第一个LingaScript程序, 关键字看上去与CTS相同:函数 问好(那谁)   返回 吃了么,  + 那谁;变量 路人 = 打酱油的;document.body.innerHTML = 问好(路人);由于仍使用.ts后缀, 在VS Code下被认作TypeScript源码, 因而有很多语法错误提示, 但不影响编译.运行编译后正确生成问好.js. 与中文代码示例之5分钟入门TypeScript文末一样, 在火狐中打开测试HTML文件仍需将编码改为Unicode.添加参数类型:函数 问好(那谁: 文字)   返回 吃了么,  + 那谁;如果’那谁’的类型不符, 比如是数组类型[0,1,2], 编译时会报错:  问好.ts:7:30 - error TS2345: 类型“number[]”的参数不能赋给类型“string”的参数。添加接口和类. 最终的问好.ts:类别 学生   全名: 文字;  构造(公开 姓: 文字, 公开 名: 文字)     本体.全名 = 姓 + 名;  接口 人   姓: 文字;  名: 文字;函数 问好(那谁: 人)   返回 吃了么,  + 那谁.姓 + 那谁.名;变量 路人 = 新建 学生(大, 林);document.body.innerHTML = 问好(路人);编译无误, 运行正常, 网页显示如下:  吃了么, 大林"
    } ,
  
    {
      "title"    : "为《 两周自制脚本语言 》添加中文测试代码",
      "category" : "语言设计, 命名",
      "description" : "为《 两周自制脚本语言 》添加中文JUnit测试代码.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E5%91%BD%E5%90%8D/2019/03/14/%E4%B8%BA-%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81.html",
      "date"     : "2019-03-14 01:00:00 -0700",
      "content"  : "源自自制编译器+自制脚本语言+自制编程语言 三书比较？两年多前只看了一本的前六章: 实践”两周自制脚本语言”一书【java吧】_百度贴吧当时是希望一路添加测试用例, 并且最终把语言改为中文语法. 但看到Gluonj之后,似乎必须要Loader.run来执行解释器, 得不到返回值, 只能打印解释结果.今天从此书官网(スクリプト言語の作り方)找到了它的附带源码库: chibash/stone, 顺便研究了一下Gluonj源码, 找到了它的JUnit辅助功能: https://github.com/chibash/gluonj/blob/master/src/javassist/gluonj/util/UTester.java据此写了第五到十四章的测试, 运行效果见开头. 下面以第九章的为例:测试用”石头”语言源码: 位置类class Position     x = y = 0    def move (nx, ny)         x = nx; y = ny;    p = Position.newp.move(3, 4)p.x = 10sum = p.x + p.y测试代码: 面向对象解释器Testpackage chap9;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.junit.Test;import chap7.NestedEnv;import chap8.Natives;import javassist.gluonj.util.UTester;import stone.ClassParser;import stone.ParseException;import stone.util.文件功用;import stone.util.解释器功用;public class 面向对象解释器Test extends ClassInterpreter   private static String 位置类 = ;  static     try       位置类 = 文件功用.读文件(测试源码/chap9/位置类.txt, StandardCharsets.UTF_8);     catch (IOException e)         public static Object 求值(String 源代码) throws ParseException     return 解释器功用.求值(new ClassParser(), new Natives().environment(new NestedEnv()), 源代码);    Test  public void 例程() throws Throwable     if (UTester.runTestWith(chap9.ClassEvaluator, chap8.NativeEvaluator, chap7.ClosureEvaluator))      return;    assertEquals(14, 求值(位置类));  改写自BasicInterpreter的解释器功用.求值()  public static Object 求值(BasicParser 基本分析器, Environment 环境, String 源代码) throws ParseException     Lexer 词法分析器 = new Lexer(new StringReader(源代码));    Object 终值 = null;    while (词法分析器.peek(0) != Token.EOF)       ASTree 树 = 基本分析器.parse(词法分析器);      if (!(树 instanceof NullStmnt))         终值 = ((BasicEvaluator.ASTreeEx) 树).eval(环境);              return 终值;又有了深入学习此书(顺便将代码中文化, 像之前的中文编程：手工翻译Vue.js源码:尝试重命名标识符与文本), 并据此开发一些中文编程语言原型的动力.补: 十四章中fib(33)的运行时间确实与Java的对应代码运行时间相差无几, 虽然如作者所言, 并不能以此判断语言的性能."
    } ,
  
    {
      "title"    : "[转载] 中文輸進去，程式出得來，開發者發大財 - LingaScript: 中文化TypeScript",
      "category" : "语言设计",
      "description" : "如何修改TypeScript使之支持繁簡中文語法.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2019/03/14/%E8%BD%AC%E8%BD%BD-LingaScript_TypeScript%E4%B8%AD%E6%96%87%E5%8C%96.html",
      "date"     : "2019-03-14 00:00:00 -0700",
      "content"  : "原文在原创者 (也是周蟒作者) 博客: 中文輸進去，程式出得來，開發者發大財前陣子過年，終於得以抽出的一些時間，可以來嘗試一些不同的東西。花了幾天查看 Typescript 程式碼，改寫了個可用繁/簡中文語法寫JS的轉譯器 LingaScript使用它做了個「中文輸進去，程式出得來，開發者發大財」的中文程式影片範例，歡迎大家開心試用。如何做到的這個專案脫胎自過去開發周蟒(Python + 中文語法)的經驗，並參考了 CTS (Typescript + 中文語法)原始碼。微軟主導開發的 Typescript 提供了分析 Typescript 語法，並可輸出成 Javascript 的轉譯器(src/compiler)。更棒的是因為 Visual Studio的開發工具中整合了 Typescript，而微軟為了讓 Visual Studio 中的所有編譯結果都有本地化語言輸出，也在 Typescript 中支援了本地化語言的命令行工具和錯誤輸出。因此， ‵LingaScript‵ 目前所做的，是讓支援的中文語法可分析為對應的 symbol，並預設將命令行工具設成對應的本地化語言。如此一來就可以得到較完整的使用本地化語言的開發體驗。因為看到 CTS 改版不易的問題，我使用自己開發，基於Google 提供的 diff-match-patch 包裝的 file-patch 工具，來對修改後的程式碼和 Typescript 原始碼做 diff/patch。‵LingaScript‵ 專案中保存了修改後的 compiler 相關檔案和 diff 檔。透過 patch 的方式更容易相容版本升級時的改動。具體可以查看相關用到的命令 https://github.com/gasolin/lingascript/blob/master/package.json#L14其他想法‵LingaScript‵ 目前的架構不僅止於能支援繁簡中文語法，只要加上對應的關鍵字檔案，也可以很快地支援其他語種，讓開發者或講師得以用熟悉的語言來介紹並執行Javascript 相容的程式。如果有興趣的話，歡迎前往 https://github.com/gasolin/lingascript 討論或提出想法。"
    } ,
  
    {
      "title"    : "中文代码示例之NW.js桌面应用开发初体验",
      "category" : "命名, 教程",
      "description" : "",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2019/03/09/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BNW.js%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C.html",
      "date"     : "2019-03-09 08:00:00 -0700",
      "content"  : "先看到了NW.js(应该是前身node-webkit的缩写? 觉得该起个更讲究的名字, 如果是NorthWest之意的话, logo(见下)里的指南针好像也没指着西北啊)和Electron的比较文章: Why I prefer NW.js over Electron? (2018 comparison)之后在看NW.js创始者(Wang WenRui)的推时不意发现微信小程序用了此框架. 也许与它对老系统如Windows XP的支持有关. 必须体验一下!下面完成与中文编程：中文代码示例之Electron桌面应用开发初体验相同的功能, 作一个比较.package.json  name: hello,  main: 主页.html,  version: 1.0.0,  window:    min_width:800,    min_height:400  主页.htmllt;!DOCTYPE htmlgt;lt;htmlgt;  lt;headgt;    lt;meta charset=UTF-8gt;    lt;titlegt;吃了么?lt;/titlegt;  lt;/headgt;  lt;bodygt;    lt;h1gt;吃了么?lt;/h1gt;    我们用了Node lt;scriptgt;document.write(process.versions.node)lt;/scriptgt;    , flavor lt;scriptgt;document.write(process.versions['nw-flavor'])lt;/scriptgt;    lt;scriptgt;      nw.Window.get().showDevTools();  lt;/scriptgt;  lt;/bodygt;lt;/htmlgt;起初安装时用了Normal版, 将nwjs.app移到了/Applications下(Mac环境)在目录下运行:   /Applications/nwjs.app/Contents/MacOS/nwjs .发现弹出的开发者工具窗口为完全空白, 搜了一下发现官方的说明:Debugging with DevTools​docs.nwjs.io必须用”SDK Flavor”, 但链接直接引向了从源码构建NW: Build Flavors - NW.js Documentation正纠结是否要着手构建, 想起之前有个”SDK”版本下载, 试着下载解压后将nwjs.app文件(还有其他一些文件, 不知何用)移到/Applications下, 再次运行, 就成功如下打开了开发者窗口.下面尝试官网第二个例子: Getting Started - NW.js Documentation. 显示上下文菜单:菜单.htmllt;!DOCTYPE htmlgt;lt;htmlgt;lt;headgt;    lt;meta charset=UTF-8gt;  lt;titlegt;上下文菜单lt;/titlegt;lt;/headgt;lt;body style=width: 100; height: 100;gt;lt;pgt;'右击'显示上下文菜单.lt;/pgt;lt;scriptgt;// 创建空白上下文菜单var 菜单 = new nw.Menu();菜单.append(new nw.MenuItem(  label: 'A项',  click: function()    alert('你点了A项');  ));菜单.append(new nw.MenuItem( label: 'B项' ));菜单.append(new nw.MenuItem( type: 'separator' ));菜单.append(new nw.MenuItem( label: 'C项' ));// Hooks the context菜单 eventdocument.body.addEventListener('contextmenu', function(事件)   // 避免显示默认菜单  事件.preventDefault();  // 在点击处弹出菜单  菜单.popup(事件.x, 事件.y);  return false;, false);lt;/scriptgt;  lt;/bodygt;lt;/htmlgt;运行后随意点击窗口中央发现菜单并非期望:后发现有效区域仅在上部:查看开发者工具, 的确body仅在上部:为啥height: 100无效呢?初感官方文档的门槛略高(另外似乎无中文版?), 上面的问题应该会影响新手接纳程度. 也许是目标群体定位与Electron不同?参考:官方文档: Getting Started - NW.js Documentation"
    } ,
  
    {
      "title"    : "中文代码示例之Electron桌面应用开发初体验",
      "category" : "命名, 教程",
      "description" : "",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2019/03/09/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BElectron%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C.html",
      "date"     : "2019-03-09 00:00:00 -0700",
      "content"  : "参考: 打造你的第一个 Electron 应用首先运行下面在目录下创建package.json:   npm init去掉了一些无关项后内容如下:  name: hello,  version: 1.0.0,  description: 问好,  main: 问好.js,  scripts:     start: electron .  ,  devDependencies:     electron: ^4.0.8  问好.jsconst  app: 应用, BrowserWindow: 浏览器窗口  = require('electron')// 保持对window对象的全局引用，如果不这么做的话，当JavaScript对象被// 垃圾回收的时候，window对象将会自动的关闭let 窗口function 创建窗口 ()   // 创建浏览器窗口。  窗口 = new 浏览器窗口( width: 800, height: 600 )  窗口.loadFile('主页.html')  // 打开开发者工具  窗口.webContents.openDevTools()  // 当 window 被关闭，这个事件会被触发。  窗口.on('closed', () =gt;     // 取消引用 window 对象，如果你的应用支持多窗口的话，    // 通常会把多个 window 对象存放在一个数组里面，    // 与此同时，你应该删除相应的元素。    窗口 = null  )// Electron 会在初始化后并准备// 创建浏览器窗口时，调用这个函数。// 部分 API 在 ready 事件触发后才能使用。应用.on('ready', 创建窗口)// 当全部窗口关闭时退出。应用.on('window-all-closed', () =gt;   // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，  // 否则绝大部分应用及其菜单栏会保持激活。  if (process.platform !== 'darwin')     应用.quit()  )应用.on('activate', () =gt;   // 在macOS上，当单击dock图标并且没有其他窗口打开时，  // 通常在应用程序中重新创建一个窗口。  if (窗口 === null)     创建窗口()  )主页.htmllt;!DOCTYPE htmlgt;lt;htmlgt;  lt;headgt;    lt;meta charset=UTF-8gt;    lt;titlegt;吃了么?lt;/titlegt;  lt;/headgt;  lt;bodygt;    lt;h1gt;吃了么?lt;/h1gt;    我们用了Node lt;scriptgt;document.write(process.versions.node)lt;/scriptgt;,    Chrome lt;scriptgt;document.write(process.versions.chrome)lt;/scriptgt;,    和Electron lt;scriptgt;document.write(process.versions.electron)lt;/scriptgt;.  lt;/bodygt;lt;/htmlgt;运行应用:   npm start即显示开头的窗口(在Mac下测试)            有实质功能后还需发布为不同系统平台的包, 可参考: [Application Distribution      Electron](https://electronjs.org/docs/tutorial/application-distribution)      "
    } ,
  
    {
      "title"    : "在PyPI测试平台发布Python包",
      "category" : "语言设计",
      "description" : "在PyPI测试平台发布Python包.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2019/02/20/%E5%9C%A8PyPI%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%8F%91%E5%B8%83Python%E5%8C%85.html",
      "date"     : "2019-02-20 00:00:00 -0700",
      "content"  : "参考Packaging Python Projects, 源码在nobodxbodon/test-package-for-pypi包名/__init__.py:测试变量 = 值setup.py中import setuptoolswith open(README.md, r) as 自述文件:    长描述 = 自述文件.read()setuptools.setup(    name=test-package-name,    version=0.0.4,    author=小名,    author_email=authorexample.com,    description=描述,    long_description=长描述,    long_description_content_type=text/markdown,    url=https://github.com/pypa/sampleproject,    packages=setuptools.find_packages(),    classifiers=[        Programming Language :: Python :: 3,        License :: OSI Approved :: MIT License,        Operating System :: OS Independent,    ],)与编写Visual Studio Code插件初尝试类似, name只能用英文.生成发布包 python3 -m pip install --user --upgrade setuptools wheel python3 setup.py sdist bdist_wheel上传到测试pypi平台 python3 -m pip install --user --upgrade twine python3 -m twine upload --repository-url https://test.pypi.org/legacy/ dist/*测试安装包. 今后最好用virtualenv python3 -m pip install --index-url https://test.pypi.org/simple/ test-package-name现在就可以导入包gt;gt;gt; import 包名gt;gt;gt; 包名.测试变量'值'接下去需要将之前的扩展Python控制台同样打包并发布到(非测试)pypi平台, 但要先搞定开发模式(Packaging and distributing projects), 以及在命令行下调用控制台. 参考:  周蟒实现: https://github.com/gasolin/zhpy/blob/master/zhpy2/setup.py#L44  How to package a command line Python script"
    } ,
  
    {
      "title"    : "扩展Python控制台实现中文反馈信息之二-正则替换",
      "category" : "语言设计",
      "description" : "扩展默认的Python控制台, 通过正则匹配和替换, 将报错/警告等信息翻译成中文.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2019/02/18/%E6%89%A9%E5%B1%95Python%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%87%E5%8F%8D%E9%A6%88%E4%BF%A1%E6%81%AF%E4%B9%8B%E4%BA%8C-%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2.html",
      "date"     : "2019-02-18 00:00:00 -0700",
      "content"  : "“中文编程”知乎专栏原文地址续前文扩展Python控制台实现中文反馈信息, 实现了如下效果:gt;gt;gt; 学Traceback (most recent call last):  File lt;consolegt;, line 1, in lt;modulegt;命名错误: 命名'学'未定义gt;gt;gt; [1] + 2Traceback (most recent call last):  File lt;consolegt;, line 1, in lt;modulegt;类型错误: 只能将list(而非int)联结到listgt;gt;gt; [1].lengthTraceback (most recent call last):  File lt;consolegt;, line 1, in lt;modulegt;属性错误: 'list'个体没有'length'属性gt;gt;gt; def foo():...     def bar():...             print(type)...     bar()...     type = 1... gt;gt;gt; foo()Traceback (most recent call last):  File lt;consolegt;, line 1, in lt;modulegt;  File lt;consolegt;, line 4, in foo  File lt;consolegt;, line 3, in bar命名错误: 在闭合作用域中, 自由变量'type'在引用之前未被赋值源码在: program-in-chinese/study 现在支持的报错信息列表见测试用例: test翻译.py参考re - Regular expression operations - Python 3.7.2 documentation, 用一系列(现8个)正则表达式匹配和替换实现, 比如:if re.match(rNameError: name '(.*)' is not defined, 原始信息):    return re.sub(rNameError: name '(.*)' is not defined, r命名错误: 命名'#92;1'未定义, 原始信息)期间发现Python编译器源代码中的报错信息所处位置比较分散, 似乎有上百处. 下面的打算:  首先将它打包发布到Pypi, 参考Packaging Python Projects  逐步补充报错信息, 除了在自己使用过程中发现的新报错信息, 也可调研哪些报错最为常见  逐步改进中文信息. 比如只能将list(而非int)联结到list =gt; 只能将列表(而非整数)联结到列表  上文提到的通过”定制sys.excepthook”实现尚未研究. 如无明显优势, 打算置后."
    } ,
  
    {
      "title"    : "1992年日本对母语编程的可读性比较实验",
      "category" : "命名, 教程",
      "description" : "日本1992以来对在代码中使用母语对可读性的影响的研究. Research since 1992 in Japan about how programming in Japanese impacts code readability.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2019/02/14/1992%E5%B9%B4%E6%97%A5%E6%9C%AC%E5%AF%B9%E6%AF%8D%E8%AF%AD%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7%E6%AF%94%E8%BE%83%E5%AE%9E%E9%AA%8C.html",
      "date"     : "2019-02-14 00:00:00 -0700",
      "content"  : "这是发现的最早一篇: CiNii 論文 - 母国語プログラミングへの方式，実践とその効果​pdf不能导出文本, 不会日语输入法, 因此论文其他部分意义仅靠猜. 请会日语的指正.主要看如下几个图, 大概推测是使用了A, B两份同样语义的代码, 每份都有英日两个版本(不确定如何保证英日版本的可读性同样好?):A_日, A_英, B_日, B_英由不同的母语为日语的被试者阅读两份代码后(第一组阅读了A_日和B_英, 第二组阅读了A_英和B_日), 还回答了相关问题. 柱形图好像只比较了代码阅读时间, 不确定”回答时间”是否有用.最后的结果, 代码阅读时间上, 平均值母语版本是英语版本的2/3左右, 方差要小很多. 个人认为方差体现了被试者的英语水平比母语水平相差更大, 而均值体现了母语版本的可读性较好. 希望会日语的翻译一下论文中原作者的结论.后续相关文章见最后. 比较不解的是中间为何有20年的空档, 不过期间有诸如なでしこ(见前文日语编程语言”抚子” - 第三版特色初探)等日语编程语言的产生可以看到, 最近几年的文章已经不再关注代码可读性本身, 而是开始对日语编程的辅助工具(如辅助代码输入的IDE插件)进行研究, 个人推测是由于母语代码可读性的优势在日本学术界已不需再验证, 一个最可能的原因是日语命名已是业界常用实践. 这也印证了之前听说的(印象里有至少四五年前的帖子提到)外包业中一些日本软件公司使用日语命名.  1994 CiNii 論文 - 日本語プログラミングの実践とその効果  1995 CiNii 論文 - 識別子と内部コード系に着目した日本語によるプログラムの可読性の一評価  1995 CiNii 論文 - プログラム理解における日本語使用の効果  1996 CiNii 論文 - プログラム理解における日本語使用の効果(2) - 比较了有无注释的两个版本  2016 PBLにおけるソースコード引き継ぎ支援～日本語と英語を交えた識別子命名によるソースコード可読性向上の試み～  2017 ローマ字入力時の日本語識別子入力補完プラグインの開発  2018 ローマ字入力による日本語識別子入力補完プラグインの開発と評価"
    } ,
  
    {
      "title"    : "扩展Python控制台实现中文反馈信息",
      "category" : "语言设计",
      "description" : "扩展默认的Python控制台, 将报错/警告等信息翻译成中文.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2019/02/10/%E6%89%A9%E5%B1%95Python%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%87%E5%8F%8D%E9%A6%88%E4%BF%A1%E6%81%AF.html",
      "date"     : "2019-02-10 00:00:00 -0700",
      "content"  : "“中文编程”知乎专栏原文地址参考了周蟒的实现, 运行效果如下: python3 解释器.pyPython 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 05:52:31)[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwinType help, copyright, credits or license for more information.(ZhPyConsole)gt;gt;gt; 学Traceback (most recent call last):  File lt;consolegt;, line 1, in lt;modulegt;命名错误: 命名'学'未定义gt;gt;gt; for i in range(1,4):...     生...Traceback (most recent call last):  File lt;consolegt;, line 2, in lt;modulegt;命名错误: 命名'生'未定义完整源码在: 解释器.py相关源码如下, 即改写InteractiveInterpreter.showtraceback方法. 仅为演示之用, 直接用了字符串替换.:    def showtraceback(self):        sys.last_type, sys.last_value, last_tb = ei = sys.exc_info()        sys.last_traceback = last_tb        try:            行 = traceback.format_exception(ei[0], ei[1], last_tb.tb_next)            汉化行 = []            if sys.excepthook is sys.__excepthook__:                for 某行 in 行:                    for 英文 in self.字典:                        某行 = 某行.replace(英文, self.字典[英文])                    汉化行.append(某行)                self.write(''.join(汉化行))            else:                # If someone has set sys.excepthook, we let that take precedence                # over self.write                sys.excepthook(ei[0], ei[1], last_tb)        finally:            last_tb = ei = None定制sys.excepthook貌似更为合适, 还需研究如何实现.参考资料周蟒-zhpy"
    } ,
  
    {
      "title"    : "程序员面试时用中文命名写白板代码的好处",
      "category" : "命名, 面试",
      "description" : "在程序员面试时的白板写代码这关用中文命名对双方的好处.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E9%9D%A2%E8%AF%95/2019/02/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%97%B6%E7%94%A8%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E5%86%99%E7%99%BD%E6%9D%BF%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84.html",
      "date"     : "2019-02-07 00:00:00 -0700",
      "content"  : "时不时就看到”要是我面试时看到中文命名的话就xxx”的说法. 此文从不同角度简述在白板写代码这关用中文命名的好处. 欢迎补充.大前提是, 大家母语都是中文, 而且面试过程主要用中文交流. 这该是大多数国内面试的状态.从公司角度  了解面试者语文水平, 尤其是表达水平. 从中文命名中可以看出遣词造句的功底. 如前文中英文代码对比系列之Java一例  可以直接选取公司真实业务相关的独立问题, 不用顾虑是否用英文表达过于复杂(尤其是公司内命名也许就不规范的情况下), 因为可以直接用中文术语讲述问题, 同时可以考验面试者的业务理解能力  字如其人. 这点见仁见智. 估计会看到很多提笔忘字的情况. 在手写字越来越稀少的今天, 一手好字应该可以让一些人才免于被误刷掉从面试者角度  代码可读性更佳, 易于看到白板时难免的细节错误. 尤其在心理紧张状态下, 代码可读性带来的好处会比平常更明显  可以不用担心命名的英文拼写问题面试者与被面试者双方兼适用  两方交流时用中文, 命名也用中文可以避免交流/思考时中英模式来回切换  避免因为英文拼写错误/选词不当引起的时间浪费"
    } ,
  
    {
      "title"    : "Python3代码片段插件",
      "category" : "",
      "description" : "",
      "tags"     : "",
      "url"      : "/2019/01/30/python3%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E6%8F%92%E4%BB%B6.html",
      "date"     : "2019-01-30 00:00:00 -0800",
      "content"  : " yo code     _-----_     ╭──────────────────────────╮    |       |    │   Welcome to the Visual  │    |--(o)--|    │   Studio Code Extension  │   `---------´   │        generator!        │    ( _´U`_ )    ╰──────────────────────────╯    /___A___#92;   /     |  ~  |        __'.___.'__    ´   `  |° ´ Y ` ? What type of extension do you want to create? New Code SnippetsFolder location that contains Text Mate (.tmSnippet) and Sublime snippets (.sublime-snippet) or press ENTER to start with an new snippet file.? Folder name for import or none for new: ? What's the name of your extension? python3_snippets_zh? What's the identifier of your extension? python3-snippets-zh? What's the description of your extension? 使用中文命名的Python 3代码片段? What's your publisher name (more info: https://code.visualstudio.com/docs/tools/vscecli#_publishing-extensions)? CodeInChineseEnter the language for which the snippets should appear. The id is an identifier and is single, lower-case name such as 'php', 'javascript'? Language id: python   create python3-snippets-zh/.vscode/launch.json   create python3-snippets-zh/package.json   create python3-snippets-zh/vsc-extension-quickstart.md   create python3-snippets-zh/README.md   create python3-snippets-zh/CHANGELOG.md   create python3-snippets-zh/snippets/snippets.jsonYour extension python3-snippets-zh has been created!"
    } ,
  
    {
      "title"    : "VS Code创建自定义Python代码片段",
      "category" : "命名, vscode",
      "description" : "在VS code中创建中文命名的Python3代码片段.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/vscode/2019/01/29/VS-Code%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89Python%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.html",
      "date"     : "2019-01-29 00:00:00 -0700",
      "content"  : "续前文[日常]Beyond的歌里最多是”唏嘘”吗? - Python分词+词频最后的想法, 发现VS Code支持用户自定义代码片段: Creating your own snippets in Visual Studio Code尝试如下, 片段使用中文命名, 但前缀好像不能用中文(如果前缀设置为”文件”, 在源码编辑时输入”文件”后没有自动补全弹窗), 应该与自动补全机制有关.片段定义:    读文件:         prefix: file,         body: [            with open(1:文件全路径) as 文件:,            #92;t内容 = 文件.read()         ],         description: 读取某文件    ,    读所有文件:         prefix: file,         body: [            import os,            路径 = '.',            for 文件名 in os.listdir(路径):,            #92;twith open(os.path.join(路径, 文件名)) as 文件:,            #92;t#92;t内容 = 文件.read()         ],         description: 读取某目录下所有文件    下一步把这些片段打包成扩展: Snippet Guide"
    } ,
  
    {
      "title"    : "[日常]Beyond的歌里最多是&quot;唏嘘&quot;吗? - Python分词+词频",
      "category" : "命名, 教程",
      "description" : "用结巴分词分析Beyond歌词, 得出词频统计.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2019/01/28/%E6%97%A5%E5%B8%B8-Beyond%E7%9A%84%E6%AD%8C%E9%87%8C%E6%9C%80%E5%A4%9A%E6%98%AF_%E5%94%8F%E5%98%98_%E5%90%97_Python%E5%88%86%E8%AF%8D_%E8%AF%8D%E9%A2%91.html",
      "date"     : "2019-01-28 00:00:00 -0700",
      "content"  : "看了一个Beyond的纪录片, 提到这个. 觉得心有不甘, 于是搜集了24首歌词, 用Python做了简单分词和词频统计.源码(包括歌词)在: program-in-chinese/study统计了总出现次数(词频列表)和词出现在歌曲的数目(词所在文件数列表). 前者算进了所有重复歌词, 后者是算某个词出现在了几首歌中.源码:import jiebaimport os所有词 = []词频表 = 词所在文件 = 词所在文件数 = 路径 = 数据for 文件名 in os.listdir(路径):    print(文件名)    with open(os.path.join(路径, 文件名)) as 文件:        内容 = 文件.read()        分词结果 = jieba.cut(内容)        for 词 in 分词结果:            if 词 !=   and len(词) != 1:                所有词.append(词)                if 词 in 词频表:                    词频表[词] += 1                    词所在文件[词].add(文件名)                else:                    词频表[词] = 1                    词所在文件[词] = set([文件名])for 词 in 词所在文件:    词所在文件数[词] = len(词所在文件[词])# 词频列表 = sorted(词频表.items(), key=lambda d: d[1], reverse=True)词所在文件数列表 = sorted(词所在文件数.items(), key=lambda d: d[1], reverse=True)print(词所在文件数列表)前者的最高频几个中文词(完整的在”所有词频输出.txt”):  (‘多少’, 22), (‘一生’, 21), (‘多么’, 20), (‘理想’, 19), (‘没有’, 19), (‘一天’, 19), (‘Woo’, 18), (‘今天’, 18), (‘心中’, 16), (‘一起’, 16), (‘OH’, 16), (‘唏嘘’, 15), (‘彼此’, 14)后者的前几位(完整的在”所在文件数.txt”):  (‘多少’, 9), (‘心中’, 8), (‘没有’, 8), (‘一切’, 8), (‘理想’, 7), (‘Woo’, 7), (‘一生’, 7), (‘今天’, 7), (‘唏嘘’, 6), (‘拥有’, 6), (‘可否’, 5), (‘多么’, 5), (‘风雨’, 5), (‘感觉’, 5), (‘天空’, 5), (‘心里’, 5), (‘岁月’, 5)至少这几首经典里, “理想”比”唏嘘”更多.觉得如果有个IDE插件能把一些常用的Python操作集合起来, 如果组织得好, 会挺有用. 因为写这个例子里, 包括取目录下的文件, 读取文本文件, 字典排序等等, 自己的第一反应还是到处找现成代码黏贴."
    } ,
  
    {
      "title"    : "JavaScript实现ZLOGO: 性能改进",
      "category" : "命名, 算法",
      "description" : "基于JavaScript和Antlr4实现简单的中文LOGO语法, 性能改进. Implement simple LOGO language using JavaScript and Antlr4. Improve performance.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%AE%97%E6%B3%95/2019/01/23/JavaScript%E5%AE%9E%E7%8E%B0ZLOGO-%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B.html",
      "date"     : "2019-01-23 00:00:00 -0700",
      "content"  : "主攻前文吴烜：JavaScript实现ZLOGO: 界面改进与速度可调的几个性能问题在线演示: 圈3源码仍在: program-in-chinese/quan3之前是在绘制过程中计算每帧需要绘制的线段, 在尝试改进的过程中很快发现问题太多且不易测试. 接着在某早晨”醒悟”到应该而且可以在绘制前计算好每一帧的步进路径表. 不仅可以避免绘制卡顿问题, 还便于测试(因为是纯JS实现, 不需夹杂DOM操作). 于是通过如下递归代码实现了截取指定位置的路径表:// 返回截取部分: 路径表, 剩余部分: 路径表// 如果 开始位置 gt;= 终止位置, 返回[], 所有function 截取路径表(路径表, 开始位置, 终止位置)   if (开始位置 gt;= 终止位置)     return 截取部分: [], 剩余部分: 路径表;    if (路径表.length == 0)     return 截取部分: [], 剩余部分: [];   else if (路径表.length == 1)     return 截取路径(路径表[0], 开始位置, 终止位置);   else     var 段 = 路径表[0];    var 长度 = 段.长度;    if (开始位置 gt;= 长度)       路径表.shift();      return 截取路径表(路径表, 开始位置 - 长度, 终止位置 - 长度);     else if (开始位置 lt; 长度 amp;amp; 终止位置 lt; 长度)       var 前段 = 截取路径(路径表[0], 开始位置, 终止位置);      路径表.shift();      return 截取部分: 前段.截取部分, 剩余部分: 前段.剩余部分.concat(路径表);     else       var 前段 = 截取路径(路径表[0], 开始位置, 长度);      路径表.shift();      var 后段 = 截取路径表(路径表, 0, 终止位置 - 长度);      return 截取部分: 前段.截取部分.concat(后段.截取部分), 剩余部分: 后段.剩余部分;      原本为去掉路径表第一项, 使用了slice(), 测试时发现耗时接近O(n^3). 导致点击”运行”后的运算耗时在复杂时(比如gt;10000线段的图形)太长(停顿超过1秒)难以接受. 改为shift()后, 粗测不超过O(n^2), 暂未深入研究.这里是获取每一帧的路径表(每帧前进的长度等于”速度”):function 按步进拆分路径表(路径表, 速度)   var 所有段 = [];  while (路径表.length gt; 0)     var 拆分路径 = 截取路径表(路径表, 0, 速度);    所有段.push(拆分路径.截取部分);    路径表 = 拆分路径.剩余部分;    return 所有段;感觉已经达到可以让用户玩玩的程度. 接下来视反馈决定改进方向."
    } ,
  
    {
      "title"    : "JavaScript实现ZLOGO: 界面改进与速度可调",
      "category" : "语言设计",
      "description" : "基于JavaScript和Antlr4实现简单的中文LOGO语法, 界面改进, 可调速度. Implement simple LOGO language using JavaScript and Antlr4.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2019/01/20/JavaScript%E5%AE%9E%E7%8E%B0ZLOGO-%E7%95%8C%E9%9D%A2%E6%94%B9%E8%BF%9B%E4%B8%8E%E9%80%9F%E5%BA%A6%E5%8F%AF%E8%B0%83.html",
      "date"     : "2019-01-20 00:00:00 -0700",
      "content"  : "续前文JavaScript实现ZLOGO: 前进方向和速度在线演示地址: http://codeinchinese.com/E59C883/E59C883.html源码仍在: program-in-chinese/quan3主要功能改进是在界面可以选择速度. 其他界面布局改进有:  在ipad横屏下显示正常(1024x768)  (前文问题1) 改正了有些浏览器”蚂蚁”对不准的问题(在火狐, Opera, Safari下测试)  加大字体和按钮待解决问题蚂蚁走位有偏移, 速度越快越明显 · Issue #9 · program-in-chinese/quan3 上面视频可以看到最后蚂蚁没有回到原点. 经测试貌似与速度有关, 尚未确定原因.避免O(n^2)的绘制过程 · Issue #8 · program-in-chinese/quan3 上面视频可见越到后面行进越慢, 应该与每帧绘制线段数逐渐增加有关. 上面例子最后一帧绘制的总线段数有7200段.避免在绘制每帧时重置背景色 · Issue #10 · program-in-chinese/quan3 在ipad下测试感觉蚂蚁行进有卡顿感, 不确定是否由于当前每帧都重置背景色. 应该只需在重新运行时再清理整个画板.[继续改进] 添加方向指示 · Issue #3 · program-in-chinese/quan3 还需:  更雅致点的图标  在初始状态(白板)时显示图标默认状态(方向/位置)  在界面提供选项, 以开/关图标显示部分p5js API继续汉化, 如line, background · Issue #11 · program-in-chinese/quan3"
    } ,
  
    {
      "title"    : "[日常]mov文件转换为gif",
      "category" : "命名, 教程",
      "description" : "用ruby调用ffmpeg转换mov文件为gif. Use ruby to call ffmpeg to transform mov to gif file.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2019/01/13/%E6%97%A5%E5%B8%B8-mov%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAgif.html",
      "date"     : "2019-01-13 00:00:00 -0700",
      "content"  : "因为需要将之前mac下用QuickTime录屏生成的文件(mov格式)转换成gif文件, 便于传到某些博客平台, 于是找到了这个转换工具, 已将原代码的命名中文化并简化. Ruby和视频转换都是新手, 请多指教.之前JavaScript实现ZLOGO: 前进方向和速度有两个mov文件, 下面为转换出的gif:“轮胎”:田字格:下面是命名中文化后的源码. 注意: 需将mov文件置于media目录下, 并自行修改mov文件名和mov视频大小值.# encoding: utf-8APP_ROOT = File.dirname(__FILE__)mov文件名 = 1214_田字格class Converter  mov视频大小 = 1032x542 # 查看mov文件属性  # Default path to ffmpeg installed by homebrew  ffmpeg   = File.join('/', 'usr', 'local', 'bin', 'ffmpeg')  # Default path to gifsicle installed by homebrew  gifsicle = File.join('/', 'usr', 'local', 'bin', 'gifsicle')  像素格式 = rgb8  # Tell ffmpeg to reduce the frame rate from to 30  帧数 = 30  # Tell gifsicle to delay 30ms between each gif (in ms)  延时 = 3  # Requests that gifsicle use the slowest/most file-size optimization  优化 = 3    def initialize(输入, 输出)    命令 = #ffmpeg -i #输入 -s #mov视频大小 -pix_fmt #像素格式 -r #帧数 -f gif - | #gifsicle --optimize=#优化 --delay=#延时 gt; #输出        x[ #命令 ]  end  end# Be careful not to use spa ces.输入 = File.join(APP_ROOT, 'media', mov文件名 + '.mov')输出 = File.join(APP_ROOT, 'media', mov文件名 + '.gif')Converter.new(输入,输出)中文命名相关问题开头需加# encoding: utf-8, 否则报错invalid multibyte char (US-ASCII)如果类名改为转换器, 运行报错如下. 不知是否Ruby的限制. ruby 转换器.rb 转换器.rb:7: class/module name must be CONSTANT"
    } ,
  
    {
      "title"    : "VS Code英汉词典v0.0.8: 批量翻译文件部分命名",
      "category" : "命名, 翻译",
      "description" : "实现VS code插件, 基于本地词典数据, 提供英汉翻译功能, 添加批量命名翻译功能. Improve vscode extension to translate English word or phrase to Chinese, by supporting translating all identifiers in a file.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/12/25/VS-Code%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8v0.0.8-%E6%89%B9%E9%87%8F%E7%BF%BB%E8%AF%91%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86%E5%91%BD%E5%90%8D.html",
      "date"     : "2018-12-25 00:00:00 -0700",
      "content"  : "续前文: VS Code英汉词典进化效果演示: 翻译文件所有命名vscode”英汉词典”插件地址: 官方链接现在实现的效果比之前的演示差很多, 因为executeDocumentSymbolProvider返回的标识符比想象中的少很多. 而且像main这样的常用术语还未进行合适的手工翻译.提取文件中标识符并翻译的相关部分代码:  provideTextDocumentContent(uri: vscode.Uri): string | Thenablelt;stringgt;     // TODO: 如果没有当前活跃编辑器, 返回空    let textEditor = vscode.window.activeTextEditor;    return vscode.commands.executeCommandlt;vscode.DocumentSymbol[]gt;('vscode.executeDocumentSymbolProvider', textEditor.document.uri)      .then(        (symbols: Arraylt;vscode.DocumentSymbolgt;) =gt;           for (var 标识符 of symbols)             this.原命名列表.push(释义处理.消除英文小括号内容(标识符.name));            for (var 子标识符 of 标识符.children)               this.原命名列表.push(释义处理.消除英文小括号内容(子标识符.name));                                // 长词先查释义, 以免出现一个命名xxxxyyyy先替换了yyyy而xxxx未替换的情况          this.原命名列表.sort(function (a, b)  return b.length - a.length );          var 新内容 = textEditor.document.getText();          for (var 原命名 of this.原命名列表)             let 中文释义 = 查词.取释义(原命名).释义;            let 翻译 = 释义处理.取字段中所有词(原命名).length gt; 1              ? 中文释义              : 释义处理.首选(中文释义, 词典常量.词性_计算机);            if (翻译)               新内容 = this._replaceAll(新内容, 原命名, 翻译);                                return 新内容;              )  ————– 坑 ————–之后废了一个小时在这个出现过的这个插件发布才会碰到的问题: Error: Item has already been added. Key in dictionary · Issue #5 · program-in-chinese/vscode_english_chinese_dictionary初步分析有两个问题:  如果两个中文文件名有同样长度, 比如”查词.ts”和”功用.ts”, 在本地打包不会有问题(vsce package), 但是在发布时(vsce publish), 估计服务端在保存到后端时会将这两个文件误识别成重命名.  更隐蔽一点的, 在无数次重命名后发现, 在运行publish时, 它不会清理本地的js输出文件夹(这里是out/). 因此在重命名过程中生成的所有.js文件都仍然存在. 导致这无数次重命名都没有效果.打算复现并报告第一点这个bug. 对第二点的权宜之计—发布前手动清理out目录!"
    } ,
  
    {
      "title"    : "在国内原创开源项目中使用中文命名的意义与方式",
      "category" : "命名, 开源",
      "description" : "在国内原创开源项目中用中文命名带来的好处, 以及几种方式.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E5%BC%80%E6%BA%90/2018/12/22/%E5%9C%A8%E5%9B%BD%E5%86%85%E5%8E%9F%E5%88%9B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E7%9A%84%E6%84%8F%E4%B9%89%E4%B8%8E%E6%96%B9%E5%BC%8F.html",
      "date"     : "2018-12-22 00:00:00 -0700",
      "content"  : "注: 个人支持踊跃参与国外开源项目. 此文面向读者仅为母语是中文的并有意原创开源项目的开发者.源自在代码中推广中文命名对中国开源软件的意义 - V2EX. 中文命名的技术优势在对在代码中使用中文命名的质疑与回应“没有好处”已明, 对于原创者本身来说, 使用中文命名可以让代码可读性更高, 维护成本更低. 此文更侧重开发者参与度和推广方面.类似功能的两个库, 一个提供中文API, 一个提供英文API, 个人相信对国内用户来说前者的接受度会更高. 因此无论代码命名选择的是英文或中文, 基于已有英文API额外提供一套同样功能的中文API对国内推广有益无害, 而维护这套API的投入相对较小. 用户群越大, 潜在的参与开发者也会越多. 这对于独立开源项目(非商业公司支持的)来说尤为重要, 直接决定项目的可持续性.之前在 v2 碰到一个小程序开发请求帖(结贴), 之后催生了五笔编码编辑器这个微型开源项目.  项目开始时, 请求者并无编程经验, 在原型搭建时, 我提到会使用中文命名, 之后的维护希望由他多出力,  感觉那时他的动力并不大. 但最后实现基本功能后, 他提交了之后的一系列改进 PR 及相关测试, 基本上我除了合并和审核之外没有投入其他精力.可见中文命名对于鼓励非专业程序员参与开源项目的作用. 开源项目的基本架构搭建之后, 如果项目本身使用的是中文命名, 用户(往往是非专业开发者)应该会更有动力去学习代码. 并不是说英文命名肯定会阻止参与, 但肯定会让很大一部分非专业程序员望而却步. 而且开源项目很大一部分工作量就在于后期维护, 界面改进, 相似功能的堆积, 以及相关测试. 这部分本可以由原作者之外的参与者(用户)来实现,  原作者就可以专心投入到架构/大功能的优化改进上. 久而久之, 新手也会逐渐成为核心贡献者.对此最常见的一个问题是, “用中文命名之后, 国外开发者如何参与”? 前文对在代码中使用中文命名的质疑与回应的”不利于非中文编程者贡献”以及阐述过. 这里补充一些.国内开源项目大概分类如下:  针对用户群较小, 或者用户群限于国内(如与中文处理相关的工具), 自然维护的也是国内开发者. 对这些项目, 不会中文的国外开发者几乎不会使用, 更不用说合作.  针对用户群很广并且国际化, 但已有类似功能的国外开源项目. 大多数国外开发者一般首选那些代码可读性更好也更成熟的项目. 在代码质量和整体功能没有级别差距的情况下, 代码可读性决定了开发者更偏好哪个项目, 而国人的代码在国外开发者看来, 可读性很难超过母语是英文的开发者编写的代码.  功能非常独特并且用户群很国际化, 而且还未有国外类似功能的开源项目 – 暂时还没看到这样的项目, 欢迎指点.中文命名最适用的是第一类, 因为无论用户还是开发者都会限于国内. 这类从数量上应该占到国内开源项目的绝大部分.至于第二类, 项目开始时决定采用中文还是英文命名取决于原创者对国内外开发者参与度的判断. 如果认为在很长时间内国外用户会很少, 可以采用首先在代码中使用中文命名但提供额外的英文API的方式, 再根据国外用户参与开发的倾向性和项目本身的需要进行调整, 当然如果国内开发者的参与已经足够项目持续, 就不需再改用英文命名."
    } ,
  
    {
      "title"    : "VS Code英汉词典进化效果演示: 翻译文件所有命名",
      "category" : "命名, 翻译",
      "description" : "实现VS code插件, 基于本地词典数据, 提供英汉翻译功能, 演示批量命名翻译功能. Demonstrate a new feature in vscode extension to translate English word or phrase to Chinese, by supporting translating all identifiers in a file.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/12/16/VS-Code%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E8%BF%9B%E5%8C%96%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA-%E7%BF%BB%E8%AF%91%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E5%91%BD%E5%90%8D.html",
      "date"     : "2018-12-16 00:00:00 -0700",
      "content"  : "续VS Code英汉词典插件v0.0.7-尝试词性搭配, 下一个功能打算实现文件的批量命名翻译: 批量代码汉化工具 · Issue #86 · program-in-chinese/overview功能仍未完成. 下面仅为效果演示之用. 并未实际调用英汉词典数据:相关源码新建编辑器内容提供者:'use strict';import * as vscode from 'vscode';export default class Provider implements vscode.TextDocumentContentProvider    static scheme = 'references';    private _演示字典: Maplt;String, Stringgt; = new Map([        [BasicCalculator, 基本的计算器],        [Calculator, 计算器类],        [calculator, 计算器],        [add, 加],        [subtract, 減],        [multiply, 乘],        [divide, 除],        [first, 第一],        [second, 第二],        [number, 数],        [divisor, 被除数]    ]);    dispose()         provideTextDocumentContent(uri: vscode.Uri): string | Thenablelt;stringgt;         var 新内容 = vscode.window.activeTextEditor.document.getText();        for (var 原命名 of this._演示字典.keys())           新内容 = this._replaceAll(新内容, 原命名, this._演示字典.get(原命名));                return 新内容;        private _replaceAll(str, find, replace)     return str.replace(new RegExp(find, 'g'), replace);  let seq = 0;export function encodeLocation(uri: vscode.Uri, pos: vscode.Position): vscode.Uri     const query = JSON.stringify([uri.toString(), pos.line, pos.character]);    return vscode.Uri.parse(`Provider.scheme:test.java?query#seq++`);添加并列编辑器(“状态框”为现有功能):    const provider = new ContentProvider();    const providerRegistrations = Disposable.from(        workspace.registerTextDocumentContentProvider(ContentProvider.scheme, provider)    );    const commandRegistration = commands.registerTextEditorCommand('editor.翻译标识符', editor =gt;         const uri = encodeLocation(editor.document.uri, editor.selection.active);        return workspace.openTextDocument(uri).then(doc =gt; window.showTextDocument(doc, editor.viewColumn + 1));    );    const 状态框 = window.createStatusBarItem(StatusBarAlignment.Right, 100);    状态框.command = 'extension.翻译选中文本';    context.subscriptions.push(        provider,        commandRegistration,        providerRegistrations,        状态框    );发现问题似乎vscode对中文命名的高亮有些问题:对比英文命名的高亮:尴尬的彩蛋:经VS Code 英汉词典进化效果演示: 翻译文件所有命名 - V2EX指出, “演示字典”部分有个错误: divisor是”除数”. 当然, 本身英汉词典数据是正确的(如下). 功能实现之后应该不会有此问题:"
    } ,
  
    {
      "title"    : "JavaScript实现ZLOGO: 前进方向和速度",
      "category" : "语言设计",
      "description" : "基于JavaScript和Antlr4实现简单的中文LOGO语法, 添加图标显示前进方向, 可修改速度. Implement simple LOGO language using JavaScript and Antlr4. Add icon to show direction, and support to change speed.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/12/14/JavaScript%E5%AE%9E%E7%8E%B0ZLOGO-%E5%89%8D%E8%BF%9B%E6%96%B9%E5%90%91%E5%92%8C%E9%80%9F%E5%BA%A6.html",
      "date"     : "2018-12-14 00:00:00 -0700",
      "content"  : "系列前文:  JavaScript实现ZLOGO子集: 前进+转向  JavaScript实现ZLOGO子集: 单层循环功能  JavaScript实现ZLOGO子集: 测试用例  JavaScript实现ZLOGO: 用语法树实现多层循环功能上, 添加了蚂蚁图标显示当前前进方向, 并可通过修改源码实现行进速度. 并未对语言本身进行改进. 另有一点界面改进. 源码仍在: program-in-chinese/quan3在线演示仍在: 圈3演示默认2倍行进速度(相比之前)画田字格:8倍行进速度画”轮胎” (LOGO源码链接):部分相关源码下面是为添加蚂蚁和定制速度作的主要修改:+  if (!指示方向图) +    指示方向图 = createImg(图标/蚂蚁头向上.png)+    指示方向图.size(36, 34);+  +   // TODO: 提取到二阶函数   绘制 = function()      var 当前序号 = 序号;+    const 速度 = 2;     background(255, 255, 255);      for (var i = 0; i lt; 路径表.length; i++ )  -33,16 +41,20  const 生成指令序列 = require(./语法树处理).生成指令序列       var 起点 = 段.起点;       var 终点 = 段.终点;       var 距离 = 段.长度;-      if (当前序号 lt; 距离) -        line(起点.x, 起点.y, 起点.x + (终点.x - 起点.x) * 当前序号 / 距离, 起点.y + (终点.y - 起点.y) * 当前序号 / 距离);+      if (当前序号 lt; 距离 / 速度) +        var 当前x = 起点.x + (终点.x - 起点.x) * 当前序号 * 速度 / 距离;+        var 当前y = 起点.y + (终点.y - 起点.y) * 当前序号 * 速度 / 距离;+        指示方向图.position(当前x + 238, 当前y - 8); // TODO: 需要对准线头+        指示方向图.style(transform, rotate( + (90 - 段.前进角度) + deg))+        line(起点.x, 起点.y, 当前x, 当前y);         break;        else          line(起点.x, 起点.y, 终点.x, 终点.y);-        当前序号 = 当前序号 - 段.长度;+        当前序号 = 当前序号 - 段.长度 / 速度;                 -    序号 ++;+    序号 += 速度;   可能改进  蚂蚁图标在火狐下没有对准走线, 应该是上面TODO的问题  改进蚂蚁图标, 需在开始时就显示  可在界面直接修改行进速度, 隐藏蚂蚁  部分p5js API继续汉化, 如line, background"
    } ,
  
    {
      "title"    : "Scala疑似中文命名问题后续",
      "category" : "命名, Scala",
      "description" : "对一个中文命名的问题进行调查后的小结. Some investigation for the issue with Chinese naming found earlier.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/scala/2018/12/10/Scala%E7%96%91%E4%BC%BC%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E9%97%AE%E9%A2%98%E5%90%8E%E7%BB%AD.html",
      "date"     : "2018-12-10 00:00:00 -0700",
      "content"  : "上文疑似bug_中文代码示例之Programming in Scala笔记第九十章的问题, 正要在scala源码项目报告bug, 决定先在gitter的scala频道确认一下问题性质. 颇有收获, 小结如下.发问之后, 很快就有社区成员发现行字似乎是被认作了大写字符.前文的例子是:scalagt; for ((行1, 行2) lt;- Array(1,2) zip Array(a, b))     | yield 行1 + 行2lt;consolegt;:12: error: not found: value 行1       for ((行1, 行2) lt;- Array(1,2) zip Array(a, b))             ^lt;consolegt;:12: error: not found: value 行2       for ((行1, 行2) lt;- Array(1,2) zip Array(a, b))                 ^lt;consolegt;:13: error: not found: value 行1       yield 行1 + 行2             ^lt;consolegt;:13: error: not found: value 行2       yield 行1 + 行2                  ^自己试了如果改为下面的英文大写开头会报同样错误, 因此并非中文字符特有问题:for ((Line1, Line2) lt;- Array(1,2) zip Array(a, b))yield Line1 + Line2接着一位scala源码贡献者指出用于模式匹配的varid必须是小写或下划线开头. 有两种解决方法:// 添加下划线前缀for ((_行1, _行2) lt;- Array(1,2) zip Array(a, b)) yield _行1 + _行2// 用 _for ((行1  _, 行2  _) lt;- Array(1,2) zip Array(a, b)) yield 行1 + 行2(他还指出了一个相关bug, 但未深究)第二种方法允许所有标识符用于模式匹配, 而不限于varid. 他还立刻为此更新了scala语法文档为何行字符貌似被认作了大写字符呢? 因为scala语法规定小写字符是Unicode字符集的”Ll”区间:  Letters, which include lower case letters (Ll), upper case letters (Lu), titlecase letters (Lt), other letters (Lo), letter numerals (Nl) and the two characters #92;u0024 ‘’ and #92;u005F ‘_’.而Unicode字符Ll部分并未包含中文字符.至此, 基本确定这个问题并非中文命名特有问题, 也不是bug. 在这种模式匹配用法时必须使用小写字符开头的确是个限制, 但至少有不大麻烦的解决方案.发现那位源码贡献者刚又给出了一个2013年scala语言作者对模式匹配和大写字符的考虑: 链接"
    } ,
  
    {
      "title"    : "疑似bug_中文代码示例之Programming in Scala笔记第九十章",
      "category" : "命名, Scala",
      "description" : "对Programming in Scala书本中的九十章示例代码进行命名中文化, 发现一个问题. Translate identifiers in sample programs to Chinese, and found an issue.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/scala/2018/12/09/%E7%96%91%E4%BC%BCbug_%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BProgramming-in-Scala%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B9%9D%E5%8D%81%E7%AB%A0.html",
      "date"     : "2018-12-09 00:00:00 -0700",
      "content"  : "续前文: 中文代码示例之Programming in Scala笔记第七八章源文档库: program-in-chinese/Programming_in_Scala_study_notes_zh疑似中文命名bugprogram-in-chinese/Programming_in_Scala_study_notes_zh. 复现如下. 需要深究:scalagt; for ((行1, 行2) lt;- Array(1,2) zip Array(a, b))     | yield 行1 + 行2lt;consolegt;:12: error: not found: value 行1       for ((行1, 行2) lt;- Array(1,2) zip Array(a, b))             ^lt;consolegt;:12: error: not found: value 行2       for ((行1, 行2) lt;- Array(1,2) zip Array(a, b))                 ^lt;consolegt;:13: error: not found: value 行1       yield 行1 + 行2             ^lt;consolegt;:13: error: not found: value 行2       yield 行1 + 行2                  ^scalagt; for ((l1, l2) lt;- Array(1,2) zip Array(a, b))     | yield l1 + l2res1: Array[String] = Array(1a, 2b)第九章 控制抽象  def 文件匹配(查询: String, 匹配器: (String, String) =gt; Boolean) =    for (文件 lt;- 此处文件; if 匹配器(文件.getName, 查询))      yield 文件    def 文件名结尾(查询: String) =    文件匹配(查询, _.endsWith(_))    def 文件名包括(查询: String) =    文件匹配(查询, _.contains(_))    def 文件名正则匹配(查询: String) =    文件匹配(查询, _.matches(_))第十章 组合和继承import 元素类.元素object 螺旋   val 空格 = 元素( )  val 角 = 元素(+)  def 螺旋(边数: Int, 方向: Int): 元素类 =     if (边数 == 1)      元素(+)    else       val 旋 = 螺旋(边数 - 1, (方向 + 3)  4)      def 竖条 = 元素('|', 1, 旋.高度)      def 横条 = 元素('-', 旋.宽度, 1)      if (方向 == 0)        (角 在旁 横条) 在上 (旋 在旁 空格)      else if (方向 == 1)        (旋 在上 空格) 在旁 (角 在上 竖条)      else if (方向 == 2)        (空格 在旁 旋) 在上 (横条 在旁 角)      else        (竖条 在上 角) 在旁 (空格 在上 旋)        def main(参数: Array[String]) =     val 边数 = 参数(0).toInt    println(螺旋(边数, 0))  运行效果: scala 螺旋 17+----------------|                | +------------+ | |            | | | +--------+ | | | |        | | | | | +----+ | | | | | |    | | | | | | | ++ | | | | | | |  | | | | | | | +--+ | | | | | |      | | | | | +------+ | | | |          | | | +----------+ | |              | +--------------+ 敬请期待后续!"
    } ,
  
    {
      "title"    : "VS Code英汉词典插件v0.0.7-尝试词性搭配",
      "category" : "命名, 词典",
      "description" : "实现VS code插件, 基于本地词典数据, 提供英汉翻译功能, 添加词性搭配功能. Improve vscode extension to translate English word or phrase to Chinese from JavaScript to TypeScript.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E8%AF%8D%E5%85%B8/2018/12/03/VS-Code%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E6%8F%92%E4%BB%B6v0.0.7-%E5%B0%9D%E8%AF%95%E8%AF%8D%E6%80%A7%E6%90%AD%E9%85%8D.html",
      "date"     : "2018-12-03 00:00:00 -0700",
      "content"  : "续上文VS Code英汉词典插件v0.0.6-改为TS实现, 加测试后, 继续重构(提取常量, 避免var, 添加类型等等), 并完善测试.测试方法参考: Testing Visual Studio Code Extensions, 调试也支持. 觉得虽然启动测试有一定开销(似乎必需启动一个vscode个例), 但还可以接受. 在重构过程中测试用例起了保驾作用.借助TypeScript特性, 为所有的接口添加了类型, 比如:export interface 词形变化   类型: string;  变化: string;export interface 单词条   词: string;  释义: string;  词形: 词形变化[];export interface 字段释义   原字段: string;  释义: string;  各词: 单词条[];尝试形容词+名词搭配优先:export function 选取释义(所有词条: 模型.单词条[], 所有词: string[]): string[]   let 所有释义 = [];  // TODO: 重构  if (所有词条.length == 2)     let 词1释义 = 所有词条[0].释义;    let 词2释义 = 所有词条[1].释义;    if (词1释义 amp;amp; 取按词性释义(词1释义).has(词典常量.词性_形容词)      amp;amp; 词2释义 amp;amp; 取按词性释义(词2释义).has(词典常量.词性_名词))       所有释义.push(首选(词1释义, 词典常量.词性_形容词));      所有释义.push(首选(词2释义, 词典常量.词性_名词));      return (所有释义);        for (let i = 0; i lt; 所有词条.length; i++)     let 词条 = 所有词条[i];    所有释义.push(词条.释义 ? 首选(词条.释义, 词典常量.词性_计算机) : 所有词[i]);    return 所有释义;下面的打算:改进命名: 常用命名/缩写的手工翻译 · Issue #16 · program-in-chinese/vscode_english_chinese_dictionary添加并列编辑器形式的源码翻译: 批量代码汉化工具 · Issue #86 · program-in-chinese/overview"
    } ,
  
    {
      "title"    : "[合辑]最精致的python访客登记系统实例项目,微信机器人不再只当人工智障",
      "category" : "命名, python",
      "description" : "微信机器人助手做的访客登记系统的示例.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/python/2018/12/01/%E5%90%88%E8%BE%91-%E6%9C%80%E7%B2%BE%E8%87%B4%E7%9A%84python%E8%AE%BF%E5%AE%A2%E7%99%BB%E8%AE%B0%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B%E9%A1%B9%E7%9B%AE,%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%8D%E5%86%8D%E5%8F%AA%E5%BD%93%E4%BA%BA%E5%B7%A5%E6%99%BA%E9%9A%9C.html",
      "date"     : "2018-12-01 00:00:00 -0700",
      "content"  : "原作者为知乎号浩海泛舟中文编程,最精致的python访客登记系统实例项目,微信机器人不再只当人工智障——01中文编程,最精致的python访客登记系统实例项目,微信机器人不再只当人工智障——02中文编程,最精致的python访客登记系统实例项目,微信机器人不再只当人工智障——03中文编程,最精致的python访客登记系统实例项目,微信机器人不再只当人工智障——04中文编程,最精致的python访客登记系统实例项目,微信机器人不再只当人工智障——05中文编程,最精致的python访客登记系统实例项目,微信机器人不再只当人工智障——06中文编程,最精致的python访客登记系统实例项目,微信机器人不再只当人工智障——07中文编程,最精致的python访客登记系统实例项目,微信机器人不再只当人工智障——08"
    } ,
  
    {
      "title"    : "VS Code英汉词典插件v0.0.6-改为TS实现, 加测试",
      "category" : "命名, 词典",
      "description" : "实现VS code插件, 基于本地词典数据, 提供英汉翻译功能, 从JavaScript改为TypeScript实现. Rewrite the vscode extension to translate English word or phrase to Chinese from JavaScript to TypeScript.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E8%AF%8D%E5%85%B8/2018/11/29/VS-Code%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E6%8F%92%E4%BB%B6v0.0.6-%E6%94%B9%E4%B8%BATS%E5%AE%9E%E7%8E%B0,-%E5%8A%A0%E6%B5%8B%E8%AF%95.html",
      "date"     : "2018-11-29 00:00:00 -0700",
      "content"  : "如前文VS Code英汉词典插件v0.0.4-驼峰下划线命名打算, 首先将JS源码改为TypeScript实现, 并添加了必要的测试.昨天得知vue.js 3.0会用TypeScript实现, 正好通过这个插件对TypeScript熟悉一下, 好为手工翻译Vue.js源码:尝试重命名标识符与文本转为对新版vue.js的源码翻译作准备.源码暂时仍在分支未合并(现已合并): program-in-chinese/vscode_english_chinese_dictionary改为TS实现参考了官方文档: Migrating from JavaScript, 比想象中的容易些(特别是改文件扩展名那一步), 主要修改是修正exports-gt;export, require-gt;import · program-in-chinese/vscode_english_chinese_dictionarycf6a40b , 还有for(.. of ..)需添加var.动态导入多个词典数据费了点功夫: 修正: not a module编译错误 · program-in-chinese/vscode_english_chinese_dictionary470f81a测试运行和调试感觉挺方便. 毕竟VS Code就是TS开发的. 基本覆盖了之前的手工测试. 有测试之后, 之后的重构(使用TS的非JS特性等等)和功能改进就方便多了.遛测试源码:import * as assert from 'assert'import * as 查词 from '../src/查词'suite(查词测试, () =gt;   test(取释义, () =gt;     assert.deepEqual(              原字段: shipment,        释义: n. 装船, 出货#92;#92;n[经] 运送, 运送(寄出)货物, 装载,        各词: [                      词: shipment, 释义: n. 装船, 出货#92;#92;n[经] 运送, 运送(寄出)货物, 装载,            词形: [               类型: 名词复数形式, 变化: shipments             ]                  ]      ,      查词.取释义(shipment)    );    assert.deepEqual(              原字段: ACCOUNT,        释义: n. 报告, 解释, 估价, 理由, 利润, 算账, 帐目#92;#92;nvi. 报帐, 解释, 导致, 报偿, 占, 杀死#92;#92;nvt. 认为#92;#92;n[计] 帐户, 帐号,        各词: [                      词: account, 释义: n. 报告, 解释, 估价, 理由, 利润, 算账, 帐目#92;#92;nvi. 报帐, 解释, 导致, 报偿, 占, 杀死#92;#92;nvt. 认为#92;#92;n[计] 帐户, 帐号,            词形: [               变化: accounts, 类型: 名词复数形式 ,               变化: accounted, 类型: 过去分词 ,               变化: accounting, 类型: 现在分词 ,               变化: accounts, 类型: 第三人称单数 ,               变化: accounted, 类型: 过去式             ]                  ]      ,      查词.取释义(ACCOUNT)    );    assert.deepEqual(              原字段: seconds,        释义: n. 次级品, 二等品,        各词: [                      词: seconds, 释义: n. 次级品, 二等品,            词形: [                              变化: [                  名词复数形式,                  第三人称单数                ],                类型: 原型变换形式              ,               类型: 原型, 变化: second             ]                  ]      ,      查词.取释义(seconds)    );    assert.equal(执行路径, 查词.取释义(execPath).释义);    assert.equal(字符串_译码器, 查词.取释义(string_decoder).释义);    assert.equal(帐户_数字, 查词.取释义(ACCOUNT_NUMBER).释义);    assert.equal(帐户数字, 查词.取释义(_ACCOUNT_NUMBER).释义);    assert.equal(取得指令秒, 查词.取释义(getSeconds).释义);    assert.equal(使用颜色, 查词.取释义(useColors).释义);    assert.equal(fs路径, 查词.取释义(fsPath).释义);  ););继续暗黑彩蛋:发布0.0.6后立即安装试用, 结果傻眼, useColors仍然翻成”使用国旗”. 从官网下载了vsix文件解压看了源码的确是更新了的. 压抑住了重新发布0.0.7的冲动, 重新安装后重启vscode, 结果正常. 难道哪里有缓存问题?"
    } ,
  
    {
      "title"    : "中文代码示例之Programming in Scala笔记第七八章",
      "category" : "命名, Scala",
      "description" : "对Programming in Scala书本中的七八章示例代码进行命名中文化. Translate identifiers in sample programs to Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/scala/2018/11/27/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BProgramming-in-Scala%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%83%E5%85%AB%E7%AB%A0.html",
      "date"     : "2018-11-27 00:00:00 -0700",
      "content"  : "续前文:  中文代码示例之Programming in Scala学习笔记第二三章  中文代码示例之Programming in Scala笔记第四五六章.同样仅节选有意思的例程部分作演示之用. 源文档仍在: program-in-chinese/Programming_in_Scala_study_notes_zh第七章 内置控制结构7.8中改为函数式风格的乘法表:def 创建行序列(行: Int) =  for (列 lt;- 1 to 10) yield     val 乘积 = (行 * 列).toString    val 缩进 =   * (4 - 乘积.length)    缩进 + 乘积  def 创建行(行: Int) = 创建行序列(行).mkStringdef 乘法表() =   val 表序列 =    for (行 lt;- 1 to 10)    yield 创建行(行)  表序列.mkString(#92;n)第八章 函数和闭包8.7 闭包在运行时, 闭包牵涉的变量值可能改变, 关键在于该闭包创建的时刻变量值如何:scalagt; def 创建累加器(增量: Int) = (数: Int) =gt; 数 + 增量创建累加器: (增量: Int)Int =gt; Intscalagt; val 累加器1 = 创建累加器(1)累加器1: Int =gt; Int = Lambda1168/184767896236f59005scalagt; val 累加器9999 = 创建累加器(9999)累加器9999: Int =gt; Int = Lambda1168/18476789624a83d668scalagt; 累加器1(10)res25: Int = 11scalagt; 累加器9999(10)res26: Int = 10009感觉书中例程还是偏IT, 本可以更接近日常, 比如这个:val 首参数 = if (参数.length gt; 0) 参数[0] else val 伙伴 =  首参数 match     case 甜酱 =gt; println(辣酱)    case 羊肉 =gt; println(泡馍)    case 皮蛋 =gt; println(豆腐)    case _ =gt; println(啥?)  println(伙伴)"
    } ,
  
    {
      "title"    : "手工翻译Vue.js源码:尝试重命名标识符与文本",
      "category" : "命名, vuejs",
      "description" : "尝试对vue.js源码中的标识符名和文本进行中文化. Try to translate identifiers and text in source code of vue.js.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/vuejs/2018/11/23/%E6%89%8B%E5%B7%A5%E7%BF%BB%E8%AF%91Vue.js%E6%BA%90%E7%A0%81-%E5%B0%9D%E8%AF%95%E9%87%8D%E5%91%BD%E5%90%8D%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E6%96%87%E6%9C%AC.html",
      "date"     : "2018-11-23 00:00:00 -0700",
      "content"  : "续前文: 手工翻译Vue.js源码第一步:14个文件重命名对core/instance/索引中的变量, 方法进行重命名如下(题图):import  混入初始化  from './初始化'import  混入状态  from './状态'import  混入渲染  from './渲染'import  混入事件  from './事件'import  混入生命周期  from './生命周期'import  warn  from '../util/索引'function Vue (选项)   if (process.env.NODE_ENV !== 'production' amp;amp;    !(this instanceof Vue)  )     warn('Vue是构造器, 需要`new`调用')    this._init(选项)混入初始化(Vue)混入状态(Vue)混入事件(Vue)混入生命周期(Vue)混入渲染(Vue)export default Vue发现不大理解的术语Mixin, 将至今所有翻译的术语小结后, 觉得需要一个工具进行管理, 至少需要提示是否有两个英文词翻成了同一个中文词: 记录术语 · Issue #2 · program-in-chinese/vue另外, 在重命名core/util/index时, 有50多个相关文件由于引用了此文件, 需要修改. vscode内置的文件重命名功能不能自动修改. 由于有其他类似的路径(如platforms/web/util/index), 不能通过简单搜索/替代进行批量修改. 今后需要寻找辅助工具, 否则工作量太大. 一种可能是, 类似文档本地化的方式(搭建Python官方文档翻译环境-汉化示例代码), 但最好尽可能通过更普遍适用的代码重构功能实现.源码中也有不少文本内容, 多为面向用户的提示信息. 这部分的翻译对vue用户来说应该是最有意义的.预估工作量还需更多样本."
    } ,
  
    {
      "title"    : "手工翻译Vue.js源码第一步:14个文件重命名",
      "category" : "命名, vuejs",
      "description" : "对vue.js源码中的英文文件名进行中文化. Translate file names in source code of vue.js.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/vuejs/2018/11/21/%E6%89%8B%E5%B7%A5%E7%BF%BB%E8%AF%91Vue.js%E6%BA%90%E7%A0%81%E7%AC%AC%E4%B8%80%E6%AD%A5-14%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D.html",
      "date"     : "2018-11-21 00:00:00 -0700",
      "content"  : "背景对现有开源项目的代码进行翻译(文件名/命名/注释) · Issue #107 · program-in-chinese/overview简单地说, 通过翻译源码, 提高项目代码可读性(对于母语为中文的开发者). 并在此过程中小结源码翻译辅助工具的需求.源码库分支: program-in-chinese/vue源码分析参考文档: Vue.js 技术揭秘 | Vue.js 技术揭秘14个重命名的文件列表core/vdom/helpers/normalize-children-gt;规格化子节点core/vdom/create-element-gt;创建元素core/vdom/vnode-gt;虚拟节点platforms/web/entry-runtime-with-compiler-gt;入口-运行时-带编译器platforms/web/runtime/index-gt;索引core/index-gt;索引core/instance/index-gt;索引core/instance/inject-gt;注入core/instance/lifecycle-gt;生命周期core/instance/proxy-gt;代理core/instance/events-gt;事件core/instance/render-gt;渲染core/instance/state-gt;状态core/instance/init-gt;初始化大概翻译过程  fork原代码库, clone到本地, 默认分支为dev. 在此基础上新建分支”translate-source”. 运行npm test通过所有测试.  逐章阅读参考文档, 将涉及的文件重命名. 在此之前运行npm run dev, 可以监控文件修改并自动编译, 根据编译错误修改对应文件  在刚开始时做了太多修改, 运行npm test时发现问题难以排错, 因此现在采取每个文件重命名后第二步构建成功后就运行npm test, 通过后就commit. 奇怪的是之前的问题再没出现.源码库基本统计src目录中236个文件, 16893行JavaScript代码参考: How do you list number of lines of every file in a directory in human readable format.源码根目录下运行命令: wc -l `find src -type f`小结估计30个小时重命名所有src下文件(包括文档初步学习时间). 下一步尝试重命名源码中的中文命名, 已预估所有源码翻译时间, 相信由于对源码和基本术语了解更多之后, 翻译方法有改进空间, 速度也会加快.源码翻译是一种简单的重构, 对测试用例范围覆盖要求较高. 唯一碰到不稳定的测试用例已有报告: tests fail from clean environment · Issue #7130 · vuejs/vue暂时没有发现难以解决的技术问题. 不过命名风格还在小结中, 比如带”-“的文件名, 有些单词构成短语, 但另一些没有. 比如”create-element”, 翻译成”创建-元素”就觉得”-“是冗余的, 因此略去为”创建元素”. 而”entry-runtime-with-compiler”, 暂时翻为”入口-运行时-带编译器”, 但也许”带编译器的运行时入口”更自然些."
    } ,
  
    {
      "title"    : "中文代码示例之Programming in Scala笔记第四五六章",
      "category" : "命名, Scala",
      "description" : "对Programming in Scala书本中的四五六章示例代码进行命名中文化. Translate identifiers in sample programs to Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/scala/2018/11/16/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BProgramming-in-Scala%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E4%BA%94%E5%85%AD%E7%AB%A0.html",
      "date"     : "2018-11-16 00:00:00 -0700",
      "content"  : "续前文: 中文代码示例之Programming in Scala学习笔记第二三章. 同样仅节选有意思的例程部分作演示之用. 源文档仍在: program-in-chinese/Programming_in_Scala_study_notes_zh第六章 功能对象此章的例子与之前的初步尝试将传统学科的内容程序/数据化有些共鸣, 以后的数学知识部分可以参考此实现.class 有理数(分子: Int, 分母: Int)   require(分母 != 0)  private val 公约数 = 最大公约数(分子.abs, 分母.abs)  val 分子值: Int = 分子 / 公约数  val 分母值: Int = 分母 / 公约数  def this(数: Int) = this(数, 1)  def + (数: 有理数): 有理数 =    new 有理数(      分子值 * 数.分母值 + 数.分子值 * 分母值,      分母值 * 数.分母值    )  def + (数: Int): 有理数 =    new 有理数(分子值 + 数 * 分母值, 分母值)  def - (数: 有理数): 有理数 =    new 有理数(      分子值 * 数.分母值 - 数.分子值 * 分母值,      分母值 * 数.分母值    )  def - (数: Int): 有理数 =    new 有理数(分子值 - 数 * 分母值, 分母值)  def * (数: 有理数): 有理数 =    new 有理数(分子值 * 数.分子值, 分母值 * 数.分母值)  def * (数: Int): 有理数 =    new 有理数(分子值 * 数, 分母值)  def / (数: 有理数): 有理数 =    new 有理数(分子值 * 数.分母值, 分母值 * 数.分子值)  def / (数: Int): 有理数 =    new 有理数(分子值, 分母值 * 数)  override def toString = 分子值 + / + 分母值    private def 最大公约数(甲: Int, 乙: Int): Int =    if (乙 == 0) 甲 else 最大公约数(乙, 甲  乙)第四章 类和对象// 在文件校验累加器.scala中import scala.collection.mutableobject 校验累加器   private val 缓存 = mutable.Map.empty[String, Int]  def 计算(文本: String): Int =    if (缓存.contains(文本))      缓存(文本)    else       val 累加器 = new 校验累加器      for (字符 lt;- 文本)        累加器.加(字符.toByte)      val 校验码 = 累加器.校验()      缓存 += (文本 -gt; 校验码)      校验码    "
    } ,
  
    {
      "title"    : "中文代码示例之Programming in Scala学习笔记第二三章",
      "category" : "命名, Scala",
      "description" : "对Programming in Scala书本中的二三章示例代码进行命名中文化. Translate identifiers in sample programs to Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/scala/2018/11/13/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BProgramming-in-Scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E4%B8%89%E7%AB%A0.html",
      "date"     : "2018-11-13 00:00:00 -0700",
      "content"  : "由于拷贝后文档格式有变, 仅摘几段如下. 完整而且代码带语法高亮的源版在: program-in-chinese/Programming_in_Scala_study_notes_zh前言: 本书已有中文版, 此笔记并不是对原教程的翻译, 而是围绕示例进行选摘, 并顺便将所有示例改成中文命名(不拘泥于原本命名用词, 而是融入中文特色).本文代码在Scala 2.12.4, Java 1.8.0_45下测试通过第一章 普适的语言1.1var 首都 = Map(中国 -gt; 北京, 俄罗斯 -gt; 莫斯科)首都 += (德国 -gt; 柏林)println(首都(俄罗斯))(待续. 先从第二章开始)第二章略第三章[略大部]第十步 使用集合(Set)和映射(Map)(这里开始仅包含例程与极简说明, 如有空再补详细说明) 不可变集合var 客机厂商 = Set(空客, 波音)客机厂商 += 商飞println(客机厂商.contains(大疆))可变集合import scala.collection.mutableval 电影 = mutable.Set(舌尖一, 舌尖二)电影 += 舌尖三println(电影)如需指定使用HashSet, 就import scala.collection.immutable.HashSet可变映射import scala.collection.mutableval 寻宝指南 = mutable.Map[Int, String]()寻宝指南 += (1 -gt; 上荒岛)寻宝指南 += (2 -gt; 在地上找个那啥)寻宝指南 += (3 -gt; 开挖)println(寻宝指南(2))不变映射val 中文数字 = Map(1 -gt; 一, 2 -gt; 二, 3 -gt; 三, 4 -gt; 四, 5 -gt; 五)println(中文数字(4))第十二步 从文件读行[部分略]如想输出更漂亮, 下面是最终版:import scala.io.Sourcedef 字符数宽度(文本: String) = 文本.length.toString.lengthif (args.length gt; 0)   val 行 = Source.fromFile(args(0)).getLines().toList  val 最长行 = 行.reduceLeft(    (行1, 行2) =gt; if (行1.length gt; 行2.length) 行1 else 行2  )  val 最大宽度 = 字符数宽度(最长行)  for (某行 lt;- 行)     val 空格数 = 最大宽度 - 字符数宽度(某行)    val 缩进 =   * 空格数    println(缩进 + 某行.length +  |  + 某行)  else  Console.err.println(请输入文件名)运行scala 统计字符2.scala 统计字符2.scala输出如下:22 | import scala.io.Source 0 |49 | def 字符数宽度(文本: String) = 文本.length.toString.length 0 |22 | if (args.length gt; 0) 52 |   val 行 = Source.fromFile(args(0)).getLines().toList25 |   val 最长行 = 行.reduceLeft(53 |     (行1, 行2) =gt; if (行1.length gt; 行2.length) 行1 else 行2 3 |   )23 |   val 最大宽度 = 字符数宽度(最长行)17 |   for (某行 lt;- 行) 30 |     val 空格数 = 最大宽度 - 字符数宽度(某行)22 |     val 缩进 =   * 空格数40 |     println(缩进 + 某行.length +  |  + 某行) 3 |    1 |  4 | else31 |   Console.err.println(请输入文件名)(第三章完)发现的中文相关问题命令行交互环境中, 错误信息对中文字符的定位不准. 这很干扰排错. 比较如下两个同样出错信息:scalagt; println([2])lt;consolegt;:1: error: illegal start of simple expression       println([2])               ^scalagt; 打印参数([2])lt;consolegt;:1: error: illegal start of simple expression       打印参数([2])            ^"
    } ,
  
    {
      "title"    : "专栏全年主题合辑-代码中文命名相关实践",
      "category" : "小结, 命名",
      "description" : "在中文编程知乎专栏创立一周年之际, 对使用中文命名代码中的标识符的相关实践作回顾小结. Summary of practice of using Chinese naming for identifiers in source code one year after starting Programming in Chinese column.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/%E5%91%BD%E5%90%8D/2018/11/10/%E4%B8%93%E6%A0%8F%E5%85%A8%E5%B9%B4%E4%B8%BB%E9%A2%98%E5%90%88%E8%BE%91-%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E7%9B%B8%E5%85%B3%E5%AE%9E%E8%B7%B5.html",
      "date"     : "2018-11-10 23:00:00 -0700",
      "content"  : "注: 本文仅对个人亲自参与的尝试作一小结, 专栏中其他作者的尝试还望各自总结. 文中所有例子都尽量使用了中文命名一些对中文命名的早期实践:  2015年对JDK中接口的中文化尝试  2016年的Spring Boot 1.3.3演示尝试了前后端中文命名  2017年开始Java实现的汇编语言编译器  将之前的插件项目中的代码中文化: 火狐插件实现浏览历史按主题显示(树)在2017年发现多数流行编程语言已经支持Unicode/中文命名, 并开始小结中文命名的风格和特点. 2017年7月编写了中文代码示例教程之Java编程一天入门, 体验了选取例程题材的趣味与难度. 同月也在Maven Central发布中文API的Java库(后话, 在一年后喜获V2EX的用户反馈”第一次见以汉字命名的 Java 类”). 8月尝试对现有图形库p5js的接口进行中文化, 是在JDK接口中文化之后, 从通用库转向专用库的一步. 必须提到的是, 在2017年初发现13年前就有同仁提出中文命名的可读性优势与IDE支持问题, 而在半年后成立的”中文编程”GitHub讨论组中, 有幸碰到通过IDE插件实现拼音输入法和自动补全功能集成的同好.在”中文编程”知乎专栏于2017年11月9月开通之前, 对现有框架的入门教程的示例代码尝试中文化, 并与VueJS开发组进行了中文命名相关问题的交流:  中文代码示例之Vuejs入门教程(一)  中文代码示例之Angular入门教程尝试  中文代码示例之Vuejs入门教程(一)问题后续专栏开通之际编写的对在代码中使用中文命名的质疑与回应是对之前看到的各种反对声音的总结, 至今尚未看到有力的反证, 并且在一路上的探索中发现了越来越多的佐证, 比如11月末发现的Python3选择支持非ASCII码标识符的缘由.专栏开通的初期, 进行了一系列的相关思考, 对今后的实践方向有不小影响:  中文命名实践的阻力和应对  中文编程兴起的必然性  中文编程兴起的可能途径对在线编程对中文命名的支持初步调研:  在LeetCode中的解答中使用中文命名  向LeetCode报告编译信息中Unicode显示问题  在线编程网站对中文代码的支持之后重心转向自研编程语言, 也进行了一些相关项目的中文命名尝试:  编写Visual Studio Code插件初尝试  中文代码示例之5分钟入门TypeScript, 此文与GitHub讨论组内成员对TypeScript进行中文化有关, 半年后有了5分钟入门CTS-尝鲜中文版TypeScript  FriceEngine试用与API中文化也是与组内成员项目的交流尝试  手机编程环境初尝试-用AIDE开发Android应用也与组内成员有关  浅尝The Little Prover一书, 重逢Chez Scheme  编程猫IDE体验:对Scratch的改进对少儿编程进行了初步了解  尝试了一些短示例演示中文命名, 如中文代码示例之冒泡算法, 后感, 中文代码示例[译]Scala中创建隐式函数, 并在项目/教程中使用母语命名的”问题”中进行了一些反思.在2个月后的2018年4月, 开始对Python官方入门文档的示例代码进行中文命名:  搭建Python官方文档翻译环境-汉化示例代码  中文代码示例视频演示Python入门教程第三章 简介Python  中文代码示例视频演示Python入门教程第四章 控制流  中文代码示例视频演示Python入门第五章 数据结构原本是打算至少完成入门部分, 但过程中逐渐发现原教程示例的局限性, 如代码考古-Python3官方教程字典例程, 认为花精力在自己编写教程上也许更值得. 就有了“西游记”主题Python入门示例尝试-数据结构 5.1-5.1.2. 也尝试对国人原创教程中的示例进行中文化: 解谜计算机科学第一章示例汉化尝试接下来是一段比较嘈杂的时期, 为Chrome和火狐浏览器编写扩展应该是为在插件中实现计算/编程工具做的技术复习. 此时发现了一系列针对中文编程/命名的软文:  最近一波对中文编程(包括中文命名)的攻势  万马齐喑究可哀-中文编程的又一波”讨论”  后来的又见套路:如果计算机是用中文编程,你能成为计算机编程专家吗？.不禁针对性地写了在代码中进行中文命名(类/变量/方法等)的优势. 至此, 深切感觉到进一步积极推广中文命名的必要性.继续进行一些以中文命名作示例的小教程的编写:  对DLL库中的接口进行中文命名  中文代码示例之Python-如何遍历字典  在Office的VBA代码里中文命名  中文代码示例之Spring Boot 2.0.3问好  Head First OO分析设计一书略读与例子中文化至此, GitHub讨论组已创建一年, 深感核心项目的必要性. 下面围绕编程术语命名进行了一些技术摸索:  中文代码之Spring Boot实现简单REST服务  中文代码之Spring Boot添加基本日志  中文代码之Spring Boot集成H2内存数据库  中文代码之Spring Boot对H2数据库简单查询  使用JDT核心库解析JDK源码后初步分析API命名8月末, 源于组内讨论, 开始了批量代码汉化工具的尝试, 并开发了必需的英汉词典相关工具, 从浏览器插件, 在线服务原型, 到今天的vscode插件:  浏览器插件实现GitHub代码翻译原型演示  Java实现英汉词典API初版发布在Maven  调研: 使用现有在线翻译服务进行代码翻译的体验  代码翻译尝试-使用Roaster解析和生成Java源码  Java源码英翻中库以及服务原型  Java源码英翻中网页演示  Java源码英翻中进展-内测上线  在浏览器插件中读取JSON资源文件  浏览器插件-离线英汉词典  Chrome插件实现GitHub代码翻译v0.0.3  Chrome插件实现GitHub代码离线翻译v0.0.4  浏览器插件-离线英汉词典 0.0.7  在线代码离线翻译Chrome插件”一马”v0.0.8  在线代码离线翻译Chrome插件”一马”v0.0.14  Visual Studio Code插件-英汉词典初版发布  VS Code英汉词典插件v0.0.4-驼峰下划线命名主要出于此项目对中文命名的推广意义, 打算将这个系列作为个人在代码中进行中文命名实践的短期目标8月之后在V2EX上交流甚多, 也催生了用Python3+tkinter开发简单图形界面程序这样的合作项目, 很希望看到类似项目的开展.另有一个中期的目标来自于首次发现在例程中使用日语命名的编程书籍, 之后做了日语命名的调研:它山之石-日本推广编程中使用日语命名的渊源. 发现将编程与传统学科结合的现实紧迫性, 并初步尝试将传统学科的内容程序/数据化. 这不仅与中文命名紧密相关, 也是潜在的中文语法编程语言的土壤(见前文末段). 个人非常期待."
    } ,
  
    {
      "title"    : "专栏全年主题合辑-中文编程语言开发尝试",
      "category" : "小结, 编程语言",
      "description" : "在中文编程知乎专栏创立一周年之际, 对中文编程语言的实验性开发作回顾小结. Summary of creating Chinese-based programming language one year after starting Programming in Chinese column.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2018/11/10/%E4%B8%93%E6%A0%8F%E5%85%A8%E5%B9%B4%E4%B8%BB%E9%A2%98%E5%90%88%E8%BE%91-%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E5%B0%9D%E8%AF%95.html",
      "date"     : "2018-11-10 00:00:00 -0700",
      "content"  : "注: 本文仅对个人尝试作一小结, 专栏中其他作者的尝试还望各自总结对自研中文编程语言的尝试也许始于2015年对CoffeeScript的部分关键词汉化和Java实现的汇编语言编译器的开发. 2017年10月那场请求C#提供汉化版的讨论也给了更多的动力. 之后对开源非英文关键词编程语言进行了一些调研, 尤其对日语编程语言”抚子”进行了较深入的学习:  日语编程语言”抚子” - 第三版特色初探  日语编程语言”抚子”-第三版实现初探期间认识到国人创造中文编程语言的优势, 并整理了对中文语法的编程语言的质疑与回应. 之后的实验编程语言以”圈”命名, 第一个尝试是编程语言试验之Antlr4+Java实现”圈2”. 接下来是对中文编程语言之Z语言初尝试: ZLOGO 4, 此文后的数十回合回复应该是专栏建立之后第一次也是仅有的一次在专栏内进行的公开热烈讨论. 在此讨论的激励下, 进行了中英文代码对比之ZLOGO 4 amp; LOGO, 并开始了基于JavaScript并可以在线运行的编程语言开发–“圈3”, 它也是个人最接近实用的一个语言工具:  作为原型的编程语言试验之Antlr4+JavaScript实现”圈4”  JavaScript实现ZLOGO子集: 前进+转向  JavaScript实现ZLOGO子集: 单层循环功能  JavaScript实现ZLOGO子集: 测试用例  JavaScript实现ZLOGO: 用语法树实现多层循环  相关的为新语言编写Visual Studio Code语法高亮插件虽然LOGO是个潜在的编程启蒙工具, 但效果毕竟不如现今的Scratch等等开发环境. 结合之前对中文语法的编程语言和相应IDE功能特色的讨论起草了通用型的中文编程语言探讨之一: 高考, 并进行了一个更实用编程语言原型的尝试–“圈5”:  Antlr4的分析错误处理  Antlr4实现数学四则运算  Antlr4添加中文变量赋求值,括号,各种问题  Antlr4: 修改语法规则更接近普通BNF格式  Antlr4实现简单语言之整数比较表达式  Antlr4实现简单语言之条件语句也对其他的编程语言开发方法作了尝试:  Xtext试用: 快速实现简单领域专用语言(DSL)  Xtext试用: 5步实现一个(中文)JVM语言期间发现AppleScript类自然语言与非英语语法设计早有对日语语法的支持. 在2018年3月意识到了中文编程已经被大量用于日常生活, 也更倾向于基于实际用途开发特定领域的中文语法编程语言. 而在用途明晰之前(两周前的初步尝试将传统学科的内容程序/数据化也许是个好方向, 希望能够早日开始), 暂不进行更多这个方向的尝试. 2018年4月之后回归对中文命名的关注和相关实践."
    } ,
  
    {
      "title"    : "VS Code英汉词典插件v0.0.4-驼峰下划线命名",
      "category" : "命名, 翻译",
      "description" : "实现VS code插件, 基于本地词典数据, 提供英汉翻译功能, 支持驼峰和下划线命名. Add support for Camel case and underscore style naming to the vscode extension to translate English word or phrase to Chinese in source code.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/11/09/VS-Code%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E6%8F%92%E4%BB%B6v0.0.4-%E9%A9%BC%E5%B3%B0%E4%B8%8B%E5%88%92%E7%BA%BF%E5%91%BD%E5%90%8D.html",
      "date"     : "2018-11-09 00:00:00 -0700",
      "content"  : "首先, 在两天时间内安装数破百, 多谢支持.VS Code插件市场地址: 英汉词典 - Visual Studio Marketplace开源库地址同前文: Visual Studio Code插件-英汉词典初版发布查询单词功能基本不变, 在详细信息的开头添加了原词:如题图, 支持驼峰命名查询. 在详细信息中, 包含所有单词的详细释义, 但为避免内容过多, 没有词形信息. 另外还支持下划线命名:查无结果时提示:注意! 比初版少了一个功能 – 查询带空格的短语, 如”as well as”. 感觉自己很少查短语, 因此暂缓修复(更多原因见下).初版中, 只截取了浏览器插件-离线英汉词典 0.0.7的加载词典部分源码. 在这个版本中, 为了进行整命名翻译, 又截取了不少在线代码离线翻译Chrome插件”一马”v0.0.14的现成代码, 虽然当时有不少测试用例. 但此插件仍做了不少改动, 添加了更复杂的接口/结构, 也欠了测试和重构/清理的债. 接下去考虑将现有JavaScript代码尽量转为TypeScript, 并且补很多课(比如到处都用var之类), 以提高可维护性.初步目标是在年前完成上述修改, 并根据期间的用户反馈决定下一步改进. 另外还希望开始基于这个词典数据的源码命名翻译预览项目: 批量代码汉化工具 · Issue #86 · program-in-chinese/overview敬请期待!遛源码时间之前提到的略复杂结构是命名查询的返回结果, 见下面的注释部分:// 原字段: 原字段, 释义: 翻译, 各词: [词: 英文, 释义: 单词释义, 词形: [所有变形]];function 显示字段信息(查字段结果)     // 长度必大于0    if (查字段结果.各词.length == 1)         return 取单词条信息(查字段结果.各词[0], true);     else         var 翻译 = ;        for (单词结果 of 查字段结果.各词)             翻译 += 取单词条信息(单词结果, true, false);                return 翻译;// 词: 英文, 释义: 单词释义, 词形: [所有变形]function 取单词条信息(查词结果, 显示原词 = false, 显示词形 = true)     var 显示 = 显示原词 ? 【 + 查词结果.词 + 】 : ;    var 释义 = 查词结果.释义;    if (释义)         显示 +=   + 释义.split('#92;#92;n').join( );        var 词形 = 查词结果.词形;    if (显示词形 amp;amp; 词形.length gt; 0)         var 词形显示 = ;        for (var 某词形 of 词形)             词形显示 += 某词形.类型 + :  + 某词形.变化 + ; ;                显示 +=    + 词形显示;        return 显示;暗黑的彩蛋刚运行vsce publish提交0.0.3版时, 报错:  Error: Item has already been added. Key in dictionary: ‘extension/????????????/????????????.js’ Key being added: ‘extension/????????????/????????????.js’于是决定将”源码翻译”目录及文件名改为英文, 并删除暂不需要的关键词数据文件之后, 0.0.4版提交成功. 开issue待研究: Error: Item has already been added. Key in dictionary · Issue #5 · program-in-chinese/vscode_english_chinese_dictionary路漫漫其修远兮"
    } ,
  
    {
      "title"    : "用中文编程-专栏初衷回顾",
      "category" : "小结",
      "description" : "在中文编程知乎专栏创立一周年之际, 对专栏初衷作回顾与修订. Revised goals for the Programming in Chinese column after one year.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/2018/11/08/%E7%94%A8%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B-%E4%B8%93%E6%A0%8F%E5%88%9D%E8%A1%B7%E5%9B%9E%E9%A1%BE.html",
      "date"     : "2018-11-08 00:00:00 -0700",
      "content"  : "一年前编写了中文编程专栏目录, 初衷和希冀, 一路上各种实践与讨论. 现将专栏内容覆盖范围重新归纳.如”中文编程”字面所言, 所有使用中文进行程序编写的理论和实践都在覆盖范围. 下面两部分相辅相成:中文命名命名包括类/接口名, 变/常量, 方法名, 数据库中的表/列名, HTML中的ID名等等所有可以使用Unicode命名的部分.  在编写新代码时使用中文命名  对现有英文命名的代码特别是API进行中文化中文语法编程语言及开发环境(IDE)  创建新的编程语言  中文化现有编程语言与核心库  开发相应的IDE支持为支持上述实践, 需要相关的工具开发, 比如对现有代码进行中文化的辅助工具, IDE对中文输入的辅助功能等等.希望认识对中文编程任何方面有兴趣和经验的同好, 为推进中文编程的实践, 交流, 推广和市场化群策群力. 望各位多多进言, 踊跃投稿!此文开始, 今后的部分文章将发表在Medium的中文编程栏目. 此前一年的部分文章将以合辑的形式进行总结. 鉴于多数Medium用户为英文用户, 特此编写英文摘要:AbstractThe Zhihu column 中文编程 is one year old, and here is a revision of our goals.This publication “Programming in Chinese” aims at both naming in Chinese and Chinese-based programming languages.Naming in Chinese includes writing new code with Chinese naming and converting existing code with English naming to Chinese naming, especially APIs.Chinese-based programming languages similarly include creating new programming languages and translating existing language syntax amp; SDKs to Chinese, plus corresponding IDE support.There need to be tools to support practices above, including assistant for translating existing code, IDE features to support Chinese input, etc.Looking forward to knowing anyone who’s interested in any way!In the future part of the articles of the 中文编程 column will be re-posted here."
    } ,
  
    {
      "title"    : "Visual Studio Code插件-英汉词典初版发布",
      "category" : "命名, 翻译",
      "description" : "实现VS code插件, 基于本地词典数据, 提供英汉翻译功能, 现仅支持单词和短语. Implement a vscode extension to translate English word or phrase to Chinese in source code.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/11/06/Visual-Studio-Code%E6%8F%92%E4%BB%B6-%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E5%88%9D%E7%89%88%E5%8F%91%E5%B8%83.html",
      "date"     : "2018-11-06 00:00:00 -0700",
      "content"  : "VS插件市场地址: 英汉词典 - Visual Studio Marketplace开源在: program-in-chinese/vscode_english_chinese_dictionary如题图, 在VS Code插件页中搜索”英汉词典”, 即可安装. 之后如果继续开发相关插件, 也会以”中文编程”作者发布.在编辑器中选中任何英文词/短语, 如果在词典中有匹配词条, 就在状态栏显示所有释义和词形. 为尽量确保状态条不会过长而被IDE自动隐藏, 当释义/词形过长时, 仅截取前半部分在状态栏显示, 点击状态可见所有信息(如简介中的演示). 如果原选中词查不到, 会查全小写, 若再查不到, 最后查全大写. 下面是查询短语:作为在IDE中实现源码翻译的先行项目, 采用了浏览器插件-离线英汉词典 0.0.7类似方案. 参考了官网的状态栏例子, 开发过程比想象中的更短一些.由于没有找到加载JSON文件的方法, 直接将浏览器插件中的JSON文件改为JS (40MB释义数据, 3MB词形变化数据), 仍在插件加载时载入所有数据, 本机也是几秒. 后续查词感觉没什么性能问题.暂时想到的改进方向:  由于源代码中的命名往往是驼峰或下划线格式, 而双击选中文本往往选中整个命名, 考虑翻译整个命名. 这与浏览器插件的此issue相关: 按照词性改进命名翻译 · Issue #9 · program-in-chinese/webextension_github_code_translator. (已实现: VS Code英汉词典插件v0.0.4-驼峰下划线命名)  在状态栏选取词义时, 选取代表性词义, 而不仅截取前部分(也已实现: . 比如”hide”, 全部释义是n. 兽皮, 迹象, 躲藏处 vt. 藏, 隐瞒, 遮避, 剥...的皮, 隐藏 vi. 躲藏 [计] 隐藏. 状态栏现在显示:    n. 兽皮, 迹象, 躲藏处 vt. 藏, 隐瞒, 遮避,...        改成这样也许更合适:    n. 兽皮 vt. 藏 vi. 躲藏 [计] 隐藏 ...      最后照例贴段源码, 由于载入词典和查词部分与浏览器插件很接近, 只选取了IDE相关操作部分(监听选中文本事件, 根据文本进行查词). 代码还需加工.function activate(context)     const window = vscode.window;    const StatusBarAlignment = vscode.StatusBarAlignment;    const workspace = vscode.workspace;    const commands = vscode.commands;    const 状态框 = window.createStatusBarItem(StatusBarAlignment.Right, 100);    状态框.command = 'extension.翻译选中文本';    context.subscriptions.push(状态框);    context.subscriptions.push(window.onDidChangeActiveTextEditor(e =gt; 更新状态栏(状态框)));    context.subscriptions.push(window.onDidChangeTextEditorSelection(e =gt; 更新状态栏(状态框)));    context.subscriptions.push(window.onDidChangeTextEditorViewColumn(e =gt; 更新状态栏(状态框)));    context.subscriptions.push(workspace.onDidOpenTextDocument(e =gt; 更新状态栏(状态框)));    context.subscriptions.push(workspace.onDidCloseTextDocument(e =gt; 更新状态栏(状态框)));    context.subscriptions.push(commands.registerCommand('extension.翻译选中文本', () =gt;         // TODO: 避免重复查询(状态框查询一次即可?)        let 文本 = 取选中文本();        if (文本)             window.showInformationMessage(显示词条(查询词条(文本), 1000));            ));    更新状态栏(状态框);function 更新状态栏(状态框)     let 文本 = 取选中文本();    if (文本)         状态框.text = '(megaphone) ' + 显示词条(查询词条(文本), 30);        状态框.show();     else         状态框.hide();    function 取选中文本()     const 当前编辑器 = vscode.window.activeTextEditor;    const 选中部分 = 当前编辑器.selection;    return 当前编辑器.document.getText(选中部分);欢迎尝鲜和反馈.后续版本介绍:VS Code英汉词典v0.0.8: 批量翻译文件部分命名VS Code英汉词典插件v0.0.7-尝试词性搭配VS Code英汉词典插件v0.0.6-改为TS实现, 加测试VS Code英汉词典插件v0.0.4-驼峰下划线命名"
    } ,
  
    {
      "title"    : "在线代码离线翻译Chrome插件&quot;一马&quot;v0.0.14",
      "category" : "命名, 翻译",
      "description" : "实现Chrome插件, 基于本地词典数据, 提供Github和码云在线源码翻译功能, 添加关键词不翻译选项等. Implement a Chrome extension to translate English source code to Chinese on Github pages.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/11/04/%E5%9C%A8%E7%BA%BF%E4%BB%A3%E7%A0%81%E7%A6%BB%E7%BA%BF%E7%BF%BB%E8%AF%91Chrome%E6%8F%92%E4%BB%B6_%E4%B8%80%E9%A9%AC_v0.0.14.html",
      "date"     : "2018-11-04 00:00:00 -0700",
      "content"  : "续前文: 在线代码离线翻译Chrome插件”一马”v0.0.8. 主要改进如下.项目源码库: program-in-chinese/webextension_github_code_translator添加基本词库发现部分用户安装了”一马”但未安装离线英汉词典插件, 这将导致翻译完全无法进行, 弹窗将显示相同代码段, 用户也许会误认为插件无效. 于是在0.0.14版中添加基本词库(牛津核心三千词), 以避免单独安装无法进行任何翻译的情况. 在部分词汇无法翻译时改进提示信息如下:默认不翻译关键词和核心API提供用户选项是否翻译:默认不翻译(例程地址):勾选翻译后的效果与0.0.8版接近:复数词汇采用原型词汇的释义比如”Minutes”的词典释义是”n. 会议记录”, “Seconds”是”n. 次级品, 二等品”. 0.0.10中改为取原型释义(“分”, “秒).添加常用命名/缩写的手工翻译仅前30个高频词, 之后将逐渐增加. 部分词汇不予翻译(to, of, bean). 常用缩写如’util’的词典释义是”跑龙套”, 手工翻译为”功用”. 详见常用命名/缩写的手工翻译 · Issue #17 · program-in-chinese/webextension_github_code_translator计划昨日收到用户详尽反馈: 请添加火狐插件吧 · Issue #19 · program-in-chinese/webextension_github_code_translator. 这是下一个主要目标.附上Chrome插件商店地址: 链接"
    } ,
  
    {
      "title"    : "在代码中进行中文命名实践的短期目标",
      "category" : "命名",
      "description" : "在代码中进行中文实践的几个短期目标. Some short-term goals of practising naming identifiers in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2018/11/02/%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E5%AE%9E%E8%B7%B5%E7%9A%84%E7%9F%AD%E6%9C%9F%E7%9B%AE%E6%A0%87.html",
      "date"     : "2018-11-02 00:00:00 -0700",
      "content"  : "对中文命名的意义不再赘述, 请参看之前的对在代码中使用中文命名的质疑与回应.去年中文命名实践的阻力和应对之后, 在一些小项目中继续实践了中文命名(Java/JS/Python等, 详见之前的专栏文章), 涉及领域不少但尚未形成明确的重点项目. 发现了一些在业务相关代码使用中文命名的例子(你们在怎样的项目中使用过中文命名? - V2EX), 还未形成社区. 下面是可能的努力方面:  编写示例代码为中文命名的教程. 之前有一些尝试, 专栏中带有示例代码的文章也都采用了中文命名  在开源项目中实践中文命名, 也欢迎提出实用项目的想法或者例题面试题等  开发中文命名的API, 如之前的简繁转换库, 离线英汉词典等  补: 在IDE中进行中文命名的辅助工具, 包括输入法与自动补全集成等.  开发工具, 辅助翻译现有英文命名的源码为中文命名, 以 #1 辅助在线阅读学习代码或者 #2 批量转换一个项目中的所有源码等等打算将最后一项作为短期内的中心内容, 围绕它开发一系列开源工具. 包括浏览器插件, IDE插件等.#1从两个月前开始实践, 最近基本实现了翻译在线代码段(GitHub和码云)的浏览器插件原型(版本已更新至0.0.11, 效果如题图).#2之前Java源码英翻中是一种可能, 但考虑尽量倚靠IDE本身重构相关API. 首先提取所有代码中的英文命名, 并提取单词(如之前对JDK源码的命名分析), 在机器翻译的基础上, 提供对某些业务术语手动翻译的选项, 之后基于这个词汇表进行源码的批量命名转换.在此项目实现过程中, 将在源码中使用中文命名, 尽可能提取易于复用的API, 并编写系列技术开发文档. 这样也可以触及上面其他1/2/3三个方面.项目中必需一些中文自然语言处理和机器翻译相关技术和相关词库/语料数据, 欢迎有兴趣和经验的同仁参与."
    } ,
  
    {
      "title"    : "专栏一岁了-我为什么投身于普及用中文编程",
      "category" : "小结",
      "description" : "在中文编程知乎专栏创立一周年之际, 对自己的相关历程作小结. Summary of my own relevant experience one year after starting Programming in Chinese column.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/2018/11/01/%E4%B8%93%E6%A0%8F%E4%B8%80%E5%B2%81%E4%BA%86-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%95%E8%BA%AB%E4%BA%8E%E6%99%AE%E5%8F%8A%E7%94%A8%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B.html",
      "date"     : "2018-11-01 00:00:00 -0700",
      "content"  : "知乎专栏于2017年11月9日开通, 之前只想写些中规中矩的年度小结, 但感觉有些东西不吐不快, 权当人生阶段报告吧.最早对编程的接触在初中, 同学帮他家里玻璃厂写了个优化切割率的程序, 我看了点源码. 高中时想自学C未果. 00年大学志愿选了听起来和计算机很接近的信息工程专业, 当时属于软硬兼修但偏电子方面. 大一开始学C, 选修了单片机/汇编等等, 之后课程中计算机基础知识(尤其体系/系统方面)比较欠缺. 毕业后在上海工作四年, 跟着不少前辈学习, 对软件工程实践有了点亲身体会. 2008年抱着对AI的憧憬来美国读硕. 英语从小学之前家里开始教, 之前这一路上英语算是相对强项.硕士期间, 补一些计算机基础课之外, 修了一些AI/自然语言处理/编译器入门相关课程, 在学校的机器人实验室做了点工作. 毕业后留美做了网络开发软件工程师, 业余开始做一些开源项目(浏览器插件). 2014年才在岗位中第一次参与可读性审核, 在国外公司参与不同国家程序员的可读性互评, 才发现母语的优势(如一群华人和东欧人讨论英语选词的时候). 2015年开始一系列中文编程相关尝试, 见前文小结此不赘述.2015年中有了大女儿, 2016年在出国八年后第一次回国探亲. 2017年中, 二女儿尚未出生, 在国外听闻奶奶去世, 同月在Github创建中文编程讨论组. 之后的绝大多数业余时间都用在相关开发讨论中. 想来算是有生以来最投入的一个业余爱好了. 对于中文编程的广泛社会效益在其他专栏文章已有阐述, 这里说说对我个人的益处.  保持自己的语文水平. 虽然在家里说中文, 但写作量非常有限. 亏得讨论组和专栏, 这一年多的中文写作量大概比在国外的前九年加起来还多(也许还可以加上工作和大学的八年). 更不用说各个相关项目开发中使用中文命名更考验用词能力.  锻炼在线社交能力. 在探讨和论战过程中, 对现今的网络环境有了更直接的认识, 作了不少自我修炼.  希望借此与国内同行多交流, 避免与国内的迅速发展脱节. 一路上结识了不少同道, 期待更多合作者.  国家越强大, 在国外越安全. 两个女儿, 更不希望看到乱世 (用中文编程可帮助缓解国内人力短缺问题, 降低初创公司的开发成本, 促进自主基础软件开发和传统行业信息化, 加速提高全行业的国际竞争力)  两边父母尚在, 国家越早富强才更有动力早日全家回国开创事业  希望用中文编程帮助下一代在英文环境中(如果#5不能短时间成行)学习中文相关知识, 避免只会听不说不写总之, 虽然困难重重, 但有足够理由坚持下去."
    } ,
  
    {
      "title"    : "在线代码离线翻译Chrome插件&quot;一马&quot;v0.0.8",
      "category" : "命名, 翻译",
      "description" : "实现Chrome插件, 基于本地词典数据, 提供Github和码云在线源码翻译功能. Implement a Chrome extension to translate English source code to Chinese on Github pages.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/10/31/%E5%9C%A8%E7%BA%BF%E4%BB%A3%E7%A0%81%E7%A6%BB%E7%BA%BF%E7%BF%BB%E8%AF%91Chrome%E6%8F%92%E4%BB%B6_%E4%B8%80%E9%A9%AC_v0.0.8.html",
      "date"     : "2018-10-31 00:00:00 -0700",
      "content"  : "续前文: Chrome插件实现GitHub代码离线翻译v0.0.4添加了对”码云”在线代码的翻译支持, 因此改名暂为”一马”. 在此贴中调研了常用的在线代码网站: 各位都在什么源码站上在线看代码? - V2EX, 暂未发现其他.注: 此插件调用浏览器插件-离线英汉词典 0.0.7进行查词, 因此也不依赖任何在线翻译服务, 不存在API调用限制.改进功能:  支持”码云”代码翻译  添加 C/PHP 关键词的翻译  删除释义中的括号内内容“码云”的代码段与GitHub的HTML结构略有不同, 暂时分别处理如下:function 获取代码段()   var 当前域名 = window.location.host;  // 默认, 适用于GitHub  var 代码段节点 = document.body.getElementsByTagName('table')[0];  if (当前域名 == gitee.com)     代码段节点 = document.body.getElementsByClassName('code')[0]      // GitHub: 父节点的class包含编程语言信息, 如class=blob-wrapper data type-python   return [代码段节点.parentElement.outerHTML];function 翻译()   // TODO: 避免与`获取代码段()`重复  var 编程语言 = ;  var 原代码拷贝 = document.body.getElementsByClassName('code');  var 顶节点 = null;  if (原代码拷贝.length == 0)     原代码拷贝 = document.getElementsByTagName('table')[0];    顶节点 = 原代码拷贝.parentElement;    编程语言 = 取编程语言(顶节点);   else     添加CSS(https://gitee.com/assets/application-e5df8140372297eda15f23497886ffdb.css);    原代码拷贝 = 原代码拷贝[0];  ...大幅增加了通用关键词的手工翻译, 以覆盖尽可能多的编程语言:// TODO: 并非所有编程语言都有. 会影响命名翻译.var 通用关键词 =   abstract: 抽象,  and: 且,  as: as,  assert: 断言,  break: 跳出,  boolean: 布尔,  byte: 字节,  char: 字节,  const: const,  case: 分支,  class: 类别,  catch: 接住,  continue: 继续,  default: 默认,  do: 执行,  double: 双浮点,  else: 否则,  enum: 枚举,  extends: 扩展,  extern: 外部,  false: 假,  final: 最终,  finally: 善后,  float: 单浮点,  for: 对于,  function: 函数,  global: 全局,  goto: goto,  if: 如果,  implements: 实现,  import: 导入,  in: 在,  include: 包括,  instanceof: 为实例,  int: 整数,  interface: 接口,  is: 为,  long: 长整数,  native: native,  new: 新,  null: 空,  or: 或,  package: 包,  private: 私有,  protected: 保护,  public: 公有,  return: 返回,  short: 短整数,  signed: 有符号,  sizeof: 大小,  static: 静态,  struct: 结构,  super: 父类,  switch: 岔,  synchronized: 同步,  this: 本身,  throw: 抛出,  throws: 会抛出,  transient: transient,  true: 真,  try: 尝试,  typedef: 类型定义,  union: 联合,  unsigned: 无符号,  void: 无值,  volatile: volatile,  while: 每当,  with: with,  yield: 产出var 专用关键词 =   // https://msdn.microsoft.com/en-us/library/befeaky0.aspx  c:     auto: auto,    register: register  ,  // http://php.net/manual/en/reserved.keywords.php  php:     // array()    callable: 可调用,    clone: 克隆,    const: const,    declare: 声明,    // die()    echo: 回响,    elseif: 否则如果,    // empty()    enddeclare: 结束声明,    endfor: 结束for,    endforeach: 结束foreach,    endif: 结束if,    endswitch: 结束switch,    endwhile: 结束while,    // eval()    // exit()    foreach: 对每个,    implements: 实现,    include_once: 包括_单次,    instanceof: 为实例,    insteadof: insteadof,    interface: 接口,    // isset()    // list()    namespace: 命名空间,    print: 打印,    require: 需要,    require: 需要_单次,    trait: trait,    // unset()    use: use,    var: var,    xor: 异或  ,  javascript:     arguments: 参数,    await: 等待,    debugger: 调试器,    delete: 删除,    eval: eval,    export: 导出,    let: 让,    typeof: 为类型,    var: 变量  ,  /*  参考 http://zetcode.com/lang/python/keywords/  import keyword  print(Python keywords: , keyword.kwlist)  */  python:     False: 假,    None: 空,    True: 真,    def: 定义,    del: 删除,    elif: 否则如果,    except: except,    from: 从,    lambda: lambda,    nonlocal: nonlocal,    not: 不,    pass: 轮空,    raise: 抛出,  ,  // 参考 https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html  java:     strictfp: strictfp  Chrome插件商店下个版本打算改进的(11/02/2018: 在0.0.11版中已基本完成):      让用户可以选择是否中文化关键词 · Issue #3 · program-in-chinese/webextension_github_code_translator        常用命名/缩写的手工翻译 · Issue #17 · program-in-chinese/webextension_github_code_translator        复数词汇取原词释义 · Issue #12 · program-in-chinese/webextension_github_code_translator: 也许还需要词频数据.  "
    } ,
  
    {
      "title"    : "浏览器插件-离线英汉词典 0.0.7",
      "category" : "命名, 词典",
      "description" : "实现浏览器插件, 基于本地词典数据, 提供网页上英语词语查询汉语释义功能, 添加词形变化等功能. Add features to English to Chinese dictionary using local data in browser extension.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E8%AF%8D%E5%85%B8/2018/10/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6-%E7%A6%BB%E7%BA%BF%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8-0.0.7.html",
      "date"     : "2018-10-30 00:00:00 -0700",
      "content"  : "新添功能:  添加词形变化信息, 如查询”get”显示: 过去分词: got; 过去式: got; 现在分词: getting; 第三人称单数: gets;  弹窗中显示处理后的英文, 比如, 查询”Task”, 弹窗中会显示”task”.  提供输入框, 可供当无法选中页面中的文本或者手动输入后按回车键查询.  当单词小写无法查到, 尝试全大写查询, 比如’ok’词形变化数据也是提取自前文浏览器插件-离线英汉词典使用的数据(提取工具: 提取词形变化到JSON), 仅有3M多.词形变化源数据条目举例如下:abdicate: p:abdicated/d:abdicatedseconds: 1:s3/0:second将其转换为可读文本显示的源码部分如下:var 词形类型 = Object.freeze(  p: 过去式, // past tense  d: 过去分词,  i: 现在分词, // -ing  3: 第三人称单数,  r: 形容词比较级, // -er  t: 形容词最高级, // -est  s: 名词复数形式,  0: 原型,  1: 原型变换形式);// 词形部分数据格式描述: https://github.com/skywind3000/ECDICT#E8AF8DE5BDA2E58F98E58C96function 提取词形(原字符串)   var 变化 = [];  if (!原字符串)     return 变化;    var 词形字段 = 原字符串.split(/);  for (var 某字段 of 词形字段)     var 分段 = 某字段.split(:);    var 类型 = 词形类型[分段[0]];    var 原型变化形式 = [];    if (类型 == 原型变换形式)       for (var 变化形式 of 分段[1])         原型变化形式.push(词形类型[变化形式]);              // 如hyphen(vt): s:hyphens/p:hyphened/i:/3:hyphens/d:, i与d内容缺失, 用空字符串占位    变化.push(      类型: 类型,      变化: 分段.length == 1 ?  : (类型 == 原型变换形式 ? 原型变化形式 : 分段[1])        );    return 变化;此词形变化数据对词典用户也许用处不大, 但Chrome插件实现GitHub代码离线翻译v0.0.4项目比较需要.另外, 考虑将词典数据也并入之前的初步尝试将传统学科的内容程序/数据化知识库中, 并将JS格式的知识库通过CDN进行分发.  离线英汉词典 – 下载 🦊 Firefox 扩展（zh-CN）​  离线英汉词典"
    } ,
  
    {
      "title"    : "初步尝试将传统学科的内容程序/数据化",
      "category" : "命名, 学科结合",
      "description" : "将数学, 历史等传统学科的内容用代码进行表达. Use program to implement common-sense knowledge, like math and history.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E5%AD%A6%E7%A7%91%E7%BB%93%E5%90%88/2018/10/27/%E5%88%9D%E6%AD%A5%E5%B0%9D%E8%AF%95%E5%B0%86%E4%BC%A0%E7%BB%9F%E5%AD%A6%E7%A7%91%E7%9A%84%E5%86%85%E5%AE%B9%E7%A8%8B%E5%BA%8F_%E6%95%B0%E6%8D%AE%E5%8C%96.html",
      "date"     : "2018-10-27 00:00:00 -0700",
      "content"  : "前文它山之石-日本推广编程中使用日语命名的渊源之后, 唤起了以前的一个想法:将尽可能多的教科书知识(从小学开始)用程序+数据整理表达, 比如梯形定义,面积, 主谓宾语法, 电流公式, 煤矿富集的省份, 19xx年发生的历史事件等等. 感觉与前文的学科结合手段有点接近, 范围也许更广.感觉这样的项目做大了就会接近wolfram知识库, 优势是开源, 中文化和更侧重中国相关的数据. 下面从数学和历史两个方向做了非常初步的尝试.数学尝试从人教版小学数学一年级上册开始, 但也许从更高年级开始更有可行性(更容易程序化).“准备课”中的认知部分, 如认识上下左右前后, 算法识别不现实. 比多少的部分, 在没有加减能力的前提下, 通过将两组物品进行1:1的摆放, 定义了”同样多”, “A比B多/少”的概念. 因此也模拟此过程, 避免使用加减法和数字大小比较, python3实现如下:from enum import Enumclass 比较结果(Enum):  多 = 多  少 = 少  同样 = 同样def 比较(组1, 组2):  for 序号 in range(10):    if 组1:      if not 组2:        return 比较结果.多      else:        组1.pop(0)        组2.pop(0)    else:      if 组2:        return 比较结果.少      else:        return 比较结果.同样print(比较([1,2], [1,2,3]))print(比较([1,2,3], [1,2]))print(比较([1,2,3], [1,2,3]))历史先用Python3, 后用JavaScript(因为想和通过浏览器插件实现一个计算/编程工具 · Issue #61 · program-in-chinese/overview结合)编写历史数据, 感觉有几个优势:  数据是文本格式, 易于合作编辑  易于扩展和重构, 相比数据库, 可以更方便地增减/修改数据之间的关系  编辑时可以借助IDE的自动补全, 语法错误等功能, 减少笔误  易于编写自动测试以保证一些基本检验规则, 比如朝代没有重合部分, 先辈出生日期肯定早于后辈, 等等.  易于直接使用数据进行分析:  比如这样:Array.prototype.diff = function(a)   return this.filter(function(i) return a.indexOf(i) lt; 0;);;消失国家 = 国家所属时期[朝代.春秋].diff(国家所属时期[朝代.战国])console.log(春秋消失的国家:  + JSON.stringify(消失国家))输出:春秋消失的国家: [晋国,宋国,吴国,越国,鲁国]下面是源码, 仅作原型演示之用, 如果正式开始项目会采用更翔实的史实参考来源(如教材). 数据结构设计等等很不成熟, 请多指摘, 尤其是TODO部分.// 来源: 中国少儿百科全书-历史大观: 河姆渡文化-郑和下西洋var 朝代 = Object.freeze(  新石器: 新石器时代,  东周: 东周,  春秋: 春秋时期,  战国: 战国时期,  秦: 秦朝,  西汉: 西汉,  东汉: 东汉,  三国: 三国时期,  隋: 隋朝,  唐: 唐朝,  元: 元朝,  明: 明朝);var 社会类型 = Object.freeze(  氏族社会: 氏族社会,  母系社会: 母系社会);// TODO: 添加地点关系, 如国-地区-省-市-镇, 以及行政区划改变(村-gt;镇等)var 地点 = Object.freeze(  浙江: 浙江省,  余姚: 余姚市,  河姆渡: 河姆渡文化,  长江下游: 长江下游地区,  黄河中游: 黄河中游地区,  陕西: 陕西省,  西安: 西安市,  半坡: 半坡遗址,  长安: 长安,  洛阳: 洛阳,  齐: 齐国,  晋: 晋国,  宋: 宋国,  秦: 秦国,  楚: 楚国,  吴_春秋: 吴国,  越: 越国,  燕: 燕国,  韩: 韩国,  赵: 赵国,  魏_战国: 魏国,  鲁: 鲁国,  匈奴: 匈奴,  大月氏: 大月氏,  西域: 西域,  官渡: 官渡,  赤壁: 赤壁,  魏_三国: 魏国,  蜀国: 蜀国,  吴_三国: 吴国,  吐蕃: 西藏,  蒙古: 蒙古国,  中亚: 中亚,  东欧: 东欧,  西洋: 东南亚和印度洋沿海);// TODO: 更多人物信息, 如原名, 性别, 小名等等var 人物 = Object.freeze(  周平王: 周平王,  齐桓公: 齐桓公,  晋文公: 晋文公,  宋襄公: 宋襄公,  秦穆公: 秦穆公,  楚庄王: 楚庄王,  吴王: 阖闾,  越王: 勾践,  孔子: 孔子,  老子: 老子,  墨子: 墨子,  孟子: 孟子,  秦王: 嬴政,  汉景帝: 汉景帝,  汉武帝: 刘彻,  卫青: 卫青,  霍去病: 霍去病,  张骞: 张骞,  袁绍: 袁绍,  袁术: 袁术,  曹操: 曹操,  孙坚: 孙坚,  刘备: 刘备,  孙权: 孙权,  曹丕: 曹丕,  汉献帝: 汉献帝,  唐太宗: 李世民,  李靖: 李靖,  尉迟恭: 尉迟恭,  李建成: 李建成,  魏征: 魏征,  文成公主: 文成公主,  松赞干布: 松赞干布,  武则天: 武则天,  唐高宗: 唐高宗,  成吉思汗: 铁木真,  忽必烈: 忽必烈,  郑和: 马和,  朱棣: 朱棣);var 年号 = Object.freeze(  贞观: 贞观);var 路线 = Object.freeze(  丝绸之路: 丝绸之路);var 群体 = Object.freeze(  儒家: 儒家,  道家: 道家,  墨家: 墨家)var 行为 = Object.freeze(  栽种: 栽种,  制作: 制作,  结婚: 结婚,  求教: 求教,  消灭: 消灭,  出使: 出使,  出击: 出击,  击败: 击败,  效力: 效力,  称帝: 称帝);var 植物 = Object.freeze(  水稻: 水稻);var 物件 = Object.freeze(  陶器: 陶器);var 国家所属时期 = Object.freeze(  [朝代.春秋]: [地点.齐, 地点.晋, 地点.宋, 地点.秦, 地点.楚, 地点.吴_春秋, 地点.越, 地点.鲁],  [朝代.战国]: [地点.齐, 地点.楚, 地点.燕, 地点.秦, 地点.韩, 地点.赵, 地点.魏_战国],  [朝代.三国]: [地点.魏_三国, 地点.吴_三国, 地点.蜀国]);// 数字为公元纪年, 如-5000即公元前5000年, 221即公元后221年// TODO: 很多年份如秦代-200需更正var 时间跨度 = Object.freeze(  [地点.河姆渡]: 开始: -6000, 结束: -5000,  [地点.半坡]: 开始: -4400, 结束: -4300,  [朝代.东周]: 开始: -770, 结束: -221,  [朝代.秦]: 开始: -221, 结束: -200,  [朝代.西汉]: 开始: -200, 结束: 0,  [朝代.东汉]: 开始: 0, 结束: 229,  [年号.贞观]: 开始: 626, 结束: 650);// TODO: 此表仅在人物无具体生卒年月时有用var 所属时期 = Object.freeze(  [地点.半坡]: 朝代.新石器,  [地点.河姆渡]: 朝代.新石器,  [人物.孔子]: 朝代.春秋,  [人物.老子]: 朝代.春秋,  [人物.卫青]: 朝代.西汉,  [人物.霍去病]: 朝代.西汉);var 所属地点 = Object.freeze(  [人物.孔子]: 地点.鲁,);var 人物所属群体 = Object.freeze(  [人物.孔子]: 群体.儒家,  [人物.孟子]: 群体.儒家,  [人物.老子]: 群体.道家,  [人物.墨子]: 群体.墨家);var 属性 = Object.freeze(  [地点.河姆渡]: 社会类型.氏族社会,  [地点.半坡]: 社会类型.母系社会);// 行为方向为: 前者对后者// TODO: 加入事件发生时间, 地点var 事件 = Object.freeze(  [行为.结婚]: [(人物.文成公主, 人物.松赞干布), (人物.武则天, 人物.唐高宗)],  [行为.栽种]: [(地点.河姆渡, 植物.水稻)],  [行为.制作]: [(地点.半坡, 物件.陶器)],  [行为.求教]: [(人物.孔子, 人物.老子)],  [行为.消灭]: [(地点.秦, 地点.韩), (地点.秦, 地点.赵), (地点.秦, 地点.魏_战国)],  [行为.出使]: [(人物.张骞, 地点.西域), (人物.郑和, 地点.西洋)],  [行为.出击]: [(人物.卫青, 地点.匈奴), (人物.霍去病, 地点.匈奴)],  [行为.击败]: [(人物.曹操, 人物.袁绍)],  [行为.效力]: [(人物.魏征, 人物.李建成), (人物.魏征, 人物.唐太宗), (人物.李靖, 人物.唐太宗), (人物.尉迟恭, 人物.唐太宗), (人物.郑和, 人物.朱棣)],  [行为.称帝]: [(人物.曹丕, 地点.魏_三国, 220), (人物.刘备, 地点.蜀国, 221), (人物.孙权, 地点.吴_三国, 229)]);var 名言 = Object.freeze(  [人物.唐太宗]: [民, 水也; 君, 舟也. 水能载舟, 亦能覆舟]);之前问过的: 有没有公开的中国历史人物事件数据库? 其中并没有很多事件数据, sqlite数据库就有230MB. 考虑将数据范围限制在教材内, 以避免数据量过度膨胀.源于讨论: 通过中文命名将少儿编程与核心学科结合起来 · Issue #97 · program-in-chinese/overview相关问题: 有哪些开源的知识库(数据, 非软件)? - V2EX"
    } ,
  
    {
      "title"    : "Chrome插件实现GitHub代码离线翻译v0.0.4",
      "category" : "命名, 翻译",
      "description" : "实现Chrome插件, 基于本地词典数据, 提供Github在线源码翻译功能. Implement a Chrome extension to translate English source code to Chinese on Github pages.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/10/19/Chrome%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0GitHub%E4%BB%A3%E7%A0%81%E7%A6%BB%E7%BA%BF%E7%BF%BB%E8%AF%91v0.0.4.html",
      "date"     : "2018-10-19 00:00:00 -0700",
      "content"  : "续前文Chrome插件实现GitHub代码翻译v0.0.3. 添加了对驼峰命名的支持. 由于调用浏览器插件-离线英汉词典进行词汇翻译, 因此也不依赖于任何在线翻译服务.Chrome插件: 官网链接支持所有编程语言因为并不需要对源代码进行语法分析(之前Java源码英翻中进展-内测上线中使用了语法分析, 工作量大很多), 因此原则上已经支持所有编程语言的源代码. 但对一些编程语言效果更好, 见下面效果.Java: 源码来源Python: 源码来源C: 源码来源 接下去添加C的关键词翻译后, include/char就不会那么坑了.阶段小结翻译方面做下去会遇到和自然语言机器翻译类似的问题. 当然会比自然语言好一些, 因为命名往往使用的是最正式(非口语化)的词汇, 连接词的使用也较少, 而且基本没有完整语句. 即便如此, 也会存在词汇的歧义, 比如词性问题, 比如顶图例子中BasicCalculator, Basic在內建词典中有名词/形容词几种词义:n. 基本原理, 要素, 基本规律a. 基本的, 碱性的(计算机)BASIC语言现在的算法是直接用首个词义, 就是名词的”基本原理”. 再比如”tell”在没有后接名词时应该是取vi释义:vt. 告诉, 说, 吩咐, 断定, 知道vi. 讲述, 泄密, 告发, 表明改进就需要加入自然语言处理的方法.源码文本处理.js中驼峰命名拆分:function 拆分骆驼命名(命名)   // 参考: https://stackoverflow.com/a/7599674/1536803  return 命名.split(/(?lt;=[a-z])(?=[A-Z])|(?lt;=[A-Z])(?=[A-Z][a-z])/);"
    } ,
  
    {
      "title"    : "它山之石-日本推广编程中使用日语命名的渊源",
      "category" : "命名, 教程",
      "description" : "日本官方和民间在编程中使用日语命名的相关历史. Brief history of  naming identifiers in Japanese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/10/18/%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3-%E6%97%A5%E6%9C%AC%E6%8E%A8%E5%B9%BF%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A5%E8%AF%AD%E5%91%BD%E5%90%8D%E7%9A%84%E6%B8%8A%E6%BA%90.html",
      "date"     : "2018-10-18 12:00:00 -0700",
      "content"  : "续前文首次发现在例程中使用日语命名的编程书籍, 调研了一下日本对日语命名的以往研究和相关政策, 罗列如下, 望多多补充.希望国内的编程教育(尤其是少儿教育)加以借鉴, 使用中文命名将编程与核心学科紧密结合起来.2018年3月的小学校プログラミング教育の手引 （第一版） 小学编程教育指导中所有示例都是日语命名, 与其他学科进行了结合:2018年11月7日更新的: 小学校プログラミング教育の手引 （第二版） 小学编程教育指导2017年论文小学校におけるプログラミング 教育実践上 の 課題中列举了编程与其他学科的结合, 没有看到英文一项:2017年的论文ローマ字入力時の日本語識別子入力補完プラグインの 開発开发了辅助插件以改进IDE对输入日语命名的支持. 摘要中提到(有道翻译):  近年来，软件开发项目的复杂性增加了维护软件所需的时间成本，重要的是为降低成本提高源代码的可读性。作为提高源代码的可读性的方法之一，有几个报告表明，用日语写源代码中的变量和函数的标识符名是有用的。2017年的个人博客: 識別子に日本語を使うことについての考察 - Qiita, 看起来日本业界暂没有一个广泛的日语命名标准.2014年博客[コーディングスタイル]識別子を日本語に切り替えていく - Qiita, 讨论了日语命名的诸多好处, 也回答了很多质疑.但之前在第一次见以汉字命名的 Java 类 - V2EX中有同行提及:  没记错的话，日本开发 Java 用罗马音做方法名，假名做变量名（可能记反），所以对日外包要求日语 N2也许是某些公司的个别行为? 仍待继续考证.参考2018年博客: 日本語識別子が流行らないのは2013年博客: C++の識別子に日本語を使いたい理由2012年4月演讲: 日本語識別子の必要性2009年博客: 日本語識別子における複数の表現 讨论单复数表达日语编程语言日语编程语言”抚子” - 第三版特色初探日本語プログラミング言語 Mind"
    } ,
  
    {
      "title"    : "首次发现在例程中使用日语命名的编程书籍",
      "category" : "命名, 教程",
      "description" : "第一次发现在例程中使用日语命名的编程教程, 为Javascript入门. Found a programming book with sample programs naming identifiers in Japanese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/10/18/%E9%A6%96%E6%AC%A1%E5%8F%91%E7%8E%B0%E5%9C%A8%E4%BE%8B%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A5%E8%AF%AD%E5%91%BD%E5%90%8D%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D.html",
      "date"     : "2018-10-18 00:00:00 -0700",
      "content"  : "初めてのJavaScript 第3版 – ES2015以降の最新ウェブ開発. 示例代码:class Person   constructor(name)     this.name = name;    this.id = Person.nextId++;  Person.nextId = 0;const 一郎 = new Person(一郎), /* id 0 */      次郎 = new Person(次郎), /* id 1 */      三郎 = new Person(三郎), /* id 2 */      四郎 = new Person(四郎); /* id 3 */const arr = [一郎, 次郎, 三郎, 四郎];/* 1. IDを使って直接比較 */console.log(arr.find(p =gt; p.id === 三郎.id)); // Person  name: '三郎', id: 2 /* 2. thisを利用。thisを定数「三郎」に指定 */console.log(arr.find(function(p) return p.id === this.id, 三郎));                                              // Person  name: '三郎', id: 2 /* アロー関数ではthisは「語彙的に（lexically）」に束縛される（6章参照） */console.log(arr.find(p =gt; p.id === this.id, 三郎)); // undefined译者对采用日语命名的缘由在此阐述初めてのJavaScript 第3版 – ES2015以降の最新ウェブ開発(2016年12月):  翻訳の過程で、一部の例を日本語の識別子（変数名や関数名など）を使って書いてみましたが、「日本語で関数名や変数名を考えるのはとても楽だなあ」と感じました。英語を仕事で毎日使っている私でもそうなのですから、普通の方ならなおさらでしょう。コメントと識別子の区別がつきにくいなど、慣れないと少し読みにくい印象はありますが、特に書く際の負担はだいぶ減るように感じます。また、たとえば単数形のbookで、値をひとつ記憶する変数、複数形のbooksで配列を表すといった手法が日本語では使えないなど、日本語独特の工夫が必要になる場面があるかもしれません（一部の例では「本」と「本_配列」のようにしてみましたが）。これからは、日本国内をターゲットにした開発では徐々に日本語識別子が使われることになるのでしょう。英語の本を読むよりも、日本語にていねいに翻訳された本を読むほうが理解がずっと早いのと同じです。倚靠在线翻译, 大致意思如下, 如有出入请指教:  日语命名函数/变量对常人更易理解, 即使译者在日常工作中使用英语仍是如此  虽然使用日语命名导致注释和实际代码行有些难以区分(日文注释+英文代码会比较显眼), 但译者编写时更容易 lt;–这里不大确定含义  有时单复数难以在日语中表达, 此时还是沿用英文命名 – 中文命名也有类似情况, 之前的探讨: 中文命名的特定问题, 相关风格及规范 · Issue #45 · program-in-chinese/overview, 在代码中进行中文命名(类/变量/方法等)的优势  最后提到(粗体部分): 对面向日本国内的软件开发, 将会逐渐普及使用日语命名. 阅读使用日语命名的编程书籍会比英文原版更容易理解. – 听起来似乎是有某些日本的业内推动力量, 值得深入发掘一下.补译者 武舎 広幸 Hiroyuki Takeba 简历(机翻):  出生于长野县上田市。他在东京工业大学，科学技术研究生院，国际基督教大学，山梨大学研究生院，俄亥俄州立大学研究生院，卡内基梅隆大学机器翻译中心等完成博士课程。作为Merlin Arms Co.，Ltd。（http://www.marlin-arms.co.jp）的代表董事，他从事与计算机和自然科学，软件开发（翻译软件等），软件项目管理，在线翻译课程（http://www.dhc-online.com）相关的翻译和写作。和字典网站（http://www.dictjuggler.net）另外, 看来日语命名在日本开发者中也是有阻力的, 日本語識別子（変数名や関数名）を好まれない方がいらっしゃるようですので - “似乎有些人不喜欢日语标识符（变量名和函数名）”(在初めてのJavaScript 第3版 – ES2015以降の最新ウェブ開発). 确实在Amazon上有一星抱怨日语命名的, 但感觉并没什么说服力.无论如何, 日本编程书籍出版商在推广母语命名上先行一步了.期待中文示例代码的编程书籍早日面世.源讨论帖在: 索引: 用中文代码作示例的编程教程 · Issue #5 · program-in-chinese/overview2018-11补:译者发消息, 重印（第四次印刷）已经确定.另外, 经告知之前有一本”我的第一本编程书”日文编程书的中译本中使用了中文命名的示例代码, 但因为偏算法, 个人感觉母语命名的优势不是特别明显.2019-2-16补:发现2003年的日文论坛提到, 2003年出版的”MYSQL徹底活用(翔泳社-初版)”一书中(貌似MySQL徹底活用―SQL言語+サーバアプリケーション+管理者編 データベースの本), 使用了日文命名的示例代码:CREATE TABLE 社員  (    社員番号 INT NOT NULL,    氏名 CHAR(20) NOT NULL,    性別 ENUM(`男`,`女`) NOT NULL,    部署コード INT NOT NULL,    入社年度 year NOT NULL,    MAIL CHAR(40) NOT NULL,    INDEX (社員番号),    INDEX (氏名));"
    } ,
  
    {
      "title"    : "Chrome插件实现GitHub代码翻译v0.0.3",
      "category" : "命名, 翻译",
      "description" : "实现Chrome插件, 基于本地词典数据, 提供Github在线源码翻译功能. Show how to translate English source code to Chinese on Github pages.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/10/17/Chrome%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0GitHub%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91v0.0.3.html",
      "date"     : "2018-10-17 00:00:00 -0700",
      "content"  : "续前文浏览器插件实现GitHub代码翻译原型演示, 通过调用浏览器插件-离线英汉词典的批量查词接口, 实现了源码的初步命名直译.源码库仍在: program-in-chinese/webextension_github_code_translator还缺失的功能: 驼峰命名法拆分. 比如图中所示, BasicCalculator未翻译.语言关键词词典.js. 內建词典包括常用关键词, 以及Java和Python的专用关键词:var 通用关键词 =   'assert': 断言,  'import': 导入,  if: 如果,  else: 否则,  while: 每当,  for: 对于,  in: 在,  switch: 岔,  case: 分支,  break: 跳出,  continue: 继续,  return: 返回,  throw: 抛出,  finally: 善后,  'class': 类别,  'is': 为var 专用关键词 =   /*  参考 http://zetcode.com/lang/python/keywords/  import keyword  print(Python keywords: , keyword.kwlist)  */  python:     'False': 假,    'None': 空,    'True': 真,    'and': 且,    'as': as,    'def': 定义,    del: 删除,    'elif': 否则如果,    'except': except,    'from': 从,    'global': 全局,    'lambda': lambda,    'nonlocal': nonlocal,    'not': 不,    'or': 或,    'pass': 轮空,    'raise': 抛出,    'with': with,    'yield': 产出  ,  // 参考 https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html  java: ...  释义处理.js. 查词后, 选取一个”合适”的词义, 这里还很粗糙:function 首选(中文释义, 所有词性)   if (!中文释义)     return;    var 首选词义 = ;  var 词性到释义 = 分词性(中文释义, 所有词性);  //console.log(词性到释义);  if (词性到释义[词性_计算机])     首选词义 = 词性到释义[词性_计算机][0];   else     // 取第一个词性的第一释义    for (var 词性 in 词性到释义)       首选词义 = 词性到释义[词性][0];      break;        return 首选词义;主界面.js中进行翻译的主体部分:function 翻译()   var 原代码拷贝 = document.getElementsByTagName('table')[0];  var 顶节点 = 原代码拷贝.parentElement;  var 编程语言 = 取编程语言(顶节点);  var span字段列表 = 原代码拷贝.getElementsByTagName('span');  var 文本字段列表 = 取子文本节点(document);  关键词词典 = 取所有关键词(编程语言);  // 合并两个部分  添加所有待查词(span字段列表);  添加所有待查词(文本字段列表);  chrome.runtime.sendMessage(    ndifefelacmidghjaehmhicbchbidhpe,    命名词典,    function(返回值)       命名词典 = 返回值.所有释义;      for (var 词 in 命名词典)         命名词典[词] = 常用命名[词] ? 常用命名[词] : 首选(命名词典[词], 词性);            翻译字段列表(span字段列表);      翻译字段列表(文本字段列表);      顶节点.insertBefore(document.createTextNode(编程语言:  + 编程语言), 原代码拷贝);      );"
    } ,
  
    {
      "title"    : "浏览器插件-离线英汉词典",
      "category" : "命名, 词典",
      "description" : "实现浏览器插件, 基于本地词典数据, 提供网页上英语词语查询汉语释义功能. Show how to implement English to Chinese dictionary using local data in browser extension.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E8%AF%8D%E5%85%B8/2018/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6-%E7%A6%BB%E7%BA%BF%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8.html",
      "date"     : "2018-10-12 00:00:00 -0700",
      "content"  : "如前文在浏览器插件中读取JSON资源文件末所述, 用浏览器插件实现了不依赖任何在线翻译服务的英汉词典. 由于词典包含77万个词条, 插件大小也达到了13+MB.词典数据也包含很多常见短语:源码库: program-in-chinese/webextension_english_chinese_dictionary在火狐插件网站提交审核时, 发现源文件大小有限制, 超过4MB就不能被审核服务自动分析. 于是按每个词典文件五万词条进行分隔(详见转换到JSON; 按五万行分隔json · program-in-chinese/english-chinese-dictionary10b55f6)插件源码主要是导入词典数据和查询/显示两部分:加载词典.jsconst 词典路径 = '词典数据/词典'const 文件扩展 = '.json'var 词典文件 = ;for (var 文件序号 = 0; 文件序号 lt; 16; 文件序号++)   词典文件[文件序号] = false;var 词典数据 = ;function 载入部分词典(文件)   return function ()     var 文件路径 = 词典路径 + 文件 + 文件扩展;    fetch(chrome.runtime.getURL(文件路径))      .then((响应) =gt; 响应.json())      .then((数据) =gt;         for (var 英文 in 数据)           词典数据[英文] = 数据[英文];                词典文件[文件] = true;      );  for (var 文件 in 词典文件)   载入部分词典(文件)();function 已载入词典()   for (var 文件 in 词典文件)     if (!词典文件[文件])       return false;        return true;function 取释义(选中文本)   var 释义 = 词典数据[选中文本];  if (!释义)     选中文本 = 选中文本.toLowerCase();    释义 = 词典数据[选中文本];    return 释义;主界面.jsfunction 翻译选中文本()   chrome.tabs.executeScript(    code: window.getSelection().toString();  , function (选中内容)     // TODO: 如果没有toString, 报错: -,.toLowerCase is not function    var 选中文本 = 选中内容.toString();    if (!选中文本)       置弹窗内容(无选中文本);      return;        var 词典接口 = chrome.extension.getBackgroundPage();    if (!词典接口.已载入词典())       置弹窗内容(载入词典数据中...);      return;        var 释义 = 词典接口.取释义(选中文本);    置弹窗内容(选中文本, 释义);  );function 置弹窗内容(英文, 释义)   var 窗体 = document.body;  var 英文部分 = document.getElementById(英文);  var 释义部分 = document.getElementById(释义);  英文部分.appendChild(document.createTextNode(英文));  var 多行 = 释义.split('#92;#92;n');  for (var 行数 in 多行)     释义部分.appendChild(document.createTextNode(多行[行数]));    释义部分.appendChild(document.createElement(br));  翻译选中文本();另, 已在Chrome插件商店发布. 链接如下:  火狐插件  Chrome插件"
    } ,
  
    {
      "title"    : "在浏览器插件中读取JSON资源文件",
      "category" : "命名",
      "description" : "实现浏览器插件, 读取插件内较大的json资源文件. Show how to read json resource file in browser extension.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2018/10/10/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96JSON%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6.html",
      "date"     : "2018-10-10 00:00:00 -0700",
      "content"  : "续前文: 浏览器插件实现GitHub代码翻译原型演示此改进只为演示: 词典数据提取到json文件 · program-in-chinese/webextension_github_code_translatorce932dfmanifest.json中添加资源路径:  web_accessible_resources: [    词典数据/*.json  ]主界面.js中加载数据:const 关键词词典文件 = '词典数据/关键词.json'fetch(chrome.runtime.getURL(关键词词典文件))  .then((响应) =gt; 响应.json())  .then((词典数据) =gt; 关键词词典 = 词典数据)  .then(翻译代码段);下面打算通过这个方法, 使用Java实现英汉词典API初版发布在Maven中的英汉词典数据, 实现一个离线英汉词典浏览器插件(现在看到的英汉词典插件都通过访问在线服务实现). 还需将原始csv数据转换为JSON, 考虑为缩减数据量删去原数据中的英文释义部分, 即使如此插件包也至少10多M, 顺便挑战一下火狐插件大小上限.参考  Reading files in a Chrome Extension  Promise.prototype.then()  Using Fetch  Arrow functions"
    } ,
  
    {
      "title"    : "Java源码英翻中进展-内测上线",
      "category" : "命名, 翻译",
      "description" : "解析Java源码, 并将标识符翻译为中文服务部署. Demonstrate the library to parse Java source code and translate the identifiers to Chinese with a domain.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/10/08/Java%E6%BA%90%E7%A0%81%E8%8B%B1%E7%BF%BB%E4%B8%AD%E8%BF%9B%E5%B1%95-%E5%86%85%E6%B5%8B%E4%B8%8A%E7%BA%BF.html",
      "date"     : "2018-10-08 00:00:00 -0700",
      "content"  : "创建了一个子域名: http://translate.codeinchinese.com/ 欢迎试用, 如有建议/发现问题欢迎在此拍砖: program-in-chinese/code_translator_service.服务器硬件配置见前文: 中文代码之Spring Boot添加基本日志功能上, 续前文Java源码英翻中网页演示, 做了一点改进: 对类型中的字段进行翻译(比如上图中的visitedCountries翻译为’拜访国家’)短期内需改进: 术语词典. 比如上面的long, 现在直译为’长’, 需要改进为比如’长整型’. 还有serialVersionUID, 还需通过添加内置字典修正.Java源码翻译库相关源码  static void 翻译字段(JavaClassSource 类结构)     Listlt;FieldSourcelt;JavaClassSourcegt;gt; 字段 = 类结构.getFields();    for (FieldSourcelt;JavaClassSourcegt; 某字段 : 字段)       String 字段名 = 某字段.getName();      try         System.out.println(字段名:  + 字段名);        String 翻译字段名 = 查词(字段名);        某字段.setName(翻译字段名);       catch (IllegalArgumentException e)         System.out.println(不合法字段名:  + 字段名);            Typelt;JavaClassSourcegt; 类型 = 某字段.getType();      某字段.setType(翻译类型(类型));      "
    } ,
  
    {
      "title"    : "[日常]用Python读取word文档中的表格并比较",
      "category" : "命名, 教程",
      "description" : "用Python3读取word文档中的表格并比较. Create a wubi encoding editor using Python with Chinese naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/10/04/%E6%97%A5%E5%B8%B8-%E7%94%A8Python%E8%AF%BB%E5%8F%96word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%B9%B6%E6%AF%94%E8%BE%83.html",
      "date"     : "2018-10-04 00:00:00 -0700",
      "content"  : "最近想对某些word文档(docx)的表格内容作比较, 于是找了一下相关工具. 参考Automate the Boring Stuff with Python中的word部分, 试用了python-docx - python-docx 0.8.7 documentation演示如下. 两个简单的word文档, 各有一个表格:读取文档中的表格到列表(为演示只对单列表格操作):import docxdef 取表格(文件名):  文件 = docx.Document(文件名)  首个表 = 文件.tables[0]  值 = []  for 行 in 首个表.rows:    for 格 in 行.cells:      值.append(格.text)  print(文件名 +  -gt;  + str(值))  return 值    表1 = 取表格('表1.docx')读取结果:表1.docx -gt; ['值1', '值2', '值3']接着找到这个做比较的python库seperman/deepdiff, 来源: Get difference between two listsfrom deepdiff import DeepDiff表1 = 取表格('表1.docx')表2 = 取表格('表2.docx')print(DeepDiff(表1, 表2))输出结果(为更可读, 已手动格式化):'values_changed':   'root[1]':     'new_value': '值2.5', 'old_value': '值2'  , 'iterable_item_added':   'root[3]': '值4'显示了修改的值和添加的值, 还挺好用. 实际的表格是两列, 需要按照某个键值作对比. 于是用字典, 正好DeepDiff也提供两个字典间的比较. 双列表文件演示:读取双列表到字典后, 进行比较:import docxfrom deepdiff import DeepDifffrom pprint import pprintdef 取表格(文件名):  文件 = docx.Document(文件名)  首个表 = 文件.tables[0]  值 =   for 行 in 首个表.rows:    格 = 行.cells    值[格[0].text] = 格[1].text  print(文件名 +  -gt;  + str(值))  return 值表1 = 取表格('双列表1.docx')表2 = 取表格('双列表2.docx')pprint(DeepDiff(表1, 表2), indent=2)输出如下: 'dictionary_item_added': root['键3'],  'values_changed': root['键2']: 'new_value': '值2.5', 'old_value': '值2'源码在: program-in-chinese/house_of_10000_business"
    } ,
  
    {
      "title"    : "用Python3和tkinter开发简单图形界面程序",
      "category" : "命名, 教程",
      "description" : "用Python3和tkinter开发五笔编码编辑器. Create a wubi encoding editor using Python with Chinese naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/09/28/%E7%94%A8Python3%E5%92%8Ctkinter%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F.html",
      "date"     : "2018-09-28 00:00:00 -0700",
      "content"  : "源码库: program-in-chinese/wubi_code_editor起因在这里. 由于此项目和汉字相关, 个人也想尝试Python的图形界面开发, 于是开始尝试.遇到的一个坑. 用户测试时, 发现png图片加载不了, 后发现是由于tkinter版本问题: Tkinter.PhotoImage doesn’t not support png image现在还处于原型状态, 两百多行代码都在一个文件中. 几个主要问题:  界面需要分离, 与界面无关的部分需要添加测试用例  文件路径只支持Linux/Mac, 还需支持Windows, 参考: Python 3 Quick Tip: The easy way to deal with file paths on Windows, Mac and Linux  完善功能: 支持对缺失数据的添加, 按编码范围导出到不同文件(出处); 按字搜索; 笔顺数据; Unicode 编码区  在VS code下开发, 还没使用测试/调试相关功能. 参考: Python in Visual Studio Code源码节选:读入csv源数据:    def 读入源数据文件(self, 文件名):        # 官方文档参考: https://docs.python.org/3/library/csv.html#module-contents        with open(文件名, newline='') as 源数据文件:            源数据读取器 = csv.reader(源数据文件, delimiter=',')            for 行 in 源数据读取器:                self.字符列表.append(行)导出csv文件:    def 导出文件(self):        with open(常量_修改后文件, 'w', newline='') as 目标文件:            写文件 = csv.writer(目标文件, delimiter=',')            for 字符 in self.字符列表:                写文件.writerow(字符)        print(修改保存到:  + 常量_修改后文件)创建图片显示:    # 显示图片, 参考: https://stackoverflow.com/questions/35024118/how-to-load-an-image-into-a-python-3-4-tkinter-window    def 创建图片显示(self, 区域, 字体名, 位置):        字体区 = Frame(区域)        字体区.pack(side = 位置)        字体提示 = Label(字体区, text = 字体名)        字体提示.pack()        图片路径 = 常量_图片主目录 + 常量_图片路径[字体名] + self.图片子路径        print(图片路径)        try:            图片 = PhotoImage(file=图片路径)        except:            print(找不到图片)            图片 = PhotoImage()        图片显示 = Label(字体区, image=图片)        图片显示.image = 图片        图片显示.pack()        return 图片显示———– 10/1/2018 更新 ————功能和重构基本完成. 还剩下一个问题”文件路径只支持Linux/Mac, 还需支持Windows”, 由于题主只在Linux下使用, 暂不打算实现.经过添加测试, 发现了几个bug.承蒙题主宣传: 感谢 xuanwu 制作五笔编码编校软件 Python 版 - V2EX———- 12/24/2018 更新 ———-上个月题主提交了好几个PR, 很高兴看到原本的纯用户成为了合作者. 最近的在国内原创开源项目中使用中文命名的意义与方式一文也受了这个实例的启发."
    } ,
  
    {
      "title"    : "Java源码英翻中网页演示",
      "category" : "命名, 翻译",
      "description" : "解析Java源码, 并将标识符翻译为中文演示网页. Demonstrate the library to parse Java source code and translate the identifiers to Chinese with a web application.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/09/24/Java%E6%BA%90%E7%A0%81%E8%8B%B1%E7%BF%BB%E4%B8%AD%E7%BD%91%E9%A1%B5%E6%BC%94%E7%A4%BA.html",
      "date"     : "2018-09-24 00:00:00 -0700",
      "content"  : "在线演示地址: 源代码翻译两部分如下.独立的Java代码翻译库续前文代码翻译尝试-使用Roaster解析和生成Java源码源码库: program-in-chinese/java_code_translator功能在前文基础上: 重构; 完善测试(基本涵盖主要接口); 小改进 - 支持数组类型的属性和方法返回类型的翻译, 如”String[]” -gt; “字符串[]”源码节选翻译Java代码.java, 按类/Bean属性/方法三部分翻译命名. 仍不处理方法内容.  public static String 翻译源码结构(String 源码)     JavaClassSource 类结构;    try       类结构 = 取类结构(源码);     catch (ParserException e)       return e.getLocalizedMessage();        翻译类(类结构);    翻译属性(类结构);    翻译方法(类结构);        return 类结构.toUnformattedString();  部署暂未发布到Maven, 在部署时, 运行’mvn install’安装jar包到本地(服务器同样).Spring Boot实现源码服务续前文Java源码英翻中库以及服务原型源码库: program-in-chinese/code_translator_service, maven依赖上面的库java_code_translator前端部分暂时合在同一库”前端”文件夹: program-in-chinese/code_translator_service功能  前端方面          实现了最简单的前端, 左边输入源码, 右边显示翻译结果      支持语法高亮: 基于CodeMirror, 包括行号, 关键词高亮, 类名等等. 它支持100多编程语言, 适于今后添加其他语言支持.      源码节选前端-Java模式语法高亮:    var 输入 = CodeMirror.fromTextArea(document.getElementById(英文源码输入),         mode : text/x-java,        lineNumbers : true,        matchBrackets : true    );    输入.setSize(500, 500);前端-访问后台(document).ready(function()     (#翻译按钮).click(function()         输出.setValue(处理中...);        .post(http://74.91.17.250:8091/,             code : 输入.getValue()        , function(结果)             输出.setValue(结果.内容);        , json);    ););后台部分-翻译控制器.javaRestControllerpublic class 翻译控制器   private static final Logger 笔录 = LoggerFactory.getLogger(翻译控制器.class);  CrossOrigin(origins = http://74.91.17.250:9000)  RequestMapping(value = /, method = RequestMethod.POST)  ResponseBody  public 翻译 翻译(RequestParam(name = code, required = false, defaultValue = ) String 英文源码)     笔录.info(输入:  + 英文源码);    return new 翻译(翻译Java代码.翻译源码结构(英文源码));  部署后台部分打包: mvn package运行: nohup java -jar target/code_translator_service-0.0.1-SNAPSHOT.jar –server.port=8091 amp;前端部分服务器: 将’前端’的public部分拷贝到tomcat(设置port为9000).本地调试: 运行’spring run app.groovy’即在8080启动前端服务; 需修改post地址为”http://localhost:8091/”, 以正确配置CORS."
    } ,
  
    {
      "title"    : "修改V8和node.js建立中文后端开发工具",
      "category" : "语言设计, 汉化关键词",
      "description" : "修改V8编译器源码, 实现关键词的中文化. Modify source code of V8 JavaScript compiler to support keywords in Chinese.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E6%B1%89%E5%8C%96%E5%85%B3%E9%94%AE%E8%AF%8D/2018/09/19/%E4%BF%AE%E6%94%B9V8%E5%92%8Cnode.js%E5%BB%BA%E7%AB%8B%E4%B8%AD%E6%96%87%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7.html",
      "date"     : "2018-09-19 00:00:00 -0700",
      "content"  : "本文github: https://github.com/swizl/zwnode一. 修改V8V8在一个文件里改就行了。#92;deps#92;v8#92;src#92;parsing#92;scanner.cc  从llvm中下一个轮子过来的StringSwitch，当然要改一下。StringRef改成std::wstring, 多余的功能去掉。放在 scanner.cc 开头。狗屎咖啡：为clang添加中文关键字​templatelt;typename T, typename R = Tgt;class StringSwitch   std::wstring Str;  const T *Result;public:  //  explicit StringSwitch(std::wstring S)  : Str(S), Result(nullptr)    // StringSwitch is not copyable.  StringSwitch(const StringSwitch amp;) = delete;  void operator=(const StringSwitch amp;) = delete;  StringSwitch(StringSwitch amp;amp;other)     *this = std::move(other);    StringSwitch amp;operator=(StringSwitch amp;amp;other)     Str = other.Str;    Result = other.Result;    return *this;    ~StringSwitch() = default;  // Case-sensitive case matchers  templatelt;unsigned Ngt;  StringSwitchamp; Case(const wchar_t (amp;S)[N], const Tamp; Value)     assert(N);    if (!Result amp;amp; N-1 == Str.size() amp;amp;        //(N == 1 || std::memcmp(S, Str.data(), (N-1)*sizeof(wchar_t)) == 0))         (N == 1 || Str.compare(S) == 0))       Result = amp;Value;        return *this;    R Default(const T amp;Value) const     if (Result)      return *Result;    return Value;      operator R() const     assert(Result amp;amp; Fell off the end of a string-switch);    return *Result;  ;  加上中文的关键字和英文关键字一样对应, 可以根据自己的喜好随便改。    #define KEYWORDS(KEYWORD_GROUP, KEYWORD, ZWKEYWORD)                    #92;  KEYWORD_GROUP('a')                                        #92;  KEYWORD(arguments, Token::ARGUMENTS)                    #92;  ZWKEYWORD(诸参, Token::ARGUMENTS)                    #92;  KEYWORD(as, Token::AS)                                  #92;  ZWKEYWORD(以, Token::AS)                                  #92;  KEYWORD(async, Token::ASYNC)                            #92;  ZWKEYWORD(异, Token::ASYNC)                            #92;  KEYWORD(await, Token::AWAIT)                            #92;  ZWKEYWORD(等, Token::AWAIT)                            #92;  KEYWORD(anonymous, Token::ANONYMOUS)                    #92;  ZWKEYWORD(匿, Token::ANONYMOUS)                    #92;  KEYWORD_GROUP('b')                                        #92;  KEYWORD(break, Token::BREAK)                            #92;  ZWKEYWORD(破, Token::BREAK)                            #92;  KEYWORD_GROUP('c')                                        #92;  KEYWORD(case, Token::CASE)                              #92;  ZWKEYWORD(例, Token::CASE)                              #92;  KEYWORD(catch, Token::CATCH)                            #92;  ZWKEYWORD(捕, Token::CATCH)                            #92;  KEYWORD(class, Token::CLASS)                            #92;  ZWKEYWORD(类, Token::CLASS)                            #92;  KEYWORD(const, Token::CONST)                            #92;  ZWKEYWORD(常, Token::CONST)                            #92;  KEYWORD(constructor, Token::CONSTRUCTOR)                #92;  ZWKEYWORD(构造器, Token::CONSTRUCTOR)                #92;  KEYWORD(continue, Token::CONTINUE)                      #92;  ZWKEYWORD(继, Token::CONTINUE)                      #92;  KEYWORD_GROUP('d')                                        #92;  KEYWORD(debugger, Token::DEBUGGER)                      #92;  ZWKEYWORD(调试器, Token::DEBUGGER)                      #92;  KEYWORD(default, Token::DEFAULT)                        #92;  ZWKEYWORD(默, Token::DEFAULT)                        #92;  KEYWORD(delete, Token::DELETE)                          #92;  ZWKEYWORD(删, Token::DELETE)                          #92;  KEYWORD(do, Token::DO)                                  #92;  ZWKEYWORD(行, Token::DO)                                  #92;  KEYWORD_GROUP('e')                                        #92;  KEYWORD(else, Token::ELSE)                              #92;  ZWKEYWORD(另, Token::ELSE)                              #92;  KEYWORD(enum, Token::ENUM)                              #92;  ZWKEYWORD(举, Token::ENUM)                              #92;  KEYWORD(eval, Token::EVAL)                              #92;  ZWKEYWORD(估, Token::EVAL)                              #92;  KEYWORD(export, Token::EXPORT)                          #92;  ZWKEYWORD(导, Token::EXPORT)                          #92;  KEYWORD(extends, Token::EXTENDS)                        #92;  ZWKEYWORD(承, Token::EXTENDS)                        #92;  KEYWORD_GROUP('f')                                        #92;  KEYWORD(false, Token::FALSE_LITERAL)                    #92;  ZWKEYWORD(假, Token::FALSE_LITERAL)                    #92;  KEYWORD(finally, Token::FINALLY)                        #92;  ZWKEYWORD(末, Token::FINALLY)                        #92;  KEYWORD(for, Token::FOR)                                #92;  ZWKEYWORD(于, Token::FOR)                                #92;  KEYWORD(from, Token::FROM)                              #92;  ZWKEYWORD(从, Token::FROM)                              #92;  KEYWORD(function, Token::FUNCTION)                      #92;  ZWKEYWORD(函数, Token::FUNCTION)                      #92;  KEYWORD_GROUP('g')                                        #92;  KEYWORD(get, Token::GET)                                #92;  ZWKEYWORD(取, Token::GET)                                #92;  KEYWORD_GROUP('i')                                        #92;  KEYWORD(if, Token::IF)                                  #92;  ZWKEYWORD(如, Token::IF)                                  #92;  KEYWORD(implements, Token::FUTURE_STRICT_RESERVED_WORD) #92;  ZWKEYWORD(成, Token::FUTURE_STRICT_RESERVED_WORD) #92;  KEYWORD(import, Token::IMPORT)                          #92;  ZWKEYWORD(引, Token::IMPORT)                          #92;  KEYWORD(in, Token::IN)                                  #92;  ZWKEYWORD(在, Token::IN)                                  #92;  KEYWORD(instanceof, Token::INSTANCEOF)                  #92;  ZWKEYWORD(是为, Token::INSTANCEOF)                  #92;  KEYWORD(interface, Token::FUTURE_STRICT_RESERVED_WORD)  #92;  ZWKEYWORD(接, Token::FUTURE_STRICT_RESERVED_WORD)  #92;  KEYWORD_GROUP('l')                                        #92;  KEYWORD(let, Token::LET)                                #92;  ZWKEYWORD(让, Token::LET)                                #92;  KEYWORD_GROUP('m')                                        #92;  KEYWORD(meta, Token::META)                              #92;  ZWKEYWORD(元, Token::META)                                #92;  KEYWORD_GROUP('n')                                        #92;  KEYWORD(name, Token::NAME)                              #92;  ZWKEYWORD(名, Token::NAME)                              #92;  KEYWORD(new, Token::NEW)                                #92;  ZWKEYWORD(新, Token::NEW)                                #92;  KEYWORD(null, Token::NULL_LITERAL)                      #92;  ZWKEYWORD(无, Token::NULL_LITERAL)                      #92;  KEYWORD_GROUP('o')                                        #92;  KEYWORD(of, Token::OF)                                  #92;  ZWKEYWORD(之, Token::OF)                                  #92;  KEYWORD_GROUP('p')                                        #92;  KEYWORD(package, Token::FUTURE_STRICT_RESERVED_WORD)    #92;  ZWKEYWORD(包, Token::FUTURE_STRICT_RESERVED_WORD)    #92;  KEYWORD(private, Token::FUTURE_STRICT_RESERVED_WORD)    #92;  ZWKEYWORD(私, Token::FUTURE_STRICT_RESERVED_WORD)    #92;  KEYWORD(protected, Token::FUTURE_STRICT_RESERVED_WORD)  #92;  ZWKEYWORD(保, Token::FUTURE_STRICT_RESERVED_WORD)  #92;  KEYWORD(prototype, Token::PROTOTYPE)                    #92;  ZWKEYWORD(原型, Token::PROTOTYPE)                    #92;  KEYWORD(public, Token::FUTURE_STRICT_RESERVED_WORD)     #92;  ZWKEYWORD(公, Token::FUTURE_STRICT_RESERVED_WORD)     #92;  KEYWORD_GROUP('r')                                        #92;  KEYWORD(return, Token::RETURN)                          #92;  ZWKEYWORD(返, Token::RETURN)                          #92;  KEYWORD_GROUP('s')                                        #92;  KEYWORD(set, Token::SET)                                #92;  ZWKEYWORD(设, Token::SET)                                #92;  KEYWORD(static, Token::STATIC)                          #92;  ZWKEYWORD(固, Token::STATIC)                          #92;  KEYWORD(super, Token::SUPER)                            #92;  ZWKEYWORD(超, Token::SUPER)                            #92;  KEYWORD(switch, Token::SWITCH)                          #92;  ZWKEYWORD(切, Token::SWITCH)                          #92;  KEYWORD_GROUP('t')                                        #92;  KEYWORD(target, Token::TARGET)                          #92;  ZWKEYWORD(标, Token::TARGET)                          #92;  KEYWORD(this, Token::THIS)                              #92;  ZWKEYWORD(此, Token::THIS)                              #92;  KEYWORD(throw, Token::THROW)                            #92;  ZWKEYWORD(抛, Token::THROW)                            #92;  KEYWORD(true, Token::TRUE_LITERAL)                      #92;  ZWKEYWORD(真, Token::TRUE_LITERAL)                      #92;  KEYWORD(try, Token::TRY)                                #92;  ZWKEYWORD(试, Token::TRY)                                #92;  KEYWORD(typeof, Token::TYPEOF)                          #92;  ZWKEYWORD(之型, Token::TYPEOF)                          #92;  KEYWORD_GROUP('u')                                        #92;  KEYWORD(undefined, Token::UNDEFINED)                    #92;  ZWKEYWORD(未定, Token::UNDEFINED)                    #92;  KEYWORD_GROUP('v')                                        #92;  KEYWORD(var, Token::VAR)                                #92;  ZWKEYWORD(变, Token::VAR)                                #92;  KEYWORD(void, Token::VOID)                              #92;  ZWKEYWORD(空, Token::VOID)                              #92;  KEYWORD_GROUP('w')                                        #92;  KEYWORD(while, Token::WHILE)                            #92;  ZWKEYWORD(当, Token::WHILE)                            #92;  KEYWORD(with, Token::WITH)                              #92;  ZWKEYWORD(为之, Token::WITH)                              #92;  KEYWORD_GROUP('y')                                        #92;  KEYWORD(yield, Token::YIELD)                            #92;  ZWKEYWORD(降, Token::YIELD)                            #92;  KEYWORD_GROUP('_')                                        #92;  KEYWORD(__proto__, Token::PROTO_UNDERSCORED)            #92;  ZWKEYWORD(__原__, Token::PROTO_UNDERSCORED)              #92;  KEYWORD_GROUP('#')                                        #92;  KEYWORD(#constructor, Token::PRIVATE_CONSTRUCTOR)        #92;  ZWKEYWORD(#构造器, Token::PRIVATE_CONSTRUCTOR)      3.仿照KeywordOrIdentifierToken写一个ZWKeywordOrIdentifierTokenstatic Token::Value KeywordOrIdentifierToken(const uint8_t* input,                                             int input_length)   DCHECK_GE(input_length, 1);  const int kMinLength = 2;  const int kMaxLength = 12;  if (input_length lt; kMinLength || input_length gt; kMaxLength)     return Token::IDENTIFIER;    switch (input[0])     default:#define ZWKEYWORD(keyword, token)#define KEYWORD_GROUP_CASE(ch)                                #92;      break;                                                  #92;    case ch:#define KEYWORD(keyword, token)                                           #92;                                                                         #92;    /* 'keyword' is a char array, so sizeof(keyword) is */                #92;    /* strlen(keyword) plus 1 for the NUL char. */                        #92;    const int keyword_length = sizeof(keyword) - 1;                       #92;    STATIC_ASSERT(keyword_length gt;= kMinLength);                          #92;    STATIC_ASSERT(keyword_length lt;= kMaxLength);                          #92;    DCHECK_EQ(input[0], keyword[0]);                                      #92;    DCHECK(token == Token::FUTURE_STRICT_RESERVED_WORD ||                 #92;           0 == strncmp(keyword, Token::String(token), sizeof(keyword))); #92;    if (input_length == keyword_length amp;amp; input[1] == keyword[1] amp;amp;       #92;        (keyword_length lt;= 2 || input[2] == keyword[2]) amp;amp;                #92;        (keyword_length lt;= 3 || input[3] == keyword[3]) amp;amp;                #92;        (keyword_length lt;= 4 || input[4] == keyword[4]) amp;amp;                #92;        (keyword_length lt;= 5 || input[5] == keyword[5]) amp;amp;                #92;        (keyword_length lt;= 6 || input[6] == keyword[6]) amp;amp;                #92;        (keyword_length lt;= 7 || input[7] == keyword[7]) amp;amp;                #92;        (keyword_length lt;= 8 || input[8] == keyword[8]) amp;amp;                #92;        (keyword_length lt;= 9 || input[9] == keyword[9]) amp;amp;                #92;        (keyword_length lt;= 10 || input[10] == keyword[10]))              #92;      return token;                                                       #92;                                                                         #92;        KEYWORDS(KEYWORD_GROUP_CASE, KEYWORD, ZWKEYWORD)    return Token::IDENTIFIER;//#undef KEYWORDS#undef KEYWORD#undef KEYWORD_GROUP_CASE#undef ZWKEYWORD#define IS_WCHAR_EQ_U16() (sizeof(wchar_t) == sizeof(uint16_t))static Token::Value ZWKeywordOrIdentifierToken(const uint16_t* input,                                             int input_length) #define ZWKEYWORD(keyword, token) .Case(L##keyword, token)#define KEYWORD_GROUP_CASE(ch)#define KEYWORD(keyword, token)        std::wstring temp_input;        if (IS_WCHAR_EQ_U16())            temp_input.append((const wchar_t *)input, input_length);        else for (int i = 0; i lt; input_length; ++i)            temp_input.push_back((wchar_t)input[i]);        return StringSwitchlt;Token::Valuegt;(temp_input)        KEYWORDS(KEYWORD_GROUP_CASE, KEYWORD, ZWKEYWORD)            .Default(Token::IDENTIFIER);#undef KEYWORD#undef KEYWORD_GROUP_CASE#undef ZWKEYWORD#undef KEYWORDS  在 ScanIdentifierOrKeywordInner 或 ScanIdentifierOrKeyword 中添加中文关键字返回token的逻辑，node.js的稳点版，改点在ScanIdentifierOrKeyword中：  if (next_.literal_chars-gt;is_one_byte())     Vectorlt;const uint8_tgt; chars = next_.literal_chars-gt;one_byte_literal();    Token::Value token =        KeywordOrIdentifierToken(chars.start(), chars.length());    if (token == Token::IDENTIFIER ||        token == Token::FUTURE_STRICT_RESERVED_WORD ||        Token::IsContextualKeyword(token))      literal.Complete();    return token;    else     Vectorlt;const uint16_tgt; chars = next_.literal_chars-gt;two_byte_literal();    Token::Value token =        ZWKeywordOrIdentifierToken(chars.start(), chars.length());    if (token == Token::IDENTIFIER ||        token == Token::FUTURE_STRICT_RESERVED_WORD ||        Token::IsContextualKeyword(token))      literal.Complete();    return token;  node.js在github上的master，改点在ScanIdentifierOrKeywordInner中：if (next_.literal_chars-gt;is_one_byte())     Vectorlt;const uint8_tgt; chars = next_.literal_chars-gt;one_byte_literal();    Token::Value token =        KeywordOrIdentifierToken(chars.start(), chars.length());    /* TODO(adamk): YIELD should be handled specially. */    if (token == Token::FUTURE_STRICT_RESERVED_WORD)       literal-gt;Complete();      if (escaped) return Token::ESCAPED_STRICT_RESERVED_WORD;      return token;        if (token == Token::IDENTIFIER || Token::IsContextualKeyword(token))       literal-gt;Complete();      return token;        if (!escaped) return token;    literal-gt;Complete();    if (token == Token::LET || token == Token::STATIC)       return Token::ESCAPED_STRICT_RESERVED_WORD;        return Token::ESCAPED_KEYWORD;   else     Vectorlt;const uint8_tgt; chars = next_.literal_chars-gt;two_byte_literal();    Token::Value token =        ZWKeywordOrIdentifierToken(chars.start(), chars.length());    /* TODO(adamk): YIELD should be handled specially. */    if (token == Token::FUTURE_STRICT_RESERVED_WORD)       literal-gt;Complete();      if (escaped) return Token::ESCAPED_STRICT_RESERVED_WORD;      return token;        if (token == Token::IDENTIFIER || Token::IsContextualKeyword(token))       literal-gt;Complete();      return token;        if (!escaped) return token;    literal-gt;Complete();    if (token == Token::LET || token == Token::STATIC)       return Token::ESCAPED_STRICT_RESERVED_WORD;        return Token::ESCAPED_KEYWORD;  二. 修改node.js的 js库，对内置对象和函数添加中文名称修改实例：添加 “控制台.日志” 等效 “console.log”1.添加 “console” 中文名 “控制台”.lib#92;internal#92;bootstrap#92;node.js // github masterlib#92;internal#92;bootstrap_node.js // web download    Object.defineProperty(global, 'console',       configurable: true,      enumerable: true,      get()         return wrappedConsole;            );    // 仿照添加 “控制台” 等效 “console”    Object.defineProperty(global, '控制台',       configurable: true,      enumerable: true,      get()         return wrappedConsole;           );  添加 “log” 函数中文名 “日志”lib#92;console.js:Console.prototype.debug = Console.prototype.log;// 仿照debug和info，添加一条“日志” 等效 “log”Console.prototype.日志 = Console.prototype.log;Console.prototype.info = Console.prototype.log;三 编译./configuremake all四 运行实例：hello.js //放在了 out/Release 中函数 说1(词)     控制台.日志(词);函数 执行(某函数, 值)     某函数(值);变 你 = 你;变 哈哈 =     哈1: '好',     哈2: 12执行(说1, 你);控制台.日志(哈哈);运行:cd out/Release./node hello.js结果:你 '哈1': '好', '哈2': 12 "
    } ,
  
    {
      "title"    : "Java源码英翻中库以及服务原型",
      "category" : "命名, 翻译",
      "description" : "解析Java源码, 并将标识符翻译为中文的库和演示服务. Demonstrate the library to parse Java source code and translate the identifiers to Chinese with a web service.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/09/15/Java%E6%BA%90%E7%A0%81%E8%8B%B1%E7%BF%BB%E4%B8%AD%E5%BA%93%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%8E%9F%E5%9E%8B.html",
      "date"     : "2018-09-15 00:00:00 -0700",
      "content"  : "服务很简单, 只为演示这个库, 源码在: program-in-chinese/code_translator_service. 在Postman测试效果:演示服务地址: 74.91.17.250:8091 . POST请求的参数名是code, 值就是需要翻译的英文源码. 返回翻译后的源码.注:  只支持语法正确的Java源码翻译. 否则直接返回分析错误信息.  现在汉化范围很有限, 主要集中在类型/方法名, 尚未处理其他如方法内容等  代码很粗放, 下面打算在继续改进之前先整理一下.在前文代码翻译尝试-使用Roaster解析和生成Java源码的基础上, 作了一些改进. 主要有:  对一般词汇使用普通英汉词典进行直译(优先选取计算机领域词义或者第一个词义)  支持术语词典, 比如’instance’, 上面的英汉词典中的第一个词义是’建议’, 于是在术语词典中添加此项, 暂时译为’个例’  支持驼峰命名和下划线分隔法命名  各种忽略. 详见命名翻译.java:          一些歧义太多的词, 如to for of      单字符字段如M        对释义进行清理, 如括号中的内容, 特殊符号等等接下去的改进方面:  提高翻译质量方面          继续扩大术语词典内容. 将在术语词典API项目 · Issue #85 · program-in-chinese/overview更新进度      添加一些简单的词序重组规则. 比如现在’afterSave’译为’在之后保存’, 最好改为’保存之后’之类, 但这牵涉到较复杂的自然语言处理.        改进源码分析方面          添加对一些变量, 方法类型进行翻译      支持复杂类型的翻译, 比如Person[], List中的'Person'现在还不能翻译        前端方面          第一步是做一个最简单的前端, 左边输入源码, 右边显示翻译结果      支持Outline模式, 就是类似IDE中只显示类的属性/接口列表, 这样也许更易于对一个类有个一目了然的了解      支持语法高亮      欢迎尝鲜/反馈/参与添加术语等."
    } ,
  
    {
      "title"    : "代码翻译尝试-使用Roaster解析和生成Java源码",
      "category" : "命名, 翻译",
      "description" : "解析Java源码, 并将标识符翻译为中文. Parse Java source code and translate the identifiers to Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/09/13/%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E5%B0%9D%E8%AF%95-%E4%BD%BF%E7%94%A8Roaster%E8%A7%A3%E6%9E%90%E5%92%8C%E7%94%9F%E6%88%90Java%E6%BA%90%E7%A0%81.html",
      "date"     : "2018-09-13 00:00:00 -0700",
      "content"  : "此文是前文使用现有在线翻译服务进行代码翻译的体验的编程语言方面第二点的一个尝试. 参考Which framework to generate source code ? - Cleancode and Refactoring, 选了一个综合代价看来最小的, forge/roaster, 因为它同时具备解析和生成两方面功能.初步汉化后代码效果如下(尚未有语法高亮, 仅作演示用. 之后的在线翻译结果也是同样处理):package com.company.example;import java.io.Serializable;public class 人 implements Serializable     private static final long serialVersionUID = 1L;    private final 整型 号;    private 字符串 全名;    public 整型 get号()         return 号;        public 字符串 get全名()         return 全名;        public void set全名(字符串 全名)         this.全名 = 全名;        public 人(java.lang.Integer id)         this.id = id;    实现的源码在: https://github.com/program-in-chinese/java_code_translator/blob/8c038261bd797d9738de182f3e0f8ac111402704/src/main/java/com/codeinchinese/code_translator/E7BFBBE8AF91JavaE4BBA3E7A081.java相关实现比较简单. 因为侧重代码解析生成, 翻译部分最简化(采用纯映射表):  static Maplt;String, Stringgt; 字典 = new HashMaplt;gt;();  static     字典.put(id, 号);    字典.put(fullName, 全名);    字典.put(getId, 取号);    字典.put(Integer, 整型);    字典.put(String, 字符串);    字典.put(Person, 人);    public static void main(String[] 参数) throws Exception     String 源码 = 文件功用.取源文件文本(测试.java);    JavaClassSource 分析结果 = Roaster.parse(JavaClassSource.class, 源码);    // 汉化类名    分析结果.setName(查词(分析结果.getName()));    // 汉化Bean属性名, 以及属性的类型名    for (PropertySourcelt;JavaClassSourcegt; 某属性 : 分析结果.getProperties())       String 属性名 = 某属性.getName();      某属性.setName(查词(属性名));      String 属性类型名 = 某属性.getType().getName();      某属性.setType(查词(属性类型名));        System.out.println(分析结果);    private static String 查词(String 英文)     return 字典.containsKey(英文) ? 字典.get(英文) : 英文;  Roaster一大缺陷是, 还不支持对方法内容的解析: ROASTER-1: Java Statement Fluent Model by sotty · Pull Request #27 · forge/roaster 貌似主创最近不很活跃, 很可能需要另辟蹊径.顺便把源码用在线翻译服务翻译一下进行比较.谷歌几乎没有翻译:package com.company.example;import java.io.Serializable;public class Person实现Serializable      private static final long serialVersionUID = 1L;     private final Integer id;     private String fullName;     public Integer getId（）         返回id;         public String getFullName（）         return fullName;         public void setFullName（String fullName）         this.fullName = fullName;         public Person（java.lang.Integer id）         this.id = id;    百度改变源码太大:包装公司。导入JavaIO.SerialCalab化；公共类人谓词可序列化私有静态最终的长序列化版本UID＝1L；私有最终整数ID；私有字符串全名；公共整数gTiID（）序列标识；公共字符串GETFuleNAMEL（）返回全名；公共空隙设置FULL NULL（String FulnNeX）全名=全名；公共人（java.郎.整数ID）这个ID＝ID；个人感觉即使是这样初步的翻译, 也是有优势的. 至于编程语言关键词不翻译, 尚不是致命问题, 毕竟下面打算与英汉词典API结合一下试试(这里有一点初步尝试, 对释义的选取还需改进). 如效果还可以接受就上线做一下内测."
    } ,
  
    {
      "title"    : "使用现有在线翻译服务进行代码翻译的体验",
      "category" : "命名, 翻译",
      "description" : "使用谷歌, 百度, 有道等在线翻译服务对代码进行翻译并比较效果. Use online translation service, including Google, baidu, youdao, etc. to translate source code and compare results.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BF%BB%E8%AF%91/2018/09/10/%E4%BD%BF%E7%94%A8%E7%8E%B0%E6%9C%89%E5%9C%A8%E7%BA%BF%E7%BF%BB%E8%AF%91%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E7%9A%84%E4%BD%93%E9%AA%8C.html",
      "date"     : "2018-09-10 00:00:00 -0700",
      "content"  : "前文浏览器插件实现GitHub代码翻译原型演示之后, 意识到现有在线翻译服务已经具备部分设想的功能.第一个测试, 选了一个很小的Python入门例程:class Person:    pass  # An empty blockp = Person()print(p)谷歌翻译:班级人物：     传递＃空块p =人（）打印（P）百度翻译:类人：传递空块P=个人（）打印（P）有道翻译:类人:传递一个空块p =人()打印(p)搜狗翻译:阶级人士:传递#一个空块p =人( )印刷(印刷)可以看出, 谷歌翻译是唯一一个保全原有代码格式的. 而其他的都删除了缩进, 甚至空行和特殊字符(#). 这会很大影响代码可读性, 对Python来说也直接影响语义.第二个测试, 也是很小的Java入门例程:package com.headfirstjava.chapterseven.boats;public class Boat     private int length;    public int getLength()         return length;        public void setLength(int len)         length = len;        public void move()         System.out.print(Drift! );    谷歌:package com.headfirstjava.chapterseven.boats;公共舱船     private int length;     public int getLength（）         返回长度;         public void setLength（int len）         长度= len;         public void move（）         System.out.print（“Drift！”）;    它的翻译较为保守, 没有翻译很多与自然语言相差很大的代码行. 这也导致一处’length’变量名没有翻译.百度:包装件。公务舱船私有int长度；Puint int GETLINTHOST（）返回长度；公共无效设置长度（int LeN）长度＝Le；公共空隙MOVE（）打印输出（“漂移”）；这里有不少将原词改写的情况, 比较不理解. 如getLength变为GETLINTHOST, len变为Le. 另外, 同样是void, 有’无效’和’空隙’两种翻译, 应该是考虑了上下文.有道:包com.headfirstjava.chapterseven.boats;公共级艇私人int长度;public int getLength() 返回长度;public void setLength(int len) 长度=兰;public void move() System.out.print(“漂移!”);它也比较保守, 但同样的len, 一处没有翻译, 一处译为’兰’, 这样也改变了代码语义.搜狗:Java . chaptersen .船；公共船私有整数长度；公共整数getLength ( )返回长度；公共空隙设置长度(内部透镜) (长度=镜头；公共空间移动( )系统输出打印(“漂移！”)；与百度类似, 也有改写词: chapterseven被缩减成chaptersen. 另外int被解释成’内部’, 也许是认为原文是’in’的笔误?——- 2018年十月2日 添加 ——–在Chrome翻译尝试如下, 发现比google在线翻译更进一步. 看起来html元素分割后, 不同语法部分可以更容易识别, 这与前文浏览器插件实现GitHub代码翻译原型演示是异曲同工.package  com.headfirstjava.chapterseven.boats ;公共 舱 船     private  int length;    public  int  getLength（）        返回长度;        public  void  setLength（int  len）        长度= len;        public  void  move（）        系统。出。打印（“漂移！”）;    ——- 2018年十月2日 添加结束 ——–基于上面的测试, 尝试列出一些源码翻译的目标:编程语言方面  具备语法高亮. 虽然所有在线翻译都不具备这一功能, 但对于源码阅读来说是必需的.  代码语义不能改变. 比如某一变量翻译后, 它的所有引用也需翻译. 这和IDE中的’重命名’功能类似, 重构后的代码需要语义相同. 这依赖于语法分析和代码生成, 感觉是这个项目在编程语言方面门槛最高的部分之一. 另外, 代码格式不能改变, 各种缩进, 空行等必须保留  对无法识别语义的部分, 包括所有相关引用, 倾向于保留原文. 不仅节省计算资源, 也是翻错不如不翻的考虑.翻译方面  长句自然语言部分可暂时不翻译. 源码文本中, 最接近自然语言的部分是常量字符串(如上面的”Drift!”), 以及注释行. 对于较长的整句自然语言, 短期很很难做到独立翻译.  支持关键词翻译: 编程语言关键词相对较易翻译, 使用字典一对一翻译.  命名尽量翻译: 需要进行词拆分(如按照驼峰命名法)之后进行类自然语言的翻译, 但多数是词或短语, 如上面的’setLength’. 对它们的翻译难度应该小于整句的自然语言翻译.还有其他吗?"
    } ,
  
    {
      "title"    : "Java实现英汉词典API初版发布在Maven",
      "category" : "命名, API, 英汉词典",
      "description" : "基于ECDICT词典数据, 开发一个Java库实现词典接口, 发布到Maven主库. Publish Java library to provide English-to-Chinese dictionary API on Maven Central.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/api/%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8/2018/09/06/Java%E5%AE%9E%E7%8E%B0%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8API%E5%88%9D%E7%89%88%E5%8F%91%E5%B8%83%E5%9C%A8Maven.html",
      "date"     : "2018-09-06 00:00:00 -0700",
      "content"  : "在打算批量代码汉化工具 · Issue #86 · program-in-chinese/overview时, 发现没有现成的Java库实现英汉查询功能. 于是开此项目.源码库: program-in-chinese/english-chinese-dictionaryAPI使用中文命名. 源码也是.使用时在Maven项目中添加依赖:lt;dependencygt;  lt;groupIdgt;com.codeinchineselt;/groupIdgt;  lt;artifactIdgt;english-chinese-dictionarylt;/artifactIdgt;  lt;versiongt;0.0.1lt;/versiongt;lt;/dependencygt;词典数据来源于skywind3000/ECDICT. 77万个词条, 除不到2千词之外绝大多数有中文释义. 将这个词典数据(csv文件)封装的后果是这个jar包有22MB, 首次调用’查词’接口需要一段时间加载数据(本机测试十秒左右), 之后的查词是哈希表查询, 速度还能接受.下面是返回词条数据结构:public class 词条   public String 英文;  public String 音标;  public Listlt;Stringgt; 英文释义;  public Listlt;Stringgt; 中文释义;  public String 词语位置;  public int 柯林斯星级;  public boolean 为牛津三千核心词;  // zk/中考，gk/高考，cet4/四级等  public String 标签;  // 如果为0, 无词频数据, 否则为正数  public int 英国国家语料库词频顺序;  public int 当代语料库词频顺序;  public Listlt;词形变化gt; 变形;  public String 详细;  public String 在线读音音频;...词形的几种变化:public enum 词形变化类型   过去式(p), // past tense  过去分词(d),  现在分词(i), // -ing  第三人称单数(3),  形容词比较级(r), // -er  形容词最高级(t), // -est  名词复数形式(s),  原型(0),  原型变换形式(1);...接口定义很简单, 调用:英汉词典.查词(apple)返回值打印输出(toString生成类JSON样式, 下同):英文: apple音标: 'æpl英文释义: n. fruit with red or yellow or green skin and sweet to tart crisp whitish fleshn. native Eurasian tree widely cultivated in many varieties for its firm rounded edible fruits中文释义: n. 苹果, 家伙[医] 苹果词语位置: 柯林斯星级: 3为牛津三千核心词: true标签: zk gk英国国家语料库词频顺序: 2446当代语料库词频顺序: 2695变形: 名词复数形式:apples; 详细: 在线读音音频: 可以查出原型:英文: shopping音标: 'ʃɒpiŋ英文释义: n. searching for or buying goods or servicesn. the commodities purchased from stores中文释义: n. 买东西, 购物[经] 购物, 买东西词语位置: 柯林斯星级: 3为牛津三千核心词: true标签: gk cet4 cet6 ielts英国国家语料库词频顺序: 2763当代语料库词频顺序: 2713变形: 原型:shop; 原型变换形式:i; 现在分词:shopping; 详细: 在线读音音频: 也有很多常见短语:英文: beat around the bush音标: 英文释义: 中文释义: 转弯抹角, 旁敲侧击, 拖延谈及正题词语位置: 柯林斯星级: 0为牛津三千核心词: false标签: 英国国家语料库词频顺序: 0当代语料库词频顺序: 0变形: 详细: 在线读音音频: 其中释义部分只根据源数据格式说明中按行分拆, 并未进行进一步提取. 打算以后在实际使用中进行改进. 也许”n. 苹果, 家伙”提取为:词性: 名词释义: [苹果, 家伙]欢迎尝鲜."
    } ,
  
    {
      "title"    : "浏览器插件实现GitHub代码翻译原型演示",
      "category" : "命名",
      "description" : "为Chrome编写一个扩展, 实现GitHub网站查看代码显示对应中文版本. A prototype of an extension for Chrome to showcase translating the code on github website.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2018/08/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0GitHub%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E5%8E%9F%E5%9E%8B%E6%BC%94%E7%A4%BA.html",
      "date"     : "2018-08-29 00:00:00 -0700",
      "content"  : "此原型源自此想法: 中文化源码. 考虑到IDE插件工作量较大, 且与IDE绑定. 在代码转换工具的各种实现中, 综合考虑实用+易用+长远改进潜力, 浏览器插件似乎较有优势. 于是用最快捷的方式实现这一想法.注: 此演示仅用Chrome在一个命名比较简单的代码页https://github.com/swaroopch/byte-of-python/blob/master/programs/ds_using_list.py 运行过, 限于取代码块的简单方式(取页面中的table元素)以及內建词典, 其他浏览器/github代码页的效果不保证.原型项目源码在: program-in-chinese/webextension_github_code_translator在Chrome下加载此插件后, 点击工具栏中的按钮(竟然默认图标是个’G’, 也许是”Github代码翻译原型”的首字母). 弹窗中就会显示翻译后的代码段. 就这样:项目源码节选对代码段的文本进行简单替换:function 翻译()   var 原代码拷贝 = document.getElementsByTagName('table')[0];  var span字段列表 = 原代码拷贝.getElementsByTagName('span');  翻译字段列表(span字段列表);  var 文本字段列表 = 取子文本节点(document);  翻译字段列表(文本字段列表);function 取子文本节点(el)   var n, a = [], walk = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);  while (n = walk.nextNode()) a.push(n);  return a;// 假设每个字段除了词, 其他都是非英文字符.function 取字段中所有词(字段)   var 单词 = 字段.match(/[a-zA-Z]+/g);  if (单词)     return 单词;    return [字段];function 取字段中最长句(字段)   var 句 = 字段.match(/[a-zA-Z#92;s]+/g);  if (句 amp;amp; 句.length gt; 0)     return 句[0].trim();    return 字段;function 翻译字段列表(字段列表)   for (var i = 0; i lt; 字段列表.length; i++)     var 字段 = 字段列表[i].textContent;    var 所有单词 = 取字段中所有词(字段);    var 所有单词有翻译 = false;    for (var j = 0; j lt; 所有单词.length; j++)       var 单词 = 所有单词[j];      var 对应中文词 = 关键词词典[单词] || API词典[单词] || 命名词典[单词];      if (对应中文词)         if (j == 所有单词.length - 1)           所有单词有翻译 = true;               else         break;            字段 = 字段.replace(单词, 对应中文词);        // 取巧: 仅当字段中所有词有翻译时才替换字段, 避免某些文本中出现个别可识别的单词. 今后需进行语法分析.    if (所有单词有翻译)       字段列表[i].textContent = 字段;     else       var 句 = 取字段中最长句(字段);      var 对应中文 = 语句翻译[句.toLowerCase()]      if (对应中文)         字段列表[i].textContent = 字段.replace(句, 对应中文);            內建词典有几部分, 前两个(关键词/API)可扩展, 单词词汇可借助现有的英汉词典(olditem等还需另行拆分处理), 语句翻译可借助在线翻译API(原型中的翻译内容取自有道在线翻译):var 关键词词典 =   'for': '对于',  'in': '在',  'if': '如果',  'del': '删除';var API词典 =   'print': '打印',  'append': '添加',  'sort': '排序',  'len': '长度',  'end': '结尾'var 命名词典 =   'shoplist': '购物单',  'apple': '苹果',  'mango': '芒果',  'carrot': '胡萝卜',  'banana': '香蕉',  'rice': '米',  'item': '物品',  'olditem': '第一项'// 这里使用有道在线翻译结果. TODO: 用翻译API代替var 语句翻译 =   'this is my shopping list': '这是我的购物单',  'i have': '我有',  'items to purchase': '要购买的产品',  'i also have to buy rice': '我还得买大米',  'my shopping list is now': '我的购物单现在在',  'i will sort my list now': '我现在就整理我的清单',  'sorted shopping list is': '排序的购物清单是',  'the first item i will buy is': '我要买的第一件东西是'参考Chrome Extension - Get DOM contenthttps://developer.chrome.com/extensions/tabs#method-executeScriptFind all text nodes in HTML page中文关键词替换体验页面原型为Chrome和火狐浏览器编写扩展"
    } ,
  
    {
      "title"    : "使用JDT核心库解析JDK源码后初步分析API命名",
      "category" : "命名, Java",
      "description" : "使用Eclipse的JDT核心库, 对JDK源码进行语法分析, 提取API包括类/方法/方法参数, 对其命名进行初步分析. Analyze JDK source code using JDT core library, get the naming of the classes and public methods including the arguments, and analyze the vocabulary.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/java/2018/08/27/%E4%BD%BF%E7%94%A8JDT%E6%A0%B8%E5%BF%83%E5%BA%93%E8%A7%A3%E6%9E%90JDK%E6%BA%90%E7%A0%81%E5%90%8E%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90API%E5%91%BD%E5%90%8D.html",
      "date"     : "2018-08-27 00:00:00 -0700",
      "content"  : "源自术语词典API项目 · Issue #85 · program-in-chinese/overview, 打算先用早先的代码提取JDK API中的类/方法/参数名, 看看有哪些词需要翻译.源码在program-in-chinese/programming_term_dictionary类型名提取器.java 扩展了语法树遍历器, 对公开(public)的类型/方法/参数进行保存:public class 类型名提取器 extends ASTVisitor   private 类型名 名 = new 类型名();    private String 当前类名 = ;  Override  public boolean visit(MethodDeclaration 方法节点)     String 当前方法名 = 方法节点.getName().getFullyQualifiedName();    if (为公开声明(方法节点))       名.方法名.put(当前方法名, 当前类名);        for (Object 参数 : 方法节点.parameters())       VariableDeclaration 变量声明 = (VariableDeclaration) 参数;      String 参数名 = 变量声明.getName().getFullyQualifiedName();      // 忽略所有单字母参数名. TODO: 是否需要研究单字母命名?      if (参数名.length() gt; 1)         名.参数名.put(参数名, 当前类名 + . + 当前方法名);              return super.visit(方法节点);    Override  public boolean visit(TypeDeclaration 类型节点)     if (为公开声明(类型节点))       // TODO: 取完整类名(包括包名)      当前类名 = 类型节点.getName().getFullyQualifiedName();      名.类名.put(类型节点.getName().getFullyQualifiedName(), 当前类名);        return super.visit(类型节点);    public 类型名 获取名()     return 名;    private boolean 为公开声明(BodyDeclaration 节点)     return (节点.getModifiers() amp; Modifier.PUBLIC) != 0;    public class 类型名     public Maplt;String, Stringgt; 类名 = new HashMaplt;gt;();    public Maplt;String, Stringgt; 方法名 = new HashMaplt;gt;();    public Maplt;String, Stringgt; 参数名 = new HashMaplt;gt;();  遍历JDK类型名.java 暂时只对util部分进行分析public class 遍历JDK类型名   private static final ASTParser 语法解析器 = ASTParser.newParser(AST.JLS8);  // JDK源码内路径  private static final String 常量_源文件路径 = java/util;  private static final String 常量_输出文件路径 = 命名列表/;  private static final 类型名提取器 提取器 = new 类型名提取器();  /**   *    * param 参数 第一个参数为JDK路径。可由JDK目录下的src.zip解压。   * throws Exception   */  public static void main(String[] 参数) throws Exception     if (参数.length != 1)       System.out.println(需要JDK源码路径作为唯一参数);      return;        文件功用.创建路径(常量_输出文件路径);    处理Java文件(new File(参数[0] + 常量_源文件路径));    类型名 名 = 提取器.获取名();    // 从方法列表中删除所有构造方法    for (String 类名 : 名.类名.keySet())       名.方法名.remove(类名);        String 后缀 = _ + 常量_源文件路径.replaceAll(/, _);    文件功用.写行入文件(名.类名, 常量_输出文件路径 + 类 + 后缀 + .txt);    文件功用.写行入文件(名.方法名, 常量_输出文件路径 + 方法 + 后缀 + .txt);    文件功用.写行入文件(名.参数名, 常量_输出文件路径 + 参数 + 后缀 + .txt);    System.out.println(提取完毕:  + 名.类名.size() + 类; + 名.方法名.size() + 方法; + 名.参数名.size() + 参数);    private static void 处理Java文件(File 路径) throws Exception     if (路径.isFile())       if (路径.getName().endsWith(.java))         解析Java文件(路径);           else       File[] 文件 = 路径.listFiles();      if (文件 != null)         for (File 某文件 : 文件)           处理Java文件(某文件);                      private static void 解析Java文件(File 文件) throws Exception     语法解析器.setSource(文件功用.取源文件文本(文件).toCharArray());    语法解析器.createAST(null).accept(提取器);  初步统计:提取完毕: 332类;1172方法;449参数按照骆驼命名对提取出的命名进行单词拆分后, 得到902个单词, 其中有不少同根词, 如:sequencesequentialsplitsplittabletokentokenizerwordwordswritewriterzonezoned还有不少不明所以的:csnemfd接下去将拆分出的单词与源API联系起来, 以便翻译时结合原API语义(已更新上面的源码). 比如csn来源于java.util.Formatter.Formatter(String fileName, String csn, Locale l), javadoc中意为The name of a supported linkplain java.nio.charset.Charset charset. 真猜不到.顺便对所有java/下的源码进行统计:1579类;5093方法;2022参数2752个单词5倍左右数量的API但单词数只有3倍, 看来复用率蛮高. 总单词表在此."
    } ,
  
    {
      "title"    : "中文代码之Spring Boot对H2数据库简单查询",
      "category" : "命名, Spring, H2",
      "description" : "演示用Spring Boot查询H2内存数据库, 使用中文代码. Demostrate naming in Chinese in query H2 in-memory database in a demo based on Spring Boot.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/spring/h2/2018/08/24/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E4%B9%8BSpring-Boot%E5%AF%B9H2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2.html",
      "date"     : "2018-08-24 00:00:00 -0700",
      "content"  : "续前文: 中文代码之Spring Boot集成H2内存数据库在词条中添加英文术语域:Entitypublic class 词条   Id  private long id;  private String 英文术语;  private String 中文术语;  public 词条()       public 词条(long id, String 英文术语, String 中文术语)     this.id = id;    this.英文术语 = 英文术语;    this.中文术语 = 中文术语;    public long getId()     return id;    public String get中文术语()     return 中文术语;    public String get英文术语()     return 英文术语;  声明查询方法(Spring支持特定命名格式的查询方法, 参考: https://docs.spring.io/spring-data/jpa/docs/1.8.x/reference/html/#repositories.query-methods)Repositorypublic interface 词库接口 extends JpaRepositorylt;词条, Longgt;   Listlt;词条gt; findBy英文术语(String 英文术语);在控制器中用数据库查询代替原本的內建Map查询:RestControllerpublic class 词典控制器   private static final Logger 笔录 = LoggerFactory.getLogger(词典控制器.class);  Autowired  private 词库接口 词库;  GetMapping(/)  ResponseBody  public Listlt;词条gt; 取词条(RequestParam(name = term, required = false, defaultValue = ) String 英文术语)     笔录.info(输入:  + 英文术语);    return 词库.findBy英文术语(英文术语);  访问在线演示地址: http://74.91.17.250:8090/?term=List 返回:[      id: 3,    英文术语: List,    中文术语: 列表  ]继续欠测试."
    } ,
  
    {
      "title"    : "为中文API的简繁转换库添加迟到的持续集成",
      "category" : "命名, API",
      "description" : "为中文Java库项目添加Travis持续集成. Add Travis continuous integration for the Chinese API project.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/api/2018/08/22/%E4%B8%BA%E4%B8%AD%E6%96%87API%E7%9A%84%E7%AE%80%E7%B9%81%E8%BD%AC%E6%8D%A2%E5%BA%93%E6%B7%BB%E5%8A%A0%E8%BF%9F%E5%88%B0%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90.html",
      "date"     : "2018-08-22 00:00:00 -0700",
      "content"  : "前两天在V2EX偶遇反馈帖第一次见以汉字命名的 Java 类 - V2EX, 于是复习了一下半年多没碰的项目program-in-chinese/zhconverter.前文介绍了发布过程: 在Maven Central发布中文API的Java库. 发现没有持续(测试)集成(下图顶上的绿块), 特此加上.之前在另一个项目设置过但未成文: 设置CI - Set up continuous integration to automatically test your code · Issue #10 · program-in-chinese/junit4_in_chinese参考: Getting started - Travis CI. 首先用collaborator之一(权限需为admin)的github账号登录Travis.org之前把.*文件都排除在git版本控制之外了(导致.travis.yml不能提交), 于是用gitignore.io重新生成.gitignore文件(https://www.gitignore.io/api/java,maven,macos,eclipse)由于Ubuntu版本Trusty相比Precise, 支持了jdk9, 于是用它作为运行平台, 并且跳过gpg构建部分(见前文maven库发布, 本地才可发布gpg的公开秘钥)..travis.yml如下:language: javainstall: mvn install -Dmaven.javadoc.skip=true -Dgpg.skip=true -B -Vjdk:  - oraclejdk9  - oraclejdk8dist: trusty最后在项目首页上添加集成状态图标. 参考: Embedding Status Images. 如果构建与测试通过, 状态会显示绿色”通过”."
    } ,
  
    {
      "title"    : "中文关键词替换体验页面原型",
      "category" : "语言设计, 汉化关键词",
      "description" : "实现一个原型, 通过对实用例程的关键词替换, 体验各种中文关键词的可读性. Create a prototype, by replacing keywords in real-world sample programs, to feel the readability of Chinese keywords.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E6%B1%89%E5%8C%96%E5%85%B3%E9%94%AE%E8%AF%8D/2018/08/21/%E4%B8%AD%E6%96%87%E5%85%B3%E9%94%AE%E8%AF%8D%E6%9B%BF%E6%8D%A2%E4%BD%93%E9%AA%8C%E9%A1%B5%E9%9D%A2%E5%8E%9F%E5%9E%8B.html",
      "date"     : "2018-08-21 00:00:00 -0700",
      "content"  : "源自: 中文化 类C编程语言 需要什么样的关键字? · Issue #40 · program-in-chinese/overview. 原型为纯前端, 本地浏览器运行效果如下:关键词选取的讨论已经不少, 往往都有各人偏好的风格. 这个原型旨在通过实验各种用词在实际代码中的效果, 使讨论更接近实用. 也许在完善后也可用来演示其他风格的中文编程语言设计.源码库在: program-in-chinese/demo_keyword_design_by_code代码选自program-in-chinese/team_website (中文代码示例之冒泡算法, 后感), 代码块的HTML代码是直接截取了jekyll转换后的HTML源码, 高亮也是利用了jekyll的自带css.原型中其他的源码如下主界面.html主要内容是三块  原始代码 - 使用英文关键词的代码  替换关键词后的代码 - 根据关键词词典, 对所有相关关键词进行替换后生成的代码  关键词修改表 - 显示所有关键词的对应中文, 进行修改后可以即时看到代码替换后的效果lt;htmlgt;  lt;headgt;    lt;link rel=stylesheet href=main.cssgt;  lt;/headgt;  lt;bodygt;lt;spangt;原代码lt;/spangt;lt;div id = 原代码gt;lt;div class=language-python highlighter-rougegt;lt;div class=highlightgt;lt;pre class=highlightgt;lt;codegt;lt;span class=kgt;forlt;/spangt; lt;span class=errgt;前lt;/spangt; lt;span class=owgt;inlt;/spangt; lt;span class=nbgt;xrangelt;/spangt;lt;span class=pgt;(lt;/spangt;lt;span class=nbgt;lenlt;/spangt;lt;span class=pgt;(lt;/spangt;lt;span class=ngt;alt;/spangt;lt;span class=pgt;)):lt;/spangt;  lt;span class=kgt;forlt;/spangt; lt;span class=errgt;后lt;/spangt; lt;span class=owgt;inlt;/spangt; lt;span class=nbgt;xrangelt;/spangt;lt;span class=pgt;(lt;/spangt;lt;span class=errgt;前lt;/spangt; lt;span class=ogt;+lt;/spangt; lt;span class=migt;1lt;/spangt;lt;span class=pgt;,lt;/spangt; lt;span class=nbgt;lenlt;/spangt;lt;span class=pgt;(lt;/spangt;lt;span class=ngt;alt;/spangt;lt;span class=pgt;)):lt;/spangt;      lt;span class=kgt;iflt;/spangt; lt;span class=ngt;alt;/spangt;lt;span class=pgt;[lt;/spangt;lt;span class=errgt;前lt;/spangt;lt;span class=pgt;]lt;/spangt; lt;span class=ogt;amp;gt;lt;/spangt; lt;span class=ngt;alt;/spangt;lt;span class=pgt;[lt;/spangt;lt;span class=errgt;后lt;/spangt;lt;span class=pgt;]:lt;/spangt;          lt;span class=ngt;alt;/spangt;lt;span class=pgt;[lt;/spangt;lt;span class=errgt;前lt;/spangt;lt;span class=pgt;],lt;/spangt; lt;span class=ngt;alt;/spangt;lt;span class=pgt;[lt;/spangt;lt;span class=errgt;后lt;/spangt;lt;span class=pgt;]lt;/spangt; lt;span class=ogt;=lt;/spangt; lt;span class=ngt;alt;/spangt;lt;span class=pgt;[lt;/spangt;lt;span class=errgt;后lt;/spangt;lt;span class=pgt;],lt;/spangt; lt;span class=ngt;alt;/spangt;lt;span class=pgt;[lt;/spangt;lt;span class=errgt;前lt;/spangt;lt;span class=pgt;]lt;/spangt;lt;/codegt;lt;/pregt;lt;/divgt;lt;/divgt;lt;/divgt;lt;spangt;替换后代码lt;/spangt;lt;div id = 替换后代码gt;lt;/divgt;lt;div id = 替换表gt;lt;/divgt;lt;script src=词替换.jsgt;lt;/scriptgt;lt;/bodygt;lt;/htmlgt;词替换.js初始时有默认的关键词词典(为演示之用只加了三个, 欢迎提交添加/修改, 最好实现多套关键词可选). 页面加载时, 按照这个默认词典对”原代码”中的代码进行关键词替换, 并按每个关键词一行动态生成”替换表”可供用户手动修改.var 关键词词典 =   'for': '对于',  'in': '在',  'if': '如果';function 替换所有关键词()   var 原代码拷贝 = document.getElementById(原代码).children[0].cloneNode(true);  var 字段列表 = 原代码拷贝.getElementsByTagName('span');  for (var i = 0; i lt; 字段列表.length; i++)     var 字段内容 = 字段列表[i].textContent;    var 对应中文词 = 关键词词典[字段内容];    if (对应中文词)       字段列表[i].textContent = 对应中文词;        var 替换代码块 = document.getElementById(替换后代码);  if (替换代码块.children.length == 1)     替换代码块.removeChild(替换代码块.children[0]);    替换代码块.appendChild(原代码拷贝);// lt;divgt;lt;spangt;forlt;/spangt;lt;input type=text name=for替换 value=对于gt;lt;/divgt;function 创建替换词条(原词文本, 替换文本)   var 词条 = document.createElement(div);  var 原词 = document.createElement('span');  原词.textContent = 原词文本;  var 替换 = document.createElement('input');  var 替换输入框名 = 原词文本 + '替换';  替换.type = 'text';  替换.name = 替换输入框名;  替换.value = 替换文本;  词条.appendChild(原词);  词条.appendChild(替换);  return 词条;function 取输入监听函数(关键词)   return function()     关键词词典[关键词] = document.getElementsByName(关键词 + '替换')[0].value;    替换所有关键词();  ;替换所有关键词();var 替换表 = document.getElementById(替换表);for(var 关键词 in 关键词词典)   替换表.appendChild(创建替换词条(关键词, 关键词词典[关键词]));  var 替换输入框名 = 关键词 + '替换';  document.getElementsByName(替换输入框名)[0].addEventListener('input', 取输入监听函数(关键词));欢迎添加新例程, 尤其是较短自成一体的中文命名的例程."
    } ,
  
    {
      "title"    : "中文代码之Spring Boot集成H2内存数据库",
      "category" : "命名, Spring, H2",
      "description" : "演示用Spring Boot集成H2内存数据库, 使用中文代码. Demostrate naming in Chinese in integrating H2 in-memory database to a demo based on Spring Boot.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/spring/h2/2018/08/20/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E4%B9%8BSpring-Boot%E9%9B%86%E6%88%90H2%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93.html",
      "date"     : "2018-08-20 00:00:00 -0700",
      "content"  : "续前文: 中文代码之Spring Boot添加基本日志, 源码库地址相同.鉴于此项目中的数据总量不大(即使万条词条也在1MB之内), 当前选择轻量级而且配置简单易于部署的H2内存数据库比较合理. 此文仅演示实现H2的集成, 还未修改服务本身功能.相关commit在: 集成H2数据库 · program-in-chinese/programming_term_dictionarydc29be7应用.javapublic class 应用 implements CommandLineRunner   private static final Logger 笔录 = LoggerFactory.getLogger(应用.class);  private final 词库接口 词库;  Autowired  public 应用(词库接口 词库)     this.词库 = 词库;  ...  Override  public void run(String ...参数) throws Exception     词条 词条1 = new 词条(1L, 集合);    词条 词条2 = new 词条(2L, 字典);        笔录.info(添加H2数据);    词库.save(词条1);    词库.save(词条2);    笔录.info(数据条数: , 词库.count());  词条.java:Entitypublic class 词条   Id  private long id;  private String 中文术语;  public 词条()     ...词库接口.javaRepositorypublic interface 词库接口 extends JpaRepositorylt;词条, Longgt; application.yml# 打开H2控制台spring:  h2:    console:      enabled: true  datasource:    url: jdbc:h2:mem:testdb;MODE=Oracle;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSEpom.xml添加依赖:        lt;dependencygt;            lt;groupIdgt;org.springframework.bootlt;/groupIdgt;            lt;artifactIdgt;spring-boot-starter-data-jpalt;/artifactIdgt;        lt;/dependencygt;        lt;dependencygt;            lt;groupIdgt;com.h2databaselt;/groupIdgt;            lt;artifactIdgt;h2lt;/artifactIdgt;                lt;scopegt;runtimelt;/scopegt;        lt;/dependencygt;启动服务后, 访问http://localhost:8080/h2-console并在JDBC URL中输入application.yml中配置的数据库路径(datasource:url):可以看到启动时添加的两个词条数据已在数据库中:下面需要修改数据库设计, 使其包括”英文”和”中文”两个列, 并实现H2数据库查询, 代替现在代码中的Map结构. 另外, 欠了的测试要还.参考:Using H2 In-memory Database with Spring BootSetting up H2 with Spring Boot"
    } ,
  
    {
      "title"    : "改造JAVA，给OpenJDK10添加中文关键词",
      "category" : "语言设计, 汉化关键词",
      "description" : "修改Java编译器源码, 实现关键词的中文化. Modify source code of OpenJDK 10 to support keywords in Chinese.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E6%B1%89%E5%8C%96%E5%85%B3%E9%94%AE%E8%AF%8D/2018/08/19/%E6%94%B9%E9%80%A0JAVA-%E7%BB%99OpenJDK10%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E5%85%B3%E9%94%AE%E8%AF%8D.html",
      "date"     : "2018-08-19 00:00:00 -0700",
      "content"  : "OpenJDK10的编译参照 ： 在WSL上编译OpenJDK10魔改JAVA，添加中文关键词，改的不多，仅仅改了javac的源代码，分别属于java.compiler、jdk.compiler 两个模块中文关键词，我用了自己的风格，不喜欢的话，可以自行修改。jdk10#92;langtools#92;src#92;java.compiler#92;share#92;classes#92;javax#92;lang#92;model#92;SourceVersion.java改最后一个函数，添加一些中文关键字的判断：public static boolean isKeyword(CharSequence s, SourceVersion version)         String id = s.toString();        switch(id)             // A trip through history        case strictfp:        case 严:            return version.compareTo(RELEASE_2) gt;= 0;        case assert:        case 断:            return version.compareTo(RELEASE_4) gt;= 0;        case enum:        case 举:            return version.compareTo(RELEASE_5) gt;= 0;        case _:            return version.compareTo(RELEASE_9) gt;= 0;            // Keywords common across versions            // Modifiers        case public:    case protected: case private:        case abstract:  case static:    case final:        case transient: case volatile:  case synchronized:        case native:        case 公:    case 保: case 私:        case 象:  case 固:    case 终:        case 暂: case 易:  case 同:        case 原:            // Declarations        case class:     case interface: case extends:        case package:   case throws:    case implements:        case 类:     case 接: case 承:        case 包:   case 弃:    case 成:            // Primitive types and void        case boolean:   case byte:      case char:        case short:     case int:       case long:        case float:     case double:        case void:        case 不二:   case 字:      case 符:        case 短:     case 整:       case 长:        case 浮:     case 双:        case 空:            // Control flow        case if:      case else:        case try:     case catch:    case finally:        case do:      case while:        case for:     case continue:        case switch:  case case:     case default:        case break:   case throw:    case return:        case 如:      case 另:        case 试:     case 捕:    case 末:        case 运:      case 当:        case 为:     case 继:        case 分:  case 例:     case 默:        case 破:   case 抛:    case 返:            // Other keywords        case  this:   case new:      case super:        case import:  case instanceof:        case  此:   case 新:      case 超:        case 进:  case 是:            // Forbidden!        case goto:        case const:        case 去:        case 常:            // literals        case null:         case true:       case false:        case 无:         case 真:       case 假:            return true;        default:            return false;        jdk10#92;langtools#92;src#92;jdk.compiler#92;share#92;classes#92;com#92;sun#92;tools#92;javac#92;parser#92;Tokens.java修改 Tokens 这个类public class Tokens    ...    /** The names of all tokens.     */    //private Name[] tokenName = new Name[TokenKind.values().length];    private Name[] tokenName = new Name[2 * TokenKind.values().length];    // 添加了中文关键字，长度*2   .../* 原代码   protected Tokens(Context context)         context.put(tokensKey, this);        names = Names.instance(context);        for (TokenKind t : TokenKind.values())             if (t.name != null)                enterKeyword(t.name, t);            else                tokenName[t.ordinal()] = null;                key = new TokenKind[maxKey+1];        for (int i = 0; i lt;= maxKey; i++) key[i] = TokenKind.IDENTIFIER;        for (TokenKind t : TokenKind.values())             if (t.name != null)            key[tokenName[t.ordinal()].getIndex()] = t;                private void enterKeyword(String s, TokenKind token)         Name n = names.fromString(s);        tokenName[token.ordinal()] = n;        if (n.getIndex() gt; maxKey) maxKey = n.getIndex();    */    protected Tokens(Context context)         context.put(tokensKey, this);        names = Names.instance(context);        for (TokenKind t : TokenKind.values())             if (t.name != null)                 Name n = names.fromString(t.name);                tokenName[2 * t.ordinal()] = n;                if (n.getIndex() gt; maxKey) maxKey = n.getIndex();                if (t.name_cn != null)                     Name n_cn = names.fromString(t.name_cn);                    tokenName[2 * t.ordinal() + 1] = n_cn;                    if (n_cn.getIndex() gt; maxKey) maxKey = n_cn.getIndex();                                else                     tokenName[2 * t.ordinal() + 1] = null;                                            //enterKeyword(t.name, t);                //直接不用了，重新写了            else                 tokenName[2 * t.ordinal()] = null;                tokenName[2 * t.ordinal() + 1] = null;                            key = new TokenKind[maxKey+1];        for (int i = 0; i lt;= maxKey; i++) key[i] = TokenKind.IDENTIFIER;        for (TokenKind t : TokenKind.values())             if (t.name != null)                 key[tokenName[2 * t.ordinal()].getIndex()] = t;                if (t.name_cn != null)                     key[tokenName[2 * t.ordinal() + 1].getIndex()] = t;                                           ...    /**     * This enum defines all tokens used by the javac scanner. A token is     * optionally associated with a name.     */    //添加中文关键词表，在英文单词，后面加一个中文词    // e.g. ABSTRACT(abstract),  --gt;  ABSTRACT(abstract, 象),    //      ASSERT(assert, Tag.NAMED), --gt;  ASSERT(assert, 断, Tag.NAMED),    // 具体实现可看结尾的构造函数，比较简单    public enum TokenKind implements Formattable, Filterlt;TokenKindgt;         EOF(),        ERROR(),        IDENTIFIER(Tag.NAMED),        ABSTRACT(abstract, 象),        ASSERT(assert, 断, Tag.NAMED),        BOOLEAN(boolean, 不二, Tag.NAMED),        BREAK(break, 破),        BYTE(byte, 字, Tag.NAMED),        CASE(case, 例),        CATCH(catch, 捕),        CHAR(char, 符, Tag.NAMED),        CLASS(class, 类),        CONST(const, 常),        CONTINUE(continue, 继),        DEFAULT(default, 默),        DO(do, 运),        DOUBLE(double, 双, Tag.NAMED),        ELSE(else, 另),        ENUM(enum, 举, Tag.NAMED),        EXTENDS(extends, 承),        FINAL(final, 终),        FINALLY(finally, 末),        FLOAT(float, 浮, Tag.NAMED),        FOR(for, 为),        GOTO(goto, 去),        IF(if, 如),        IMPLEMENTS(implements, 成),        IMPORT(import, 进),        INSTANCEOF(instanceof, 是),        INT(int, 整, Tag.NAMED),        INTERFACE(interface, 接),        LONG(long, 长, Tag.NAMED),        NATIVE(native, 原),        NEW(new, 新),        PACKAGE(package, 包),        PRIVATE(private, 私),        PROTECTED(protected, 保),        PUBLIC(public, 公),        RETURN(return, 返),        SHORT(short, 短, Tag.NAMED),        STATIC(static, 固),        STRICTFP(strictfp, 严),        SUPER(super, 超, Tag.NAMED),        SWITCH(switch, 分),        SYNCHRONIZED(synchronized, 同),        THIS(this, 此, Tag.NAMED),        THROW(throw, 抛),        THROWS(throws, 弃),        TRANSIENT(transient, 暂),        TRY(try, 试),        VOID(void, 空, Tag.NAMED),        VOLATILE(volatile, 易),        WHILE(while, 当),        INTLITERAL(Tag.NUMERIC),        LONGLITERAL(Tag.NUMERIC),        FLOATLITERAL(Tag.NUMERIC),        DOUBLELITERAL(Tag.NUMERIC),        CHARLITERAL(Tag.NUMERIC),        STRINGLITERAL(Tag.STRING),        TRUE(true, 真, Tag.NAMED),        FALSE(false, 假, Tag.NAMED),        NULL(null, 无, Tag.NAMED),        UNDERSCORE(_, Tag.NAMED),        ARROW(-gt;),        COLCOL(::),        LPAREN((),        RPAREN()),        LBRACE(),        RBRACE(),        LBRACKET([),        RBRACKET(]),        SEMI(;),        COMMA(,),        DOT(.),        ELLIPSIS(...),        EQ(=),        GT(gt;),        LT(lt;),        BANG(!),        TILDE(~),        QUES(?),        COLON(:),        EQEQ(==),        LTEQ(lt;=),        GTEQ(gt;=),        BANGEQ(!=),        AMPAMP(amp;amp;),        BARBAR(||),        PLUSPLUS(++),        SUBSUB(--),        PLUS(+),        SUB(-),        STAR(*),        SLASH(/),        AMP(amp;),        BAR(|),        CARET(^),        PERCENT(),        LTLT(lt;lt;),        GTGT(gt;gt;),        GTGTGT(gt;gt;gt;),        PLUSEQ(+=),        SUBEQ(-=),        STAREQ(*=),        SLASHEQ(/=),        AMPEQ(amp;=),        BAREQ(|=),        CARETEQ(^=),        PERCENTEQ(=),        LTLTEQ(lt;lt;=),        GTGTEQ(gt;gt;=),        GTGTGTEQ(gt;gt;gt;=),        MONKEYS_AT(),        CUSTOM;        public final String name;        public final String name_cn; //添加的中文关键词的String        public final Tag tag;          //因为添加了一个中文关键字的String，初始化得简单修改         TokenKind()             //this(null, Tag.DEFAULT); //原代码            this(null, null, Tag.DEFAULT); //新代码                TokenKind(String name)             //this(name, Tag.DEFAULT); //原代码            this(name, null, Tag.DEFAULT); //新代码                TokenKind(Tag tag)             //this(null, tag); //原代码            this(null, null, tag); //新代码                // 原有的构造函数，改为调用新的构造函数        TokenKind(String name, Tag tag)             //this.name = name;            //this.tag = tag;            this(name, null, tag);                // 添加新的构造形式        TokenKind(String name, String name_cn)             //this.name = name;            //this.tag = tag;            this(name, name_cn, Tag.DEFAULT);                // 新添加的构造函数        TokenKind(String name, String name_cn, Tag tag)             this.name = name;            this.name_cn = name_cn;            this.tag = tag;        以上两个源文件改好之后，保存为UTF-8格式。主要是我比较喜欢UTF-8格式，如果你想用GBK等其他格式，后面的参数，和中文源代码，都配套用相同格式就行。加好代码后，编译参数也需要改一下，因为源代码里加了utf-8字符给 java.compiler、jdk.compiler 加上-encoding UTF-8 的选项。jdk10/make/CompileJavaModules.gmkline 88：java.compiler_ADD_JAVAC_FLAGS += -encoding UTF-8 -Xdoclint:all/protected '-Xdoclint/package:java.*,javax.*'line 354：jdk.compiler_ADD_JAVAC_FLAGS += -encoding UTF-8 -Xdoclint:all/protected '-Xdoclint/package:-com.sun.tools.*,-jdk.internal.*' #92;    -XDstringConcat=inline编译完成之后，下面这段代码，可以顺利编译，打印。OpenJDK10估计默认源代码为UTF-8，所以编译不需要加 -encoding UTF-8 参数。包 hello;公 类 Hello     公 固 空 main(String[] args)         System.out.println(你好 SwizL!);    OpenJDK10估计默认源代码为UTF-8，所以编译不需要加 -encoding UTF-8 参数。参考:  狗屎咖啡：如何使GCC支持中文(utf-8)的变量名、函数名？​  狗屎咖啡：为GCC添加中文关键字​  狗屎咖啡：为Python添加中文关键字​  狗屎咖啡：为clang添加中文关键字​"
    } ,
  
    {
      "title"    : "[转载]手机编程与AIDE",
      "category" : "命名, 移动开发",
      "description" : "AIDE在Android手机环境中开发的诀窍, 各种问题与解决. Tips and tricks for developing in AIDE on Android phone.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/2018/08/18/%E8%BD%AC%E8%BD%BD_%E6%89%8B%E6%9C%BA%E7%BC%96%E7%A8%8B%E4%B8%8EAIDE.html",
      "date"     : "2018-08-18 00:00:00 -0700",
      "content"  : "转载者注: 原文对AIDE开发作了详细介绍, 并提及它对非英文/ASCII码的支持问题. 相信对前文手机编程环境初尝试-用AIDE开发Android应用有兴趣的会是好参考资料. 另外, “jar内非英文字符类/方法都无法使用”指的是中文命名的类/方法生成的jar包无法在AIDE中被引用, 并非AIDE中开发本身不能使用中文命名.原文: 手机编程与aide - MikaGuraNTK注 : 文中提到的AIDE均为 3.2.180419汉化版 不讨论其他版本点此下载本文可能需要java基础 一般通过退散aide提供了一个类似android studio的开发环境 支持eclipse/gradle的项目格式但是只是兼容 并不是真正的gradle  不支持除compile以外的引用  不支持java7以外的语言  不支持直接引用aar  jar内非英文字符类/方法都无法使用  apk内包含非英文文件都会签名失败  不支持注解工厂不支持  gradle plugin一些奇怪的bug快速开始 :1.进入AIDE 打开文件目录2.选择新建项目 -gt; 新建AndroidApp3.输入包名与应用名 创建应用4.点击右上角播放按钮编译默认实例包含一个Activity,一个布局xml与一些无用文件.一些坑 :代码没有保存不知道为啥有时候不会自动保存，这就要改一个设置，在 设置/编辑器/自动保存 改成15秒，这样离开软件会自动保存(不是指15秒)，否则离开软件可能不会自动保存。也就是说，不管什么15秒，开启了这个设置，只要不是闪退，应用一到后台就会把当前未保存的代码全部保存。m2rep是什么？怎么用？这是google提供的android suppert工具包的集合，(包含在 android sdk)通常到http://dl.google.com(注意国内可以访问)下载，旧版的aide和idea android studio等使用android support库都需要配置(但是新版aide不用，看下面)我们通常到东软的开源镜像站下载，比较快，贴一下地址 :http://mirrors.neusoft.edu.cn/android/repository/android_m2repository_r47.zip这是一个zip文件，300多m，解压后在aide配置 设置/构建 运行/Maven仓库目录配置本文开头提供的aide可以直接下载android support的单个依赖库了，不需要m2rep了aide的dexer优化和proguraddexer优化没什么明显作用，但是他说能优化速度，那就开。progurad呢，这个不是aide自带的功能,是贴吧大神添加的功能,需要在设置开启而且必须项目下必须配置proguard-rules.pro以下是必须写的内容，否则报错-dontnote **-dontwarn **-keepclasseswithmembernames class * native lt;methodsgt;;-keepclassmembers enum * public static **[] values();public static ** valueOf(java.lang.String);-keep class * implements android.os.Parcelable public static final android.os.ParcelableCreator *;-keepclassmembers class * implements java.io.Serializable static final long serialVersionUID;private static final java.io.ObjectStreamField[] serialPersistentFields;private void writeObject(java.io.ObjectOutputStream);private void readObject(java.io.ObjectInputStream);java.lang.Object writeReplace();java.lang.Object readResolve();-keepnames class * implements android.os.Parcelable public static final ** CREATOR;关于aide的分支release和debug和aide-debug的区别。release发布版 aide里收不到日志，最稳定。debug版 aide可以收到应用的日志，但是有时候安装完了aide还开着的话应用更新后第一次启动会闪退，当时我以为自己软件有问题还找了好久的bug，结果是aide的问题。aide-debug是aide用来打断点的版本，关于断点请自行百度。打断点之后应用会很大，而且有时候运行会闪退。aide断点版本的应用启动时会请求aide，看起来像白屏一样，如果很久没反应请手动打开aide。有时候改了代码编译了还是原来那样/删除了build文件夹 aide重新编译不编译类了。是aide抽风了。选择 更多/项目/构建刷新 重新编译你的项目即可。aide编译项目速度和你手机配置相关。编译之后没有跳出安装怎么回事抽风了 自己打开安装包安装android support aide编译不通过可能是版本太高了，aide不支持，我推荐把版本换成23.0.1就行了。aide 子项目引用同目录下依赖项目 :compile project (“:文件夹名”)同样可以引用父目录下的:compile project (“:../文件夹名”)但是只能在aide这么用,真正的gradle是不能这么用的assets不支持非ascii字符这是一些apk签名工具的bug，而并不是assets里的文件不能用中文和其他字符。aide就有这个bug，但android studio 、 idea等电脑ide都没有这个bugapk编译后保存在哪sdcard/Android/data/com.aide.ui/files/cache/apk"
    } ,
  
    {
      "title"    : "中文代码之Spring Boot添加基本日志",
      "category" : "命名, Spring",
      "description" : "演示用Spring Boot实现基本日志, 使用中文代码. Demostrate naming in Chinese in adding log to a demo based on Spring Boot.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/spring/2018/08/16/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E4%B9%8BSpring-Boot%E6%B7%BB%E5%8A%A0%E5%9F%BA%E6%9C%AC%E6%97%A5%E5%BF%97.html",
      "date"     : "2018-08-16 00:00:00 -0700",
      "content"  : "之前中文代码之Spring Boot实现简单REST服务的演示服务不知为何中止. 新开issue: 演示服务中止 · Issue #2 · program-in-chinese/programming_term_dictionary.毫无线索的情况下, 先添加日志: program-in-chinese/programming_term_dictionaryapplication.yml:logging:  file: 日志.log词典控制器.java:RestControllerpublic class 词典控制器   private static final Logger 笔录 = LoggerFactory.getLogger(词典控制器.class);...  GetMapping(/)  ResponseBody  public 词条 取词条(RequestParam(name = term, required = false, defaultValue = ) String 英文术语)     笔录.info(输入:  + 英文术语);...对服务中止问题, 如有思路/线索请多指教.演示机器环境和配置:Java 8,Ubuntu 14.04,FX-4100 Quad-Core, 16GB内存, 2T硬盘补记: 多半是由于远程登录服务器退出时, 服务自动结束. 添加nohup后再看. 参考: Run java jar file on a server as background process参考:74. Properties and ConfigurationSpring Boot Logging Example"
    } ,
  
    {
      "title"    : "中文代码之Spring Boot实现简单REST服务",
      "category" : "命名, Spring",
      "description" : "演示用Spring Boot实现简单REST服务, 使用中文代码. Demostrate naming in Chinese in a demo of building RESTful service based on Spring Boot.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/spring/2018/08/14/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E4%B9%8BSpring-Boot%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95REST%E6%9C%8D%E5%8A%A1.html",
      "date"     : "2018-08-14 00:00:00 -0700",
      "content"  : "最终目标详见: 参考MSDN，试搞.NET类库标识符的翻译版 · Issue #54 · program-in-chinese/overview此文仅为技术探索+原型搭建的第一小步.源码库: 演示原型 · program-in-chinese/programming_term_dictionary6bb00f3主要部分源码如下:应用.javaSpringBootApplicationpublic class 应用   public static void main(String[] 参数)     SpringApplication.run(应用.class, 参数);  词典控制器.javaRestControllerpublic class 词典控制器   private static final HashMaplt;String, Stringgt; 英中词典 = new HashMaplt;gt;();  static     英中词典.put(List, 列表);    private final AtomicLong 计数器 = new AtomicLong();  GetMapping(/)  ResponseBody  public 词条 取词条(RequestParam(name = term, required = false, defaultValue = ) String 英文术语)     if (英中词典.containsKey(英文术语))       return new 词条(计数器.incrementAndGet(), 英中词典.get(英文术语));        return null;  词条.javapublic class 词条   // TODO: 仅为演示用  private final long id;  private final String 中文术语;  public 词条(long id, String 中文术语)     this.id = id;    this.中文术语 = 中文术语;    public long getId()     return id;    public String get中文术语()     return 中文术语;  在演示服务器上构建并从jar包启动服务: mvn package amp;amp; java -jar target/programming-term-dictionary-0.1.0.jar --server.port=8090在本地(客户端)访问, 或直接在浏览器访问http://74.91.17.250:8090/?term=List: curl 74.91.17.250:8090?term=Listid:3,中文术语:列表参考文档: Building a RESTful Web Service with Spring Boot Actuator"
    } ,
  
    {
      "title"    : "Head First OO分析设计一书略读与例子中文化",
      "category" : "命名, UML",
      "description" : "学习Head First Object-Oriented Analysis and Design一书的组织布局, 以及中文化其中一例. Notes after browsing through the book Head First Object-Oriented Analysis and Design, with one sample program in Chinese naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/uml/2018/08/13/Head-First-OO%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B9%A6%E7%95%A5%E8%AF%BB%E4%B8%8E%E4%BE%8B%E5%AD%90%E4%B8%AD%E6%96%87%E5%8C%96.html",
      "date"     : "2018-08-13 15:00:00 -0700",
      "content"  : "注: 此笔记仅为个人学习此教程的布局和材料组织之用. 如有兴趣请自行详阅.第一章是以吉他商店的存货系统作例子.第二章设计有狗洞的门.第三章对第二章基础上, 更改需求后对应设计.第四章继续改进此门, 添加对自家狗的识别等.第五章, 对第一章吉他商店的例子进行扩展, 看到抽象类等等.第六章一个游戏项目的需求分析第七章对游戏项目进行顶层和细化设计第八章对之前的几个项目应用常用OO模式第九章继续游戏项目第十章作为最终项目, 基于地铁系统开发地图/路径搜索应用. 迭代开发如下:一次迭代用例:管理员 - 载入地铁线路; 旅游代理 - 获取路线类设计如下(基于书中UML图简化)地铁载入器类.从文件载入(文件类) 返回 地铁类地铁类.添加站点(字符串类)地铁类.存在站点(字符串类) 返回 布尔值地铁类.添加区间(字符串类, 字符串类, 字符串类)站点类.名称 为 字符串类站点类.取名称() 返回 字符串类站点类.等于(个例) 返回 布尔值站点类.哈希码() 返回 整型区间类.段名称 为 字符串类区间类.取站点1() 返回 站点类区间类.取站点2() 返回 站点类区间类.取段名称() 返回 字符串类之后的源码部分只是对设计的简单实现, 略去.二次迭代添加路径搜索功能和路径打印器.读后小结与现实项目类似的迭代开发和根据需求增加扩展设计的教授方式很有参考价值. 更理想的是整本书都采用同一个项目, 但对素材和章节组织会有更大挑战."
    } ,
  
    {
      "title"    : "中文编程讨论组(GitHub)社区守则一周年修订",
      "category" : "小结, 守则",
      "description" : "中文编程讨论组对社区守则的细化和修订. Revised code of conduct for the Programming in Chinese discussion group after one year.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/%E5%AE%88%E5%88%99/2018/08/13/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%AE%A8%E8%AE%BA%E7%BB%84(GitHub)%E7%A4%BE%E5%8C%BA%E5%AE%88%E5%88%99%E4%B8%80%E5%91%A8%E5%B9%B4%E4%BF%AE%E8%AE%A2.html",
      "date"     : "2018-08-13 00:00:00 -0700",
      "content"  : "原址在此社区守则大原则  求同存异  就事论事  己所不欲勿施于人注: 在讨论组成立一周年之际, 对行为规范进行一些细化内这部分所有内容同样适用于对外回归技术所有与中文编程没有直接关系的话题都不应成为隔阂, 尤其非技术话题.谨言慎行对不同技术, 包括中文编程本身, 尽量客观探讨. 避免参与鄙视链.命名与语法并重中文命名(包括创造中文API等)与中文语法(包括设计新编程语言和汉化现有语言)相辅相成, 并从不同角度促进中文编程的推广. 可有专攻, 不可相轻.参考: 中文编程专栏目录, 初衷和希冀外这部分侧重一些对外交流的注意事项应对有理有力有节. 中文编程的反对声音中, 有不明事实的, 有被过往的一些讨论中非理性声音影响的, 也有一些搅浑水的. 对于不明事实者, 尽量摆实例说道理. 对于被非理性声音影响的, 尽量秉持专业精神作纯技术探讨.很长一段时间内, 恐怕会面对某些无视事实的指责刁难(尤其是匿名/水军), 以及用心叵测者的挑衅. 请不要被拉低到同一层次或者拖进非理性谩骂的陷阱中.对于确实可复现的中文命名或者主创的中文编程语言导致的相关问题, 重视并尽力辅助解决. 如果牵涉到某些项目对中文命名的支持问题, 请参考下面向Vuejs提问题报告的例子. 这不仅能鼓励中文编程的直接用户群, 也可以提高在整个开源社区中的影响.参考:  对在代码中使用中文命名的质疑与回应  用中文命名API的意义和途径  国人创造中文编程语言的优势推广由于本营现在Github, 需特别注意遵守它的规范. 成立之初采用的是选取潜在用户, 不预先通知直接发邀请的方式, 但马上被用户举报spam并被管理员警告. 自此, 先在潜在用户的相关commit/issue/repo先建立联系后询问是否有兴趣加入组. 获得确认后再发送邀请. 新管理员请严守此则. 在其他社区招募也请谨慎.对支持中文命名(即Unicode命名, 后同)的开源项目社区, 一个交流途径是试用并提出中文命名的相关问题并推进解决, 如中文代码示例之Vuejs入门教程(一)问题后续."
    } ,
  
    {
      "title"    : "中文代码示例之Spring Boot 2.0.3问好",
      "category" : "命名, Spring",
      "description" : "演示在Spring Boot 2.0.3入门示例中使用中文代码. Demostrate naming in Chinese in the basic tutorial of Spring Boot 2.0.3.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/spring/2018/08/11/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BSpring-Boot-2.0.3%E9%97%AE%E5%A5%BD.html",
      "date"     : "2018-08-11 00:00:00 -0700",
      "content"  : "上次试用Spring Boot还是两年前: 中文代码示例之Spring Boot 1.3.3演示. 打算用在一个讨论组内小项目上, 于是从官网Building an Application with Spring Boot入门开始.源码库: program-in-chinese/spring_boot_hello_zh汉化后的源码如下:问好控制器:RestControllerpublic class 问好控制器     RequestMapping(/)    public String 索引()         return Spring Boot问好!;    主入口:SpringBootApplicationpublic class 应用     public static void main(String[] 参数)         SpringApplication.run(应用.class, 参数);        Bean    public CommandLineRunner 命令行运行器(ApplicationContext 上下文)         return 参数 -gt;             System.out.println(检查一下Spring Boot提供的beans:);            String[] bean名 = 上下文.getBeanDefinitionNames();            Arrays.sort(bean名);            for (String 某bean名 : bean名)                 System.out.println(某bean名);                    ;    控制器单元测试:RunWith(SpringRunner.class)SpringBootTestAutoConfigureMockMvcpublic class 问好控制器Test     Autowired    private MockMvc mvc;    Test    public void 取问好() throws Exception         mvc.perform(MockMvcRequestBuilders.get(/).accept(MediaType.APPLICATION_JSON))                .andExpect(status().isOk())                .andExpect(content().string(equalTo(Spring Boot问好!)));    集成测试:RunWith(SpringRunner.class)SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class 问好控制器集成测试     LocalServerPort    private int 端口;    private URL 基础网址;    Autowired    private TestRestTemplate 模板;    Before    public void 初始化() throws Exception         this.基础网址 = new URL(http://localhost: + 端口 + /);        Test    public void 取问好() throws Exception         ResponseEntitylt;Stringgt; 响应 = 模板.getForEntity(基础网址.toString(),                String.class);        assertThat(响应.getBody(), equalTo(Spring Boot问好!));    本地启动应用: mvn package amp;amp; java -jar target/spring-boot-hello-0.1.0.jar访问本地端口响应如期: curl localhost:8080Spring Boot问好!"
    } ,
  
    {
      "title"    : "在Office的VBA代码里中文命名",
      "category" : "命名, VBA",
      "description" : "如题. Use Chinese naming in VBA code in office Excel software.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/vba/2018/08/06/%E5%9C%A8Office%E7%9A%84VBA%E4%BB%A3%E7%A0%81%E9%87%8C%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D.html",
      "date"     : "2018-08-06 00:00:00 -0700",
      "content"  : "在Excel处理数据时, 顺便试了一下VBA代码编辑器里输入中文, 结果显示为乱码. 查了一下发现VBA本身支持Unicode, 但需要设置系统配置使编辑器能够正常显示, 即设置简体中文为Current language for non-Unicode programs. 详见How to display foreign characters in Excel’s Visual Basic Editor在WPS 2016专业版(试用30天)中测试如下, 最简单的中文变量/方法名通过. 类似测试在Office Excel 2016也通过:代码如下:Sub 测试()    Dim 问好 As String    问好 = 吃了么?    Cells(1, 1) = 问好End Sub但似乎OpenOffice/LibreOffice并不支持Unicode命名, 运行时报错. 需在社区中求证:它们还支持JavaScript/Python脚本, 但打开时总报JRE Required, 即使是新安装了jre8_u181之后. 未能继续深入."
    } ,
  
    {
      "title"    : "中文代码示例之Python-如何遍历字典",
      "category" : "命名, 教程",
      "description" : "对mkyong的Python教程进行例程中文化. Change sample programs in the Python tutorial on Dictionary from mkyong.com, to use Chinese naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/08/03/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BPython-%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8.html",
      "date"     : "2018-08-03 00:00:00 -0700",
      "content"  : "此系列之后将参考一些最常用功能的在线教程/示例程序, 进行示例代码的中文化改进. 欢迎推荐有代表性和实用性的教程, 篇幅小更佳. 谢谢.参考Python - How to loop a dictionary下面将介绍如何在Python中遍历一个字典1. for 键 in 字典:1.1 对字典中所有的键进行遍历 - for 键 in 字典:for 键 in 字典:    print(键)1.2 遍历字典中所有的键和对应值 - for 键, 值 in 字典.items():for 键, 值 in 字典.items():    print(键, 值)注: items()在Python2和3都可用2. 实例演示:字典测试.py:def 主程序():    股票 =         '航天机电': 3.88,        '航天动力': 9.05,        '航天电子': 6.50        # 打印所有键    for 名称 in 股票:        print(名称)        # 打印键, 对应值    for 名称, 股价 in 股票.items():        print(名称: 0, 股价: 1.format(名称, 股价))    if __name__ == '__main__':    主程序()运行结果: python 字典测试.py 航天机电航天动力航天电子名称: 航天机电, 股价: 3.88名称: 航天动力, 股价: 9.05名称: 航天电子, 股价: 6.5注: Python3.6.5下测试通过. 直接的中文命名在Python3开始支持.参考:5. Data Structures"
    } ,
  
    {
      "title"    : "对DLL库中的接口进行中文命名",
      "category" : "命名, C++",
      "description" : "基于官方文档, 将DLL库的接口进行中文命名. Based on official tutorial, name API in DLL library in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/c++/2018/07/30/%E5%AF%B9DLL%E5%BA%93%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D.html",
      "date"     : "2018-07-30 00:00:00 -0700",
      "content"  : "补注: 此文是在探究在Windows上编写DLL时不能使用中文命名 · Issue #74 · program-in-chinese/overview问题时编写的演示用代码, 代码基于官方文档. 正如farter yang在评论中指出的, 对已广泛应用的数学操作符进行的中文命名意义不如带有丰富语义的业务部分代码.源码库: program-in-chinese/MathLibraryAndClient_with_API_in_Chinese参考微软官方文档: Walkthrough: Creating and Using a Dynamic Link Library (C++)对库, 类, 接口名进行了中文命名, 成功编译并运行:主要相关源码如下:数学库.h文件:#pragma once  #ifdef 数学库导出#define 数学库接口 __declspec(dllexport)   #else  #define 数学库接口 __declspec(dllimport)   #endif  namespace 数学库    class 函数        public:        static 数学库接口 double 加(double a, double b);    ;数学库.cpp文件:#include stdafx.h  #include 数学库.h  namespace 数学库    double 函数::加(double a, double b)            return a + b;    数学小学生.cpp文件:#include stdafx.h  #include lt;iostreamgt;  #include 数学库.h  using namespace std;int main()    double a = 1;    int b = 2;    cout lt;lt; a lt;lt; 加 lt;lt; b lt;lt; = lt;lt;        数学库::函数::加(a, b) lt;lt; endl;    return 0;开发环境:VS community 2017, v15.7.5Windows 7 pro sp1如发现中文命名产生问题请留言. 谢谢."
    } ,
  
    {
      "title"    : "又见套路:如果计算机是用中文编程,你能成为计算机编程专家吗？",
      "category" : "命名",
      "description" : "对质疑中文编程的一篇网文的逐条驳斥. Detailed response to a post that's questioning programming in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2018/07/27/%E5%8F%88%E8%A7%81%E5%A5%97%E8%B7%AF-%E5%A6%82%E6%9E%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E7%94%A8%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B,%E4%BD%A0%E8%83%BD%E6%88%90%E4%B8%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E4%B8%93%E5%AE%B6%E5%90%97.html",
      "date"     : "2018-07-27 00:00:00 -0700",
      "content"  : "刚发现的头条文章: 如果计算机是用中文编程，你能成为计算机编程专家吗？这个题目又具有明显的误导性. 上来就把”用中文编程”放在一个假设性位置, 从而给人以当下不能够用中文编程的暗示, 可以想象文中不会提到即使是在英文编程语言中也可以中文命名这一可行性极强的技术手段(详见在各种编程语言中使用中文命名). 更不用说后半句的引导式疑问了.  我们知道现在已经有一个中文界面编程语言，易语言，编程的语法全部是用中文来表达，但是现在推广程度及份额不敢恭维。那我们看看有哪些原因。了解易语言的开发者应该知道, 下面的几个点其实和易语言推广的障碍都没有直接关系. 在易语言已经处于休眠状态的现在, 为什么还要拿它说事呢? 也许更重要的目的, 是把中文编程直接局限到中文编程语言以至于易语言上, 以偏概全, 转移对中文编程其他方面比如无需中文编程语言也可以中文命名等等的关注.  1.现在市面上主流及成型的模块全部是英文写的，使用起来比较方便，交流起来也比较方便。但中文编程起步较难，容易放弃。这里提到API都是英文的确实是个事实, 但交流/学习上对于中文母语的开发者是肯定没有优势的. “中文编程起步较难”就是睁眼瞎话, 易语言就是出名的起步容易. 但配上前一句之后, 乍一听起来似乎就有了一点说服力, 也是此类水文的一个套路.  2.开源一直是用户最喜欢，java因为时机准确，并且开源，一直受用户喜爱，但现在还没有一个开源的中文编程语言。个人觉得易语言开源(即使是分社区版/专业版)有可能使它重获新生. 即使如此, 不开源也不是易语言推广的直接障碍. 个人了解, 商业语言开源化是从Java在2006年的开源才大规模开始的. 而易语言在那之前的推广速度很快(详见易语言_百度百科).Z语言(详见前几篇, 如中文编程Ｚ语言设计思想)是开源的中文语法的编程语言. 另外有不少汉化现有语言的开源项目(如5分钟入门CTS-尝鲜中文版TypeScript). 非常希望看到其他商用中文编程语言/工具加入开源的队伍.  3.编程的基础是语言，编程的思路是核心，不断修复BUG是过程。中文编程只是让你的语言全部用中文表示，但是编程思路，仍然不变。对于一个没有基础的初学者，中文和英文没差距。第一句乍一看很有大师风范, 也许能唬住一些人, 但三个部分都是空话. 后面绕过了中文命名的问题, 强调”编程思路，仍然不变”, 这也是把编程和命名割裂开的一种引导, 显然编程思路和业务逻辑的紧密关系直接决定了母语命名具有优势. 至于最后一句”对于一个没有基础的初学者，中文和英文没差距”就是完全无视易语言易于上手而且问世就迅速推广的最主要原因了.  4.要想对编程有一定理解，如果只是中文好，仅仅只是可以看的懂写的是什么，但是和中文自然语言仍然会有较大差距，还是需要去钻研。这里又混淆了”中文编程仍需学习计算机科学才能进阶”和”中文编程不能让入门/代码开发的成本更低”两个完全不同的命题. 更具有迷惑性的是提到”和中文自然语言仍然会有较大差距”. 最直接的反驳就是所有主流英文编程语言写出的程序也都和英文自然语言有很大差距.  所以如果计算机是用中文编程，仍然需要花费大量的时间和精力去学习，去研究。该能成为一方大牛，不管用什么语言，都能做到。和前一段类似, 如果把”中文”替换成”英文”, 也是完全成立的. 很明显的引导方向是: 大家都去学现在的流行语言吧, 就别惦记着用中文编程了.此种水文层出不穷, 但套路基本相同. 还有一类是挑选一些推手问题引出的”精华”回答来证明中文编程的不被待见. 比如这篇的素材就源自知乎某问题: 看看90万程序员讨论的话题：能否用中文写代码？"
    } ,
  
    {
      "title"    : "中文编程讨论组一岁了",
      "category" : "小结, 年度",
      "description" : "中文编程讨论组自2017年7月末成立, 收获良多, 在此作一回顾和展望. The Programming in Chinese discussion group is one year old. Happy birthday to ourselves. Looking forward to more success in the future.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/%E5%B9%B4%E5%BA%A6/2018/07/26/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%AE%A8%E8%AE%BA%E7%BB%84%E4%B8%80%E5%B2%81%E4%BA%86.html",
      "date"     : "2018-07-26 00:00:00 -0700",
      "content"  : "中文编程讨论组自2017年7月末成立, 收获良多. 在此作一回顾和展望.下面是一年来我们参与, 整理的一些项目和讨论(不完整列表).语言设计  新创中文语法的编程语言. 设计, 原型与实践          Agda原生实现中文语法      中文编程Ｚ语言设计思想      无空格设计      Antlr4+JavaScript实现类LOGO语法系列      Antlr4+Java实现简单语言的尝试        基于现有英文编程语言, 进行关键词汉化的讨论与实践          C: 为GCC添加中文关键字      Python: 为Python添加中文关键字      TypeScript: CTS(见下)以及为其开发的vscode输入法插件      更广泛的关键词讨论      命名实践  开发中文API          Java:                  Java通用接口集          汉化版Junit4          提交到Maven的简繁转换库                    TypeScript: 5分钟入门CTS-尝鲜中文版TypeScript        在语言入门教程的示例代码中使用中文命名          Java: 中文代码示例教程之Java编程一天入门      Python: 中文代码示例视频演示Python入门        在英文编程语言/框架中使用中文命名开发项目          Java:                  中文代码示例之Spring Boot 1.3.3演示          烂尾工程: Java实现的汇编语言编译器                    JavaScript: History in Threads: 火狐插件实现浏览历史按主题显示(树)      Kotlin: FriceEngine试用与API中文化      Python: 臺灣言語工具      小结与展望过去一年在中文编程的不同方向上都有收获. 通过知乎专栏和其他推广渠道, 有更多人看到了中文命名和中文语法的优势, 以及中文编程语言设计的多样性和实现上的可行性.主要问题之一是, 项目尚未成气候. 几个可能的方向是:  完善现有的开源项目  加强为新编程语言服务的IDE支持  改进使用中文命名示例代码的教程, 并争取形成系列另一个问题, 是推广的方式. 知乎专栏可以作为前进基地, 但各种方向都需要接触更多和更广的用户.不积跬步无以至千里. 望一起再接再厉."
    } ,
  
    {
      "title"    : "Z语言实现基本原理",
      "category" : "语言设计",
      "description" : "Z语言作者介绍它的实现原理和细节. Under the hood of Z programming language by its author.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/07/24/Z%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",
      "date"     : "2018-07-24 00:00:00 -0700",
      "content"  : "原文作者: TKT2016 (知乎, github)计算机编程发展已经有几十年了，编程的难度也越来越小，会编程的人也越来越多。但是现在的编程还是非常难，需要专门学习很长时间才能掌握。我的目标是创造出更简单更容易掌握的语言，所以我开发出了Z语言。C#语言中实现用控制台打印”你好”的程序是Console.Write(“你好”);对一个没有接触编程的人来说，他至少需要懂Console是什么、Write是什么、‘.’号起什么作用、“你好”为什么需要括号括起来。在Z语言中打印“你好”的程序是这样写的控制台打印“你好”相比来说，Z语言程序是主要用汉字写的，和中文自然语法比较接近，需要学习的知识点更少，一般人即使没有学过，也能一眼看出这句话是什么意思。Z语言编译为了实现正确编译上条控制台打印“你好”程序，会进行以下步骤。一、准备实际功能类(控制台的源文件在’Z语言系统/控制台’)1.新建类新建一个叫‘控制台’的C#类，给这个类名添加特性[ZStatic]。(Zstatic在‘Z语言接口编写文档’解释)2.实现’ public static void Write(object obj)’方法3.给‘打印(object obj)’添加‘[ZCode(“打印(object:obj)”)]’特性二、读取Token流编译器读取源文件，把控制台打印“你好” 分析成标识“控制台打印”和字符串“你好”两个Token控制台打印“你好” → 控制台打印 ＋ “你好”三、语法分析编译器分析导入的开发包，构建词库，根据‘[ZStatic]’标注的控制台类型和‘[ZCode(“打印(object:obj)”)]’构建两个词‘控制台’和‘打印’四、表达式分析编译器根据词库把‘控制台打印’分词为‘控制台’和‘打印’两个Token控制台打印 ＋ “你好” → 控制台 ＋ 打印＋ “你好”五、语义分析从控制台Token查找到控制台类型，根据打印Token查找特性为‘[ZCode(“打印(object:obj)”)]’的方法Write，把把“你好” Token作为方法调用的参数六、生成二进制指令编译器生成CLR调用方法指令ldstr bytearray(60 4F 7D 59 )call void [‘Z语言系统’]’Z语言系统’.’控制台’::Write(object)Z语言也可以实现对参数不在末尾的方法的调用。比如下面例子。在C#中，控制台换行实现如下Console.WriteLine();如果要求根据一个整数参数k连续换行k行，代码可以编写为一个方法（在’Z语言系统/控制台’）public static void 换行(int k)  for (int i = 0; i lt; k; i++)    Console.WriteLine();  用C#语言调用这一方法的程序是控制台.换行(5);而给这个方法加特性[ZCode(“换(int:k)行”)] 后就可以在Z语言中这样调用控制台换5行5是参数，‘换’和‘行’是调用过程名称的组成部分。这是Z语言先进于主流编程语言的一个地方，主流编程语言中参数必须放在语句的末尾，Z语言的参数可以放在一条语句的任意位置，实现了编程的类自然语言化。编译器对控制台换5行 这条程序的处理大概步骤如下。一、读取Token流控制台换5行 → 控制台换5行二、语法分析编译器分析导入的开发包，构建词库，根据‘[ZStatic]’标注的控制台类型和‘[ZCode(“打印(object:obj)”)]’构建两个词‘控制台’、‘换’、‘行’三、表达式分析对程序进行分词控制台换5行 → 控制台 ＋ 换 ＋ 5 ＋行四、语义分析从控制台Token查找到控制台类型，根据换 ＋ 5 ＋ 行查找特性为‘ZCode(“换(int:k)行”)’的方法，把把5作为方法调用的参数五、生成二进制指令编译器生成CLR指令ldc.i4.5call void [‘Z语言系统’]’Z语言系统’.’控制台’::’换行’(int32)"
    } ,
  
    {
      "title"    : "在代码中进行中文命名(类/变量/方法等)的优势",
      "category" : "命名",
      "description" : "相比英文命名, 一些中文命名的优势. Some advantages with Chinese naming compared to English naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2018/07/19/%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D(%E7%B1%BB-%E5%8F%98%E9%87%8F-%E6%96%B9%E6%B3%95%E7%AD%89)%E7%9A%84%E4%BC%98%E5%8A%BF.html",
      "date"     : "2018-07-19 00:00:00 -0700",
      "content"  : "最初的专栏文章对在代码中使用中文命名的质疑与回应是对一些常见质疑的批驳, 至今未见更有理的反面声音. 鉴于最近看到一些对中文命名进行负面暗示各种带节奏的网文(见最近一波对中文编程(包括中文命名)的攻势), 实在难以置之不理.此文尝试小结一些比起英文命名更方便之处. 注意这是在明确的母语优势(对在代码中使用中文命名的质疑与回应“没有好处”一节)基础上额外的优势:一. 不需要驼峰命名法或者下划线分隔之前看到过有人问”中文命名怎么用驼峰命名法?”. 答案是, 不用, 因为根本就不需要. 原因很简单, 中文语言本身就不用空格分隔. 带来的好处是, 中文命名和中文自然语言更加接近. 比较如下:英文变量名: “weaponOfMonkeyKing” 或者 “weapon_of_monkey_king”对应自然语言: “weapon of the Monkey King”中文变量名: “孙悟空的武器” 对应自然语言完全相同二. 单字变量视觉混淆更少Python创始人亲自编写的Python命名规范PEP 8 – Style Guide for Python Code就直接指出需要避免使用单字母的’l’, ‘O’, ‘I’(猜猜第一个还是第三个是大写i?)进行命名:  Never use the characters ‘l’ (lowercase letter el), ‘O’ (uppercase letter oh), or ‘I’ (uppercase letter eye) as single character variable names.In some fonts, these characters are indistinguishable from the numerals one and zero. When tempted to use ‘l’, use ‘L’ instead.另外还有i, j在两层循环中容易混淆等等, 而中文单字(如’甲’, ‘乙’, ‘丙’, ‘丁’等等)没有这样的问题三. 中文单复数模糊性更符合语义摘自中英文代码对比系列之Java一例:  flaggedCells是个List, 它用复数命名的意思是”可能包含多个格”. 而实际上这个变量可能只包含一个格. 中文中的名词不分单复数, 正好符合”这个变量有可能含有单个或多个元素”这个语义. 因此命名为被标的格感觉可行. 假如语义需要强调有多个(不可能只有单个或没有), 可以考虑加上修饰如多个前缀等等.四. 单字命名有更多选择, 也更可读承蒙评论中指出, 单字命名在英文命名中确实常见. Is the use of one-letter variables encouraged?总结的比较全面, 还加了不少双字母的.由于英文字母总共26个, 加上大写也很有限. 以至于有些字母有几种用法, 比如k: 1) 在循环中表示变量 2) 在表中表示键. 而单字中文的选择就多的多了. 比如(肯定有更合适的, 待集思广益): index-位/索/引, file-档, key-键(循环变量用’甲乙丙丁’之类, 就不会有上面的k的两种用法问题), value-值. 而这些中文单字比起对应的英文字母来, 明显更可读. 比较: i-位/索/引, f-档, k-键, v-值欢迎补充."
    } ,
  
    {
      "title"    : "最近一波对中文编程(包括中文命名)的攻势",
      "category" : "命名",
      "description" : "对质疑中文编程的一篇网文的追究. Back tracking a post that's questioning programming in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2018/07/18/%E6%9C%80%E8%BF%91%E4%B8%80%E6%B3%A2%E5%AF%B9%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B(%E5%8C%85%E6%8B%AC%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D)%E7%9A%84%E6%94%BB%E5%8A%BF.html",
      "date"     : "2018-07-18 12:00:00 -0700",
      "content"  : "相信很多人看到了这篇文章: 如果我们的编程替换成中文会变成怎样?-聚能聊-云栖社区-阿里云由于带着太明显的水文气息, 不禁花点功夫进行探究. 下面是之前的发现(原帖在专用帖: 对中文编程的质疑, 困惑, 批评, 吐槽请到此处 · Issue #44 · program-in-chinese/overview)刚找到了第一张图的出处, 居然还是知乎贴: 四年前的田雅夫：如果计算机是由中国人发明的，那么编程时写代码会是全中文吗？相信原作者的玩笑成分为多.还找到了这篇文章的前一版本: 如果编程替换成中文就会怎样? 程序员看了表示头疼发现前后两个版本的一些区别, 推敲了一下. 前文的VB例子明显不如中文代码来的一目了然. 因此后文强行改为了Java代码(也不顾易语言和VB的事实关系了), 靠着编辑器的高亮功能勉强得出英文代码更清晰的结论.而前文中的第一个易飞扬代码(“易语言.飞扬”（EF）集成开发环境 EFIDE 0.2.2 下载地址), 明显有较强的可读性, 以至于都不敢拿同样功能的英文代码进行比较. 因此后文直接删除了, 以更复杂也更难以一目了然的易语言程序代替. 加了一句在以前初中，老师在上完课后教了我们有趣的易语言中文编程，那时候感觉很有趣, 以示自己有易语言使用经验.全文的中心似乎是”中文并不适合现有的编程方式”, 后面的”未来的发展可能超出你的想象”也是画饼而已. 最大的意外是, 后面竟然提到”现代的语言比如Java，都支持Unicode，也就是说可以用中文甚至世界其他语言做变量名和函数名”. 本以为如果是全部否定中文编程的文章, 似乎应该回避这个很多初学者都不知道的点. 不过文中的调子还是中文命名不如英文命名, 看来是黑的更高级了一点.后文的问题又提到:  2.在目前的c++、java等编程语言有使用过中文作为变量名吗？再看看下面的多数热评对中文命名还是基本反面态度, 说的基本是汉字输入慢, 会有莫名问题, 没规范等等老生常谈.在腾讯看到另一篇转载, 评论区看到熟人哈, 也看到其他不少对中文编程支持的声音, 不过没什么对中文命名的探讨.另外, 更早的一个版本”假如编程交换成中文就会更简单吗?程序员看了表示头疼”(链接已失效)中, 用的是”言语”, 还有一些错别字. 在后续版本里都修正了, 也是颇为用心了.前文中有的部分:后文中被改成了Java, 和更复杂的易语言代码:前文中有的代码示例, 后文中被删去了:这么看来, 它不仅是黑中文编程语言. 蛮意外的是中文命名被提到台面上了, 而之前看到的绝大多数关于中文编程的网文都只关注易语言为主的中文编程语言. 无论这一波讨论的推手动机如何, 至少中文命名已经成为了中文编程中不得不提的一个方面吧.———————- 2018.7.20 更新 —————–发现疑似主要内容的出处(2017/11): 国内码农为什么那么讨厌中文编程？-中文编程,码农,讨厌,为什么. 也许是被推手(很可能是这个问题的发起者)发现, 无意中为后续加工提供了素材. 很高兴看到有不少其他回答中表示了对中文命名的支持, 以及亲身实践.总结一下推手的套路:  首先, 试探性地发起一个争议性题目, 拉高赞一个最合意的答案, 并将其收入素材之中  搜集对题目本身的质疑, 比如一个回复中指出, “上来就是国内码农讨厌中文”, 在后续加工中进行改进, 以减轻对发起者动机的质疑. 可以看到后面的一篇题目就改成了”如果编程替换成中文就会怎样? 程序员看了表示头疼”  过一段时间后, 将素材再加工, 润色, 包括加上天书般的中文示例代码, 加入自己的”易语言学习经验”等等, 再在更多平台上传播.这样的水文相信会越来越多, 大家擦亮眼吧."
    } ,
  
    {
      "title"    : "万马齐喑究可哀-中文编程的又一波&quot;讨论&quot;",
      "category" : "命名",
      "description" : "对问题假设中国人最先开发电脑和设计程序语言，那么各种程序语言会使用汉字吗？的回应. A response to the question what if the Chinese invented computer first?",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2018/07/18/%E4%B8%87%E9%A9%AC%E9%BD%90%E5%96%91%E7%A9%B6%E5%8F%AF%E5%93%80-%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%88%E4%B8%80%E6%B3%A2_%E8%AE%A8%E8%AE%BA.html",
      "date"     : "2018-07-18 00:00:00 -0700",
      "content"  : "刚申诉了自动折叠, 还是把回答转帖一下: 吴烜：假设中国人最先开发电脑和设计程序语言，那么各种程序语言会使用汉字吗？这种有明显倾向性的问题怎么还有市场呢…不管谁先开发的电脑(就不论算盘之类是不是计算机前身了), 就不许后来者基于自身需求开发最趁手的工具吗?再说一遍, 没有中文编程语言, 也可以在代码中用中文命名! 是的, 现在就可以! 不需要任何额外的工具: 在各种编程语言中使用中文命名母语命名标识符可以带来代码清晰度和可维护性的提高: Python3选择支持非ASCII码标识符的缘由. 而支持Unicode命名是大多数现代编程语言都具备的特性, 难道那些语言开发者都闲得慌才加的这个特性吗?各种用诡异的中文命名写出天书般代码来证明中文代码可读性不高的请用英文把同样的代码用直译一遍, 再放在一起比较一下, 到底哪个更天书.基于各种语言/框架的中文命名例子见中文编程专栏目录, 初衷和希冀的”中文命名”部分目录(Java, Python, Javascript等).其他关于中文命名的质疑(比如输入慢, 没好处, Linux也用的英文命名, 不利于外国开发者贡献, 用中文注释就够了, 现有API都是英文的, 编程语言和自然语言无关, 会有编码问题, 会影响钱程, 没有先例等等)回应详见对在代码中使用中文命名的质疑与回应. 欢迎各种新论点.下面该有人说中文命名和中文编程语言无关了.正因为缺少这种中文命名的实践, 各种编程和领域术语都没有形成规范(即使常见用词List和Collection都有不同的中文说法, 见讨论参考MSDN，试搞.NET类库标识符的翻译版 · Issue #54 · program-in-chinese/overview), 设计中文语法的编程语言往往成了无本之木. 语言特性应该从实践中提炼, 即使在现有英文编程语言中进行的中文命名实践, 也可以促进中文语法编程语言/开发工具的发展. 个人的看法, 中文编程语言有没有空格, 到底要多”高级”, 都是其次. 好用应该是第一原则, 在这方面易语言是个标杆, 可惜十多年了至今无人跨越.再说, 现实是英文编程语言的天下, 为什么不在这些工具中用中文命名, 以最小的代价实现代码可读性提升呢? 哪天有合适的中文编程语言了, 把代码移植过去都方便的多. 十年之后, 估计会有不少人吐槽, 当年把中文术语硬翻成了英文标识符(甚至于拼音), 现在还得翻回去, 当年是怎么想的.最近又看到不少此类带节奏的文章, 就刚才还挖了一篇的底(专用帖: 对中文编程的质疑, 困惑, 批评, 吐槽请到此处 · Issue #44 · program-in-chinese/overview). 只能说, 看来有些人终于有点急了, 因为代码可读性的重要性, 以及中文命名对可读性的提升已经被越来越多的人认识到了. 此路必定不平坦, 比如很多中文编码相关的坑会让中文命名来背锅, 更不用说非技术因素了(见中文编程兴起的可能途径). 但这恐怕是大势所趋. 能在此大势中出一份微薄之力, 也算是个人之幸."
    } ,
  
    {
      "title"    : "为Chrome和火狐浏览器编写扩展",
      "category" : "命名, 教程",
      "description" : "为Chrome和火狐浏览器编写一个简单的扩展, 使用中文命名. Use Chinese naming when developing a simple extension for Chrome/Firefox.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/07/10/%E4%B8%BAChrome%E5%92%8C%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%96%E5%86%99%E6%89%A9%E5%B1%95.html",
      "date"     : "2018-07-10 00:00:00 -0700",
      "content"  : "由于扩展标准的逐渐一致, 现在同一扩展代码库已经有可能同时用于Chrome和火狐. 下面是一个简单的工具栏按钮和弹窗(尚无任何实际功能):代码库地址: nobodxbodon/suan1所有代码:manifest.json:  manifest_version: 2,  name: 算一,  version: 0.0.1,  description: 工具栏按钮, 弹窗中包含计算器,  homepage_url: https://github.com/nobodxbodon/suan1,  icons:     48: 图标/算-48.png,    96: 图标/算-96.png  ,  permissions: [],  browser_action:     default_icon: 图标/算-32.png,    default_title: 算一,    default_popup: 弹窗/主界面.html  弹窗/主界面.htmllt;!DOCTYPE htmlgt;lt;htmlgt;  lt;headgt;    lt;meta charset=utf-8gt;    lt;link rel=stylesheet href=主界面.css/gt;  lt;/headgt;lt;bodygt;  lt;div class=按钮gt;你好lt;/divgt;  lt;script src=主界面.jsgt;lt;/scriptgt;lt;/bodygt;lt;/htmlgt;弹窗/主界面.csshtml, body   width: 100px;.按钮   margin: 3 auto;  padding: 4px;  text-align: center;  font-size: 1.5em;  cursor: pointer;待续…"
    } ,
  
    {
      "title"    : "&quot;西游记&quot;主题Python入门示例尝试-数据结构 5.1-5.1.2",
      "category" : "命名, 教程",
      "description" : "参考Python入门教程第五章数据结构中的有关列表的几个示例代码进行命名中文化. Change some sample programs about List in chapter 5 of Python 3 official tutorial, to use Chinese naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/06/29/%E8%A5%BF%E6%B8%B8%E8%AE%B0%E4%B8%BB%E9%A2%98Python%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%E5%B0%9D%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5.1-5.1.2.html",
      "date"     : "2018-06-29 00:00:00 -0700",
      "content"  : "(见前: 中文代码示例视频演示Python入门第五章 数据结构) 仍然基于官方文档, 欢迎建议(尤其是如何取材).5. Data Structures - More on Lists 列表详述gt;gt;gt; 人物 = ['佛', '妖', '凡人', '菩萨', '妖', '凡人']gt;gt;gt; 人物.count('妖')2gt;gt;gt; 人物.count('圣人')0gt;gt;gt; 人物.index('凡人')2gt;gt;gt; 人物.index('凡人', 4)        # 从位置4开始搜索下一个凡人5gt;gt;gt; 人物.reverse()gt;gt;gt; 人物['凡人', '妖', '菩萨', '凡人', '妖', '佛']gt;gt;gt; 人物.append('仙')gt;gt;gt; 人物['凡人', '妖', '菩萨', '凡人', '妖', '佛', '仙']gt;gt;gt; 人物.sort()                # 按照编码排序, 详见5.8gt;gt;gt; 人物['仙', '佛', '凡人', '凡人', '妖', '妖', '菩萨']gt;gt;gt; 人物.pop()'菩萨'5. Data Structures - Using Lists as Stacks 用列表实现栈gt;gt;gt; 取经队伍 = ['唐僧', '孙悟空']gt;gt;gt; 取经队伍.append('猪悟能')gt;gt;gt; 取经队伍.append('沙悟净')gt;gt;gt; 取经队伍['唐僧', '孙悟空', '猪悟能', '沙悟净']gt;gt;gt; 取经队伍.pop()'沙悟净'gt;gt;gt; 取经队伍['唐僧', '孙悟空', '猪悟能']gt;gt;gt; 取经队伍.pop()'猪悟能'gt;gt;gt; 取经队伍.pop()'孙悟空'gt;gt;gt; 取经队伍['唐僧']5. Data Structures - Using Lists as Queues 用列表实现队列gt;gt;gt; 围剿大圣 = deque(['巨灵神', '哪吒',  '四大天王'])gt;gt;gt; 围剿大圣.append('二郎神')          # 二郎神来了gt;gt;gt; 围剿大圣.append('太上老君')        # 太上老君来了gt;gt;gt; 围剿大圣.popleft()               # 最先到的离开了'巨灵神'gt;gt;gt; 围剿大圣.popleft()               # 第二个到的离开了'哪吒'gt;gt;gt; 围剿大圣                         # 按照到达顺序的剩余队列deque(['四大天王', '二郎神', '太上老君'])"
    } ,
  
    {
      "title"    : "解谜计算机科学第一章示例汉化尝试",
      "category" : "命名, 教程",
      "description" : "对解谜计算机科学第一章中的示例代码进行命名中文化. Change demo programs in chapter 1 of the ebook Demystify Computing Science to use Chinese naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/06/26/%E8%A7%A3%E8%B0%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%A4%BA%E4%BE%8B%E6%B1%89%E5%8C%96%E5%B0%9D%E8%AF%95.html",
      "date"     : "2018-06-26 14:30:00 -0700",
      "content"  : "知乎原链示例程序来源: 解谜计算机科学（1）  比如我们想要表达一个“风扇控制器”，有了它之后，风扇的转速总是当前气温的两倍。这个“当前气温”就是一个未知数。原例程:t -gt; t*2f = t -gt; t*2f(t) = t*2个人觉得相对抽象, 和数学表达比较近. 猜想选择t作变量名是因为temperature. 汉化尝试如下:气温 -gt; 气温*2风扇转速 = 气温 -gt; 气温*2风扇转速(气温) = 气温*2  比如，如果我想表达这样一个“食物选择器”：如果气温低于 22 度，就返回 “hotpot” 表示今天吃火锅，否则返回 “ice cream” 表示今天吃冰激凌。原例程:t -gt; if (t lt; 22)             hotpot          else             ice cream     个人感觉下面更直观一点:气温 -gt; 如果 (气温 lt; 22)             火锅          否则             冰淇淋       不好的变量和参数名会导致代码难以理解，引起程序员的混乱和错误。所以通常说来，你需要给变量和参数起好的名字。什么样的名字好呢？我会在后面集中讲解。很期待之后章节对代码可读性的探讨."
    } ,
  
    {
      "title"    : "中文代码示例视频演示Python入门教程第五章 数据结构",
      "category" : "命名, 教程",
      "description" : "参考Python入门教程第五章数据结构, 用视频演示编写中文命名的示例代码 Demonstrating writing sample codes using Chinese naming based on chapter 5 of Python official tutorial by videos.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/06/21/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E8%A7%86%E9%A2%91%E6%BC%94%E7%A4%BAPython%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",
      "date"     : "2018-06-21 14:30:00 -0700",
      "content"  : "知乎原链续前作: 中文代码示例视频演示Python入门教程第四章 控制流对应在线文档: 5. Data Structures这一章起初还是采取了尽量与原例程相近的汉化方式, 但有些语义较偏(如Trondheim的hammer dance). 鉴于这一教程的目的在于使人尽量快速入门Python, 而任何不熟悉的词汇都会加上不必要的负担. 于是最终决定不拘泥于与原例程的”形似”, 而采取在例程中使用更为国人熟知的词汇了.中文代码示例Python入门教程 5.1 列表详述_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.1.1 用列表实现栈_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.1.2 用列表实现队列_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.1.3 列表构成_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.1.4 嵌套列表构成_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.2 del(删除)语句_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.3 元组和序列_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.4 集合_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.5 字典_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.6 循环方法_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.7 更多条件判断_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 5.8 比较序列和其他类型_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​如前文所述, 这一系列在此章结束."
    } ,
  
    {
      "title"    : "中文代码示例视频演示Python入门教程第四章 控制流",
      "category" : "命名, 教程",
      "description" : "参考Python入门教程第四章控制流, 用视频演示编写中文命名的示例代码 Demonstrating writing sample codes using Chinese naming based on chapter 4 of Python official tutorial by videos.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/06/20/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E8%A7%86%E9%A2%91%E6%BC%94%E7%A4%BAPython%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8E%A7%E5%88%B6%E6%B5%81.html",
      "date"     : "2018-06-20 15:00:00 -0700",
      "content"  : "知乎原链续前作: 中文代码示例视频演示Python入门教程第三章 简介Python对应在线文档: 4. More Control Flow Tools录制中出了不少岔子. 另外, 输入法确实是一个短板.中文代码示例Python入门教程 4.1 if条件语句 amp; 4.2 for语句_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.3 range函数_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.4 break, continue, 循环中的else_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.5 pass语句_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.6 定义函数_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.7.1 定义函数 - 默认参数值_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.7.2 定义函数 - 关键词参数 第一部分_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.7.2 定义函数 - 关键词参数 第二部分_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.7.3 定义函数 - 任意参数列表_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.7.4 定义函数 - 展开参数列表_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.7.5 定义函数 - Lambda表达式_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.7.6 定义函数 - 文档字符串_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​中文代码示例Python入门教程 4.7.7 定义函数 - 函数注解_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​"
    } ,
  
    {
      "title"    : "中文代码示例视频演示Python入门教程第三章 简介Python",
      "category" : "命名, 教程",
      "description" : "参考Python入门教程第三章简介Python, 用视频演示编写中文命名的示例代码 Demonstrating writing sample codes using Chinese naming based on chapter 3 of Python official tutorial by videos.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/06/20/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E8%A7%86%E9%A2%91%E6%BC%94%E7%A4%BAPython%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AE%80%E4%BB%8BPython.html",
      "date"     : "2018-06-20 00:00:00 -0700",
      "content"  : "知乎原链Python 3.6.5官方入门教程中示例代码汉化后演示对应在线文档: 3. An Informal Introduction to Python不知如何合集, 请指教.中文代码示例Python入门教程 3.1.1_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili中文代码示例Python入门教程 3.1.2 第一部分_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili中文代码示例Python入门教程 3.1.2 第二部分_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili中文代码示例Python入门教程 3.1.3_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili中文代码示例Python入门教程 3.2_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili汉化示例代码进行到第五章后, 感觉官方文档的示例与Python创始人的渊源过深(如代码考古-Python3官方教程字典例程). 更希望另行编写一些更有中文特色的教程. 此视频系列也打算在完成第五章后停止. 几个目的:  自审核汉化的代码. 视频录制过程中发现了不少第一次的错漏之处  更多体会中文代码在Python环境中的交互  复习Python欢迎拍砖."
    } ,
  
    {
      "title"    : "代码考古-Python3官方教程字典例程",
      "category" : "命名, 教程",
      "description" : "研究Python3官方教程中的字典例程的来历. The hidden meaning behind the sample program of Dictionary in Python 3's official tutorial.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/05/14/%E4%BB%A3%E7%A0%81%E8%80%83%E5%8F%A4-Python3%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E5%AD%97%E5%85%B8%E4%BE%8B%E7%A8%8B.html",
      "date"     : "2018-05-14 00:00:00 -0700",
      "content"  : "知乎原链  Data Structures中的第一个例程:gt;gt;gt; tel = 'jack': 4098, 'sape': 4139gt;gt;gt; tel['guido'] = 4127gt;gt;gt; tel'sape': 4139, 'guido': 4127, 'jack': 4098gt;gt;gt; tel['jack']4098gt;gt;gt; del tel['sape']gt;gt;gt; tel['irv'] = 4127gt;gt;gt; tel'guido': 4127, 'irv': 4127, 'jack': 4098gt;gt;gt; list(tel.keys())['irv', 'guido', 'jack']gt;gt;gt; sorted(tel.keys())['guido', 'irv', 'jack']gt;gt;gt; 'guido' in telTruegt;gt;gt; 'jack' not in telFalse大多数读者也许都认为这些字符串和数字并没有特别意义. 如果真是这样, 这个例程还不如用 dict = 'aa': 100, 'bb': 200 之类来的一目了然, 省去多余的猜度.不巧发现”guido”是Python创作者的名字(Guido van Rossum), 就觉得不该这么简单. 根据python源码27年前的commit6fc178f46d40aa068a713b509904d343ee55cfa6, 这个教程中的示例代码是Guido本人编写的. 因此与他1991年8月附近的经历应该有关. 接着找到他的简历中的:  From 1986 till 1991 I was with the Amoeba project, headed by Sape Mullender发现Sape也是人名, 基本可以确定是他的同事的名字. 接下去搜到这里“Open Software Foundation”文末, Sape Mullender的电话是+20-592 4139, 可以印证例程中的变量tel应该指的是当时他们的电话号码后四位.接着找到Jack的号码: +31 20 592 4098另外还找到Guido用过4127这一号码, 也许这是CWI那时的一个多人号码, 如此文, 就能解释这个代码示例中还有”irv”也映射到了这个号码.原来, 这是一个电话簿. 考虑到Python创造之初, 主要用户都是Guido的同事, 也是当时他写教程的读者, 这个示例代码对于他们来说是很容易理解的. 但随着几十年Python的推广, 它的含义也就被掩埋了.英文代码风格中不提倡缩写名词挺合理的. 如果原例程中的变量名是phone或者telephone, 也会比tel好理解一些. 字符串的首字母大写也会更易于理解它们是人名. 汉化示例代码时, 打算就用”电话簿”作变量名."
    } ,
  
    {
      "title"    : "5分钟入门CTS-尝鲜中文版TypeScript",
      "category" : "命名, 教程",
      "description" : "基于TypeScript官方入门文档, 用中文版TypeScript CTS重写示例代码. Use CTS, TypeScript with Chinese keywords and APIs, to rewrite sample programs in the 5-minute tutorial from official TypeScript language website.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/05/09/5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8CTS-%E5%B0%9D%E9%B2%9C%E4%B8%AD%E6%96%87%E7%89%88TypeScript.html",
      "date"     : "2018-05-09 00:00:00 -0700",
      "content"  : "知乎原链本文为中文代码示例之5分钟入门TypeScript的CTS版本. CTS作者是htwx(github). 它实现了关键词和标准库的所有命名汉化. 本文并未使用附带的vscode相关插件(包括CTS语言插件和拼音输入插件), 与原Typescript教程类似, 只用了命令行进行编译.过程仍旧基于Typescript官方文档: TypeScript in 5 minutes.源码在: program-in-chinese/cts_in_5_min第一个CTS程序函数 问好(那谁)   返回 吃了么,  + 那谁;变量 路人 = 打酱油的;文档.体.内部HTML = 问好(路人);运行cts 问好.ts --useUnicodeKeywords编译生成”问好.js”文件.添加参数类型函数 问好(那谁: 文字)    返回 吃了么,  + 那谁;如果’那谁’的类型不符, 比如是数组类型[0,1,2], 编译时会报错, 挺好:问好.ts(7,30): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.添加接口接口 人   姓: 文字;  名: 文字;函数 问好(那谁: 人)   返回 吃了么,  + 那谁.姓 + 那谁.名;变量 路人 = 姓: 大, 名: 黄;这里路人的”形状”符合”人”, 类型就被判定为相符.自己误写成了:函数 问好(那谁: 人)   返回 吃了么,  + 人.姓 + 人.名;编译提示’人’是个类型而不是值, 挺好:问好.ts(7,20): error TS2693: '人' only refers to a type, but is being used as a value here.添加类类别 学生   全名: 文字;  构造(公开 姓: 文字, 公开 名: 文字)     本体.全名 = 姓 + 名;  接口 人   姓: 文字;  名: 文字;函数 问好(那谁: 人)   返回 吃了么,  + 那谁.姓 + 那谁.名;变量 路人 = 新建 学生(大, 黄);运行第一个网络应用为了检验js文件, 添加HTML文件:lt;!DOCTYPE htmlgt;lt;htmlgt;    lt;headgt;lt;titlegt;TypeScript你好lt;/titlegt;lt;/headgt;    lt;bodygt;        lt;script src=问好.jsgt;lt;/scriptgt;    lt;/bodygt;lt;/htmlgt;html文件在Chrome中打开显示正确:  吃了么, 大黄"
    } ,
  
    {
      "title"    : "搭建Python官方文档翻译环境-汉化示例代码",
      "category" : "命名, 教程",
      "description" : "演示翻译Python官方文档的示例代码中的标识符. Demonstrate translating the identifiers in the sample programes in official Python tutorials.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/04/27/%E6%90%AD%E5%BB%BAPython%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83-%E6%B1%89%E5%8C%96%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81.html",
      "date"     : "2018-04-27 00:00:00 -0700",
      "content"  : "通过官方i18n流程, 实现文档中的代码段的汉化, 效果如下(4. More Control Flow Tools):步骤基于python官方3.6版文档cpython/Doc生成pot文件. 参考The build configuration file, 需要在Doc/conf.py中添加配置:gettext_compact = Falsegettext_additional_targets = ['literal-block']如下命令在_build文件夹中生成pot文件, 如果不设置gettext_compact就不能生成对应路径结构(所有tutorial中文档的可翻译字段都在一个pot文件) sphinx-build -M gettext . _build如下命令生成对应po文件(参考Internationalization - Sphinx 1.8.0+ documentation): sphinx-intl update -p _build/gettext -l zh修改构建脚本: 实现代码段翻译. use gettext_additional_targets to translate code samples in … · nobodxbodon/docsbuild-scripts68e7578)按照README运行后, 即在www文件夹中生成汉化后的文档相关代码库文档构建脚本库: nobodxbodon/docsbuild-scriptspo文件库: nobodxbodon/python-docs-zh生成的HTML演示库: nobodxbodon/py36zh其他参考Getting Started: Overview amp; Introduction to Concepts"
    } ,
  
    {
      "title"    : "搭建Python官方文档翻译环境",
      "category" : "命名, 教程",
      "description" : "为翻译Python官方文档的示例代码中的标识符, 搭建翻译环境 Setup translation environment in order to translate the identifiers in the sample programes in official Python tutorials.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/04/21/%E6%90%AD%E5%BB%BAPython%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83.html",
      "date"     : "2018-04-21 00:00:00 -0700",
      "content"  : "参考PEP 545 – Python Documentation Translationsfork的编译脚本: nobodxbodon/docsbuild-scripts, 添加了zh语言标签, 以及fork的PO文件库nobodxbodon/python-docs-ko, 仅作演示用(更改字段”测试python入门教程”: Update index.po · nobodxbodon/python-docs-ko00b8073)据非常有限的理解, 大概过程是, PO文件包含了所有翻译的段落, 像打补丁似地附加到原英文文档后生成rEst格式文件, 再编译成HTML文档(html库地址:nobodxbodon/py36zh. 演示: 4. 기타 제어 흐름 도구 - Python 3.6.5 文档)接下去要解决的是, 如何汉化程序部分, 效果如下. 所有现有的其他语言的翻译文档都没有对程序进行本地化(字符串/命名等)现在可以通过直接修改rst文件, 但PEP 545的流程是修改PO文件. 问了其他翻译组的作者, 似乎需要修改Sphinx配置才能实现(在PO文件中添加程序部分, 并且在构建时合并入rst文件).另:Python官方文档(入门教程只是一小部分)日语翻译进度86+, 法语30, 中文1.5: The Python 3.6 translation project on Transifex. 后得知早先有老版本3.2.2的中文翻译项目: https://docspy3zh.readthedocs.io/en/latest/ 不知是否是这1.5的前身."
    } ,
  
    {
      "title"    : "从人机交互角度看中文编程:&#39;打开微信&#39;",
      "category" : "语言设计",
      "description" : "越来越多的人机交互使用自然语言, 比如移动设备. 从这个角度看, 中文编程已经非常普及了. Programming in Chinese seems popular already from perspective of human-machine interaction, especially mobile devices.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/03/28/%E4%BB%8E%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.html",
      "date"     : "2018-03-28 00:00:00 -0700",
      "content"  : "前文通用型的中文编程语言探讨之一: 高考是基于现有英文编程语言的一个技术思路. 在这个回答以及下面的讨论中, 又提到了编程其实是人机交互的一种形式. 不禁试着跳出程序员视角看这个问题.几年前才发现Mozilla的火狐浏览器早在2008年开始了一个叫Ubiquity的项目, 而且根据这里介绍, 它直到最近的火狐浏览器大改才失效. 官网介绍摘选:  Its purpose was to explore whether a radically different type of interface to the Web — a task-centric, natural-language-based command line — could help us get common Web tasks done faster.用户手册中, 有这样的例子:twitter updating my status with Ubiquity.translate buenas tardes from spanish to french它的界面会实时显示”运行”结果, 比如twitter的状态预览, 翻译的结果. 它也可以和浏览器操作结合起来, 比如选中网页的文本/图片后, 运行下面:email this to chris就可以把选中的内容用email发给某个联系人(看到这里, 想起之前自己的一个原型设计也许也是受到它的影响而不自知)很自然地也有将它国际化的努力. 这个插件一直没有被火狐转正的原因暂没有深究, 但也许和生不逢时有关. 2008年的自然语言交互还刚起步, 如谷歌直到几年之后才有简单自然语言语法的搜索命令. 这里是更全的自然语言界面的软件/工具/平台列表.搜索引擎的自然语言界面似乎已经能够解决大多数人的大多数日常的信息搜索问题. 它也提升了人机交互的期望值. 而编程解决的问题和信息搜索差别很大. Ubiquity更接近专用脚本语言系统的范畴, 似乎也更可以借鉴. 更现实的例子是手机语音功能(最后的系统功能和生活服务部分), 比如”打开微信”(可惜似乎国产语音助手在这方面好像还是短板). 从这个角度来说, 中文编程已经被大量用于日常生活(打开微信和print(Hello World!)都是程序吧), 只是不被提及而已.个人认为, 通过第三方应用集成手机的系统和应用功能的方式, 中文编程的潜力很大, 别说基本的日常命令还有很大提升空间, 进一步的简单条件/循环语句也可以有很多功能增强(之前的脑洞), 而似乎现在的语音助手都不具备这个功能. 类似的服务如IFTTT, 虽然只支持如果...就...不然的逻辑, 通过集成各种网络服务也有了很多用户.在浏览器平台上, 个人认为Ubiquity的插件方式还可以继续, 当然需要和移动设备结合. 只是由于和手机隔了一层浏览器API, 在可集成的系统功能上会受限一些, 但优势是可以集成浏览器本身的功能. 当然另一个优势是跨系统平台."
    } ,
  
    {
      "title"    : "&quot;Literate Programming&quot;一书摘记之一",
      "category" : "笔记",
      "description" : "代码可读性相关部分.",
      "tags"     : "",
      "url"      : "/%E7%AC%94%E8%AE%B0/2018/02/27/Literate-Programming%E4%B8%80%E4%B9%A6%E6%91%98%E8%AE%B0%E4%B9%8B%E4%B8%80.html",
      "date"     : "2018-02-27 00:00:00 -0700",
      "content"  : "书到后才发现是Knuth的论文集, 第一篇就在网上: Computer programming as an art (1974). 其中”Taste and Style”(品味和风格)一节说到”好”程序的一部分要素:  …when it works correctly. Secondly, if it is easy to change, when the time for adaptation arises. Both of these goals are achieved when the program is easily readable and understandable to a person who knows the appropriate language.很高兴看到他早就指出可读性的重要性.不远处就是那句经典的:  Premature optimization is the root of all evil (or at least most of it) in programming.时间有限, 就跳过了那些网上已有的论文. 如:structured programming with goto statements (1974)“a structured program to generate all topological sorting arrangements”直接跳到”Literate Programming(1984)”一章. 先看最后一页(总共30+). 之后写到哪里算哪里吧.这两句很有趣:  My hope is that the ability to make explanations more natural will cause more programmers to discover the joys of literate programming, because I believe it’s quite a pleasure to combine verbal and mathematical skills; but perhaps I’m hoping for too much. …Perhaps we will even one day find Pulitzer prizes awarded to computer programs.遥远地握握手. 想让程序像文章一样是个好坑, 估计个人是爬不出来了.倒数第二页提到:  I don’t believe every computer language should attempt to offer all things to all people.WEB系统结合了TEX和Pascal, 是为当时的计算机科学家设计. 论文主体是介绍一个完整的例子(20页左右). 粗看一下WEB好像是一个类自然语言语法的语言, 编译可以生成TEX文档和Pascal源码.待续."
    } ,
  
    {
      "title"    : "项目/教程中使用母语命名的&quot;问题&quot;",
      "category" : "命名, 教程",
      "description" : "在教程中使用中文命名的一些副效应. Some side effects of naming identifiers in Chinese in the sample programs of tutorials.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/02/24/%E9%A1%B9%E7%9B%AE_%E6%95%99%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AF%8D%E8%AF%AD%E5%91%BD%E5%90%8D%E7%9A%84_%E9%97%AE%E9%A2%98.html",
      "date"     : "2018-02-24 00:00:00 -0700",
      "content"  : "早先试图找使用中文命名代码的项目, 但所获寥寥: 索引: 用中文编写代码的实用开源项目 · Issue #6 · program-in-chinese/overview. 更不用说教程了: 索引: 用中文代码作示例的编程教程 · Issue #5 · program-in-chinese/overview前几天有幸看到Quora不久前的一个回复: Has any serious project been written in a non-English-based programming language?得知西门子和爱立信内部都有使用母语命名的C/C++代码(德语/瑞典语). 原文如下:  At both Siemens (German) and Ericsson (Swedish), I have seen programs written in C, and C++ where the only English words are the keywords. So if, new, else, for and the standard libraries like std::vectorlt;gt;    Everything else was in German or Swedish.    …另外, 答者还提到在布拉格碰到过一本Java编程书, 也是用非英语进行命名写的示例代码.以母语命名可读性强的优势, 照理说编程教程应该是非常适合这一实践的. 那么来试试:enum 发薪日     周一, 周二, 周三, 周四, 周五, 周六, 周日;    private static final int 每班分钟数 = 8 * 60;    int 发薪(int 工作分钟数, int 每分钟薪水)         int 底薪 = 工作分钟数 * 每分钟薪水;        int 加班费;        switch (this)         case 周六:        case 周日: // 周末            加班费 = 底薪 / 2;            break;        default: // 周中            加班费 = 工作分钟数 lt;= 每班分钟数 ? 0 : (工作分钟数 - 每班分钟数) * 每分钟薪水 / 2;                return 底薪 + 加班费;    观感如何? 个人觉得是非常一目了然, 但自带不少槽点.下面看看原版(Effective Java第三版, Item 34的例程):enum PayrollDay     MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;    private static final int MINS_PER_SHIFT = 8 * 60;    int pay(int minutesWorked, int payRate)         int basePay = minutesWorked * payRate;        int overtimePay;        switch (this)         case SATURDAY:        case SUNDAY: // Weekend            overtimePay = basePay / 2;            break;        default: // Weekday            overtimePay = minutesWorked lt;= MINS_PER_SHIFT ? 0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;                return basePay + overtimePay;    意思一样, 但是不是看上去有了些”距离感”, 槽点似乎就没那么明显了, 尤其不会有太多代入感. 可以想见, 在翻译英文原著时, 译者对代码本身的命名进行中文化也许会吃力却讨不到多少好.翻了也许会有其他麻烦的还有这种(同一本书, Item 68):if (car.speed() gt; 2 * SPEED_LIMIT)        generateAudibleAlert(Watch out for cops!);还有这种(Item 4):String s = bikini;至于下面这个例子(Item 34), 问题是想翻译都只能找到音译词, 也许还不如不翻. 而且, 在示例代码里用”桔子”, “苹果”之类在外文编程书籍中屡见不鲜, 但如果真用在中文代码中, 似乎第一感觉就有点幼稚.public enum Apple   FUJI, PIPPIN, GRANNY_SMITH public enum Orange  NAVEL, TEMPLE, BLOOD 还有一种问题比如(Programming in Scala 第三版, 7.5节):    val firstArg = if (args.length gt; 0) args(0) else     firstArg match       case salt =gt; println(pepper)      case chips =gt; println(salsa)      case eggs =gt; println(bacon)      case _ =gt; println(huh?)       直译过来是:    val 参数1 = if (参数.length gt; 0) 参数(0) else     参数1 match       case 盐 =gt; println(胡椒)      case 玉米薄片 =gt; println(萨尔萨辣酱)      case 鸡蛋 =gt; println(培根)      case _ =gt; println(啥?)          这几个词对于不大了解西方饮食习惯的读者来说, 读起来完全没有感觉. 与其费口舌在注解里普及西方文化, 也许改成这样更自然:    val 参数1 = if (参数.length gt; 0) 参数(0) else     参数1 match       case 牛奶 =gt; println(面包)      case 烧饼 =gt; println(油条)      case 煎饼果子 =gt; println(薄脆)      case _ =gt; println(啥?)          但这比起翻译本身来, 又多了不少工作量, 估计还很难获得原作者的同意. 当然, 如果是自编文献, 就没有原作的限制了, 但就像之前的例子所示, 恐怕选材和尺度都会比用英文代码更加敏感.类似的, 在项目中使用中文命名也比英文命名更需要推敲. 随手写个奇怪的英文名看起来也许不那么显眼, 但用了中文, 就会非常扎眼. 所谓”文如其人”, 也许语文的实用性会随着中文编程的推广而逐渐回归."
    } ,
  
    {
      "title"    : "Antlr4实现简单语言之条件语句",
      "category" : "命名, 教程",
      "description" : "在前作基础上, 使用Antlr4添加简单的条件语句. Based on previous work in the series, add support for simple conditional statement using Antlr4.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/02/18/Antlr4%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5.html",
      "date"     : "2018-02-18 00:00:00 -0700",
      "content"  : "本系列之前的文章:Antlr4的分析错误处理Antlr4实现数学四则运算Antlr4添加中文变量赋求值,括号,各种问题Antlr4: 修改语法规则更接近普通BNF格式Antlr4实现简单语言之整数比较表达式这一步, 实现了最简单的单条件, 只有”条件为真”时执行单语句. 例如:变量=1如果 变量lt;2 变量=变量×2变量返回2实现语法规则修改, 将原本的’声明’拆分出多个规则:声明    :   赋值声明    |   如果声明    |   求值声明    |   T新行    ;如果声明    :   '如果' 表达式 声明    ;赋值声明    : T变量名 '=' 表达式 T新行    ;求值声明    : 表达式 T新行    ;“定制访问器”中, 赋值/求值声明只需修改类型, 添加的”如果声明”部分(需改名为”条件声明”之类):  Override  public 节点 visit如果声明(如果声明Context 上下文)     条件节点 节点 = new 条件节点();    节点.条件 = visit(上下文.表达式());    节点.条件.原始文本 = 上下文.表达式().getText();    节点.条件为真分支 = visit(上下文.声明());    return 节点;  语法树节点新增类型:public class 条件节点 extends 节点   public 节点 条件;  public 节点 条件为真分支;“运行器”的”求值”方法中添加条件节点的处理:     else if (节点 instanceof 条件节点)       Object 条件 = 求值(((条件节点) 节点).条件);      if (条件 instanceof Boolean)         return (boolean)条件 ? 求值(((条件节点) 节点).条件为真分支) : null;       else         System.err.println([运行时错误] 条件部分需为布尔值:  + ((条件节点) 节点).条件.原始文本);        return null;          下面, 需要添加条件语句中对换行以及条件执行多个语句的支持, 需要选择是用还是其他特殊规则决定条件语句范围."
    } ,
  
    {
      "title"    : "中文代码示例[译]Scala中创建隐式函数",
      "category" : "命名, 教程",
      "description" : "转译入门教程 - Scala中的隐式函数, 使用中文命名. Translate a tutorial of creating implicit functions in Scala, naming identifiers in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2018/02/17/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-%E8%AF%91-Scala%E4%B8%AD%E5%88%9B%E5%BB%BA%E9%9A%90%E5%BC%8F%E5%87%BD%E6%95%B0.html",
      "date"     : "2018-02-17 00:00:00 -0700",
      "content"  : "前言: 学习Scala时, 顺便翻译一下自己有兴趣的文章. 代码中所有命名都中文化了(不是翻译). 比如原文用的是甜甜圈的例子.原文: Scala Tutorial - Learn How To Create Implicit Function简述本文学习如何创建隐式函数, 以便对几乎任何类型实现扩展方法或函数.正如其名, Scala设计时就最大化了可扩展性. Scala features tutorial提到用implicit可以方便地实现任何类型的扩展方法或函数.对之前的教程的包子铺例子, 这里扩展String类使它有最爱吃的包子()函数.步骤1. 创建String的封装类我们创建一个简单的封装类, 以String为参数, 并提供这个最爱吃的包子函数println(第一步: 创建封装类以便扩展String类型)class 包子名称(名称: String)   def 最爱吃的包子: Boolean = 名称 == 香菇菜包(原文, 下同)注:看到Scala可以用==而不是equals比较字符串, Java或者.NET的开发者也许会惊喜2. 如何创建隐式函数把String转换成封装类把隐式函数封装到object实现的单例中是个好习惯. 也可以用之后教程中的package object实现.下面, 就定义了一个隐式函数将String作参数并创建一个封装类的实例:println(#92;n第二步: 创建隐式函数把String转换为封装类)object 包子转换   implicit def 文本到包子名称(名称: String) = new 包子名称(名称)注:隐式函数与其他函数定义唯一区别就是前面有implicit关键词3. 导入转换函数进入作用域为了使用第二步中定义的隐式函数, 需要将它纳入作用域. 这需要import关键词:println(#92;n第三步: 导入转换函数进入作用域)import 包子转换._注:导入中使用的_通配符可以导入所有值或隐式函数4. 建文本常量建了两个文本常量:println(#92;n第四步: 建文本常量)val 菜包 = 香菇菜包val 肉包 = 白菜肉包5. 如何调用自定义的最爱吃的包子简单:println(#92;n第五步)println(s爱吃菜包吗 = 菜包.最爱吃的包子)println(s爱吃肉包吗 = 肉包.最爱吃的包子)运行后应该得到:第五步爱吃菜包吗 = true爱吃肉包吗 = false注:  最爱吃的包子像是String类自带的函数  但并不用修改String类的源码  而是用Scala的隐式函数来扩展了String类本节教程结束, 希望有所帮助.译后感  翻译比想象中耗时"
    } ,
  
    {
      "title"    : "中文代码示例之冒泡算法, 后感",
      "category" : "命名, 示例",
      "description" : "以冒泡算法演示代码中的中文命名. Use bubble sort algorithm to illustrate naming identifiers in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%A4%BA%E4%BE%8B/2018/02/16/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8B%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95,-%E5%90%8E%E6%84%9F.html",
      "date"     : "2018-02-16 00:00:00 -0700",
      "content"  : "以前探讨过中文命名在业务部分的优势大于算法部分. 今天又一次看到了这个以冒泡算法的例子: 刘然：批判易语言的人是否用过这门语言，批判它的原因又是什么？有些感触. 先尝试对变量命名进行改进, 来看看是否会有不同观感. 注: 本文不讨论输入效率问题, 也不讨论易语言时间太有限, 仅对帖子中的Python程序作粗浅探讨. 另一个易语言语法的例程也有不同方面的改进空间, 就不展开了. 有兴趣/质疑的欢迎提其他例程一同探讨.for i in xrange(len(a)):    for j in xrange(i + 1, len(a)):        if a[i] gt; a[j]:            a[i], a[j] = a[j], a[i]首先, 在嵌套循环中使用i和j的一个问题是, 两者看起来有点像. 下面的视觉区分度更大:for 甲 in xrange(len(a)):    for 乙 in xrange(甲 + 1, len(a)):        if a[甲] gt; a[乙]:            a[甲], a[乙] = a[乙], a[甲]也可以赋予变量名以更多语义, 来凸显变量的某些性质, 如下. 而英文命名想要表达类似语义就要长一些了:for 前 in xrange(len(a)):    for 后 in xrange(前 + 1, len(a)):        if a[前] gt; a[后]:            a[前], a[后] = a[后], a[前]后感中文命名很自然是个考验中文修养的活. 用中文命名的代码可以像天书一样”仅仅是符号”, 也可以像好文章一样用词考究恰如其分, 当然更多的(包括在下写的)限于功力或者开发时间限制也许只能达到流水账的水平.哪里用中文最有效果(对可读性增强最大), 哪里是鸡肋(比如上面的a, 可以改名为”数组”, 但效果逊一些, 也许更合适放在注释中), 也与程序的目的/设计/理解非常相关.相比数理能力, 更大量的编程任务更需要的是逻辑与思辨能力, 这种任务的比重只会越来越大. 而逻辑思辨能力是文理相通的. 与编程相配套的文档编写和阅读也更偏文, 团队建设/客户交流之类软实力更不用说. 相信随着IT产业的逐渐成熟, 文科背景的开发者将会越来越多, 长远看这肯定是好事.论文Concise and Consistent Naming: Ten Years Later提到:  Approximately 70 of the source code of a software system consists of identifiers. Hence, the names chosen as identifiers are of paramount importance for the readability of computer programs and therewith their comprehensibility. However, virtually every programming language allows programmers to use almost arbitrary sequences of characters as identifiers which far too often results in more or less meaningless or even misleading naming.很想看全文(尤其是那个辅助命名工具的十年实践的总结)但下载的pdf里只有摘要. 如果有哪位同学有全文请分享一下, 先谢了."
    } ,
  
    {
      "title"    : "编程猫IDE体验:对Scratch的改进",
      "category" : "语言设计, IDE",
      "description" : "编程猫对Scratch的编程语言功能和IDE改进. Improvements to Scratch programming language and IDE.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/ide/2018/02/06/%E7%BC%96%E7%A8%8B%E7%8C%ABIDE%E4%BD%93%E9%AA%8C-%E5%AF%B9Scratch%E7%9A%84%E6%94%B9%E8%BF%9B.html",
      "date"     : "2018-02-06 00:00:00 -0700",
      "content"  : "前两天偶遇编程猫推介(为什么没有中文的编程?), 第一眼感觉像Scratch, 求证之下确实, 并且据说有改良. 今天非常粗浅地尝试一下, 限于水平没有做出很炫的效果, 不过颇有些发现.首先上最终效果图:选择了无趣的斐波那契函数, 在这个主打动画和互动效果的开发环境里应该属于非常边缘的用户.从头开始说. 到官网上之后, 第一感觉是内容比较杂, 因为是冲着这个中文编程开发环境去的, 试了几个链接才从”创作”进到一个类似的但是英文的界面. 因为只有这里像帖子中的截图, 于是试了”多语言”选项, 还好有”简体中文”. 也许因为笔者浏览器是英文界面, 因此默认英文环境?“编程猫MOD编程器”好像是与MineCraft的集成, 但好像生成的代码需要到”Box”(代码岛)运行, 时间有限就没有体验, 但希望网站的入口能够调整一下, 或者把各个功能的关系介绍清楚一点.(补记: 经官方论坛指出 “mod编辑器做的mod是放进多玩魔盒的手机版《我的世界》中体验的，《代码岛》是一个3D图形化编程平台哈，和mod编辑器没关系”)进入环境后, 比较了一下Scratch界面, 发现中间的控件栏作了修改, 采用了顶层菜单, 点击向右展开:与原版的布局(下)相比, 猜测是出于最大化编辑框的考虑, 也许会对移动设备更加友好, 但副效应是展开时容易遮住编辑框.尝试过程中, 发现一些控件(如比较/逻辑运算)整合到了一个控件, 是个不错的改进:相比原版:通过类似整合, 减少了控件数量, 另外增加了不少辅助功能的控件, 如”是整/质/正/负数”, 等等. 不过, 在控件排序上, 还有改进空间, 比如运算部分:头尾两部分都是逻辑运算, 但中间插了一块数值运算.在定义函数的过程中, 发现参数好像是自动识别类型, 输入是文本的话, 比如”测试”, +1操作就返回”测试1”, 输入2就返回3. 原版貌似是声明参数类型.体验中最意外的是, 编程猫支持了函数返回值功能, 而即使还未发布的Scratch 3.0(Scratch 3.0 - Scratch Wiki)好像也没有这个功能. 经斐波那契测试, 感觉对于绝大多数这个环境中的用途应该足够了(函数内的局部变量没有深入测试, 不确定是否支持).在汉化方面, 还有改进的空间, 比如控件的演示字符串不少还是Hi, Hello, abc之类; 显示(2/0)的结果是”Infinity”, 仍然在某些地方把block翻译成”积木”(原版的汉化版如此. 编程猫已经把新建block改成了”函数”, 是个改进)总体感觉, 开发者的改进是颇费了一番心思, 并且对缺失的关键功能做了突破. 个人比较期待的一个功能是, 函数发布/共享, 以及官方维护一个比较常用的”标准库”, 比如更复杂的动作(转圈, 加速等等), 更复杂的运算等等. 这样就离一个实用的游戏/动画引擎和开发环境更近了一步. 而且利用他人开发的函数库还可以促进团队开发理念和开源互助的推广, 也是少儿教育的一个重要部分.瞩目!"
    } ,
  
    {
      "title"    : "AppleScript类自然语言与非英语语法设计",
      "category" : "语言设计",
      "description" : "对AppleScript语言中的类自然语言设计, 和日语, 法语的语法设计进行回顾和讨论. Review Applescript, which has a grammar close to natural language, and the support for Japanese and French grammars.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/02/04/AppleScript%E7%B1%BB%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%9D%9E%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E8%AE%BE%E8%AE%A1.html",
      "date"     : "2018-02-04 00:00:00 -0700",
      "content"  : "最早知晓是之前C#中文版的github讨论里提到了AppleScript有多语言版. 昨天想起, 觉得它毕竟是为数不多(仅有的?)大公司开发的非英语语法的编程语言, 不禁好奇它的前世今生. 于是作了一点调研.网上相关资料不多, 最早的一本AppleScript专著”AppleScript in a Nutshell”也是2001年出版, 已经到了Mac 9. AppleScript Not Necessarily in English 提到早先支持日语,法语, 还讨论过”a C dialect”, 不知指哪个语言, 但在Mac 8.5版就放弃了(1998年左右)接着有幸找到了2006年的论文”AppleScript”, 更多介绍了多语言支持以及相关问题. 这篇论文其他内容也很有价值, 包括这个项目的起源, 相关项目, 以及这一语言系统从需求分析到实现的各阶段细节. 本文只关注非英语语法部分, 对项目本身有兴趣的不妨自行细阅.下图是不同”语种”(英语, 日语, 法语, “专业”)的示例代码:文中总结的贴近自然语言语法的语言设计的问题:  The experiment in designing a language that resembled natural languages (English and Japanese) was not successful. It was assume that scripts should be presented in “natural language” so that average people could read and write them. This lead to the invention of multi-token keywords and the ability to disambiguate tokens without spaces for Japanese Kanji. In the end the syntactic variations and flexibility did more to confuse programmers than to help them out. The main problem is that AppleScript only appears to be a natural language. In fact is an artificial language, like any other programming language. Recording was successful, but even small changes to the script may introduce subtle syntactic errors which baffle users. It is easy to read AppleScript, but quite hard to write it.  When writing programs or scripts, users prefer a more conventional programming language structure. Later versions of AppleScript dropped support for dialects. In hindsight, we believe that AppleScript should have adopted the Professional Dialect that was developed but never shipped.  Finally, readability was no substitute for an effect security mechanism. Most people just run scripts — they don’t read or write them.大致是说, 类自然语言语法(包括英语和日语, 不知为何没提法语)的尝试失败了. 为了实现接近自然语言的语法, 引入了多token的关键词(猜测是类似于”在…中”这样的用法), 以及日语的无空格语法. 问题是, 这样”貌似”自然语言而实质仍然语法严格的后果之一是, 用户误认为小的改动, 其实会导致词法解析的大变化. 也就是“易读而难写”. 另一个结论是, “Professional Dialect”, 即接近Java的语法被认为是最应该被保留的, 因为它最接近传统编程习惯.最后一段的意思是, 即使代码可读性好, 也不能取代一套有效的安全机制. 因为大多数人在运行脚本之前, 并不会先读一遍, 确认它是否安全. 个人认为这个结论对语言设计的借鉴价值有限, 因为安全机制和可读性应该没有直接矛盾.关于文中提到语法近自然语言导致的问题, 个人认为与目标用户群有关. 文中提到”The language was primarily aimed at casual programmers.”以及”make it accessible to non-programmers”, 可见它的设计初衷和推广目标都是非专业程序员, 而他们是最容易将自然语言和程序语言混淆的. 这个问题同样可以适用于今天, 虽然技术上程序语言语法可以引入更多自然语言元素. 这也许是多数最新的通用型英语编程语言(求反例)仍然与自然语言保持相当距离的一个原因.话虽如此, 现今的人机交互已经越来越普及, 即使是一般用户, 对手机喊命令的时候也会清楚是对一个只懂得简单语法的机器说话. 随着大众适应的过程, 上面这个混淆的问题也许会不那么严重. 个人猜想, 编程语言的趋势还是逐渐向靠近自然语言的方向发展, 尤其是适用于大众编程的语言.再回到开头的那个讨论, 提到AppleScript时将这一功能的失败归因于关键词/语法支持多语言导致脚本内容混乱:  But it found limited adoption and where it was adopted scripts became amess of mixed languages and Apple eventually dropped support.回头看是需要考证的, 因为看起来最大的问题在于当时类似自然语言的语法, 即使只使用单纯的英语语法."
    } ,
  
    {
      "title"    : "中文编程专栏月报：2018年1月",
      "category" : "小结",
      "description" : "中文编程知乎专栏的2018年1月月度小结, 包括所有在下了解的中文编程相关项目进展. Monthly report of column Programming in Chinese, together with other progresses in Github organization and other channels.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/2018/02/03/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E4%B8%93%E6%A0%8F%E6%9C%88%E6%8A%A5-2018%E5%B9%B41%E6%9C%88.html",
      "date"     : "2018-02-03 00:00:00 -0700",
      "content"  : "原文知乎地址: 中文编程专栏月报：2018年1月本月的一大部分是围绕这个话题: 通用型的中文编程语言探讨之一: 高考. 接着用Antlr4开始了一点语言的原型开发:  Antlr4的分析错误处理  Antlr4实现数学四则运算  Antlr4添加中文变量赋求值,括号,各种问题  Antlr4: 修改语法规则更接近普通BNF格式  Antlr4实现简单语言之整数比较表达式中途尝试了另一个工具Xtext:  Xtext试用: 快速实现简单领域专用语言(DSL)  Xtext试用: 5步实现一个(中文)JVM语言下面还未确定是继续Antlr4还是Xtext. 暂时更倾向于Antlr4, 因为对个人来说用途更广, 对项目来说看起来更灵活, 但坏处是周期和开发量也许会更长.对之前的在代码中使用中文命名的业余项目进行了小结:  烂尾工程: Java实现的汇编语言编译器  History in Threads: 火狐插件实现浏览历史按主题显示(树)浅尝The Little Prover一书, 重逢Chez Scheme未能续篇, 但还有兴趣. 之前卡在了if-equal定理, 还没转过弯来.另外, 作为测试用户, 参与了两个中文编程相关的开源项目(都在代码中用了中文命名). 希望早日能达到公测的程度. 个人感觉, 项目的测试和文档(包括版本记录)的完整程度, 很大程度会影响开源的效果(开发者参与度, 用户试用等等). 个人也在尽量从这两个方面对这些项目出一点力."
    } ,
  
    {
      "title"    : "Xtext试用: 5步实现一个(中文)JVM语言",
      "category" : "语言设计, DSL",
      "description" : "利用Xtext实现中文语法的JVM语言. Use Xtext to JVM programming language with Chinese grammar.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/dsl/2018/01/19/Xtext%E8%AF%95%E7%94%A8-5%E6%AD%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA(%E4%B8%AD%E6%96%87)JVM%E8%AF%AD%E8%A8%80.html",
      "date"     : "2018-01-19 00:00:00 -0700",
      "content"  : "续上文Xtext试用: 快速实现简单领域专用语言(DSL). 基于官方教程: Five simple steps to your JVM language达成如下语言:它被Quan6JvmModelInferrer中的转换生成Java源代码(与上文中的代码生成不同的是, 不需要写出具体Java语法).项目源码在: program-in-chinese/xtext_tutorial_15_min_zh, 只包含了语法规则所在项目. 其他项目(.ide, .tests, .ui.tests等等, 也不知何用)未提交. 测试项目(包括上图的代码)在: program-in-chinese/xtext_tutorial_15_min_zh由于本人创建的项目名称与教程不同(com.program_in_chinese.quan6), 运行后打开DSL源码文件时报错:An internal error occurred during: XtextReconcilerJob.java.lang.IllegalArgumentException: Domainmodel.importSection does not exist后发现语法规则的命名空间应该修改为自定义的(本文用的Quan6, 而非教程中的Domainmodel). 顺便将关键词汉化了, 标识符支持中文(IDENTIFIER等), 更新后的语法规则如下:grammar com.program_in_chinese.quan6.Quan6 with org.eclipse.xtext.xbase.Xbasegenerate quan6 http://www.program_in_chinese.com/quan6/Quan6Quan6:    importSection=XImportSection?    elements+=AbstractElement*; AbstractElement:    PackageDeclaration | Entity; PackageDeclaration:    '包' name=QualifiedName ''        elements+=AbstractElement*    ''; Entity:    '类' name=ValidID ('扩展' superType=JvmTypeReference)? ''        features+=Feature*    ''; Feature:    Property | Operation; Property:    name=ValidID ':' type=JvmTypeReference; Operation:    '函数' name=ValidID         '('(params+=FullJvmFormalParameter         (',' params+=FullJvmFormalParameter)*)?')'        ':' type=JvmTypeReference     body=XBlockExpression;OverrideValidID:    IDENTIFIER;    terminal IDENTIFIER:    '^'?('#92;u4E00'..'#92;u9FA5'|'#92;uF900'..'#92;uFA2D'|'a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'#92;u4E00'..'#92;u9FA5'|'#92;uF900'..'#92;uFA2D')*;其中不少xbase支持的规则如XBlockExpression, 就是Java块, 如:    return Hello World + !小结这个教程中演示的语法定制程度似乎有限, 在深入学习xtext语法规则描述语言(The Grammar Language)和xbase之前, 还不能确认能够支持多么自由的语法定义. 但暂时没想到什么肯定能不到的语法规则(未把不带空格语法考虑在内). 感觉工具的一些错误反馈信息不那么易懂, 使用过程中感觉不那么结实. 但至少应该可以用于语言原型的快速开发."
    } ,
  
    {
      "title"    : "Xtext试用: 快速实现简单领域专用语言(DSL)",
      "category" : "语言设计, DSL",
      "description" : "利用Xtext实现中文语法的简单DSL. Use Xtext to create simple DSL with Chinese grammar.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/dsl/2018/01/19/Xtext%E8%AF%95%E7%94%A8-%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E9%A2%86%E5%9F%9F%E4%B8%93%E7%94%A8%E8%AF%AD%E8%A8%80(DSL).html",
      "date"     : "2018-01-19 00:00:00 -0700",
      "content"  : "环境搭建使用的Eclipse版本: Oxygen.1a Release (4.7.1a) Build id: 20171005-1200, 通过添加Xtext - Download上列出的Releases update site安装xtext IDE和xtext SDK. 之后打开Eclipse, 打开任何文件就报错:An error has occurred. See error log for more details.loader constraint violation: loader (instance of org/eclipse/osgi/internal/loader/EquinoxClassLoader) previously initiated loading for a different type with name org/aspectj/runtime/internal/AroundClosure为避免现有插件和它的冲突, 新安装了更新版Eclipse: Version: Oxygen.2 Release (4.7.2) Build id: 20171218-0600官方教程原代码试用首先, 参考官方教程: 15 Minutes Tutorial教程按部就班, 基本没有问题. 唯一碰到的坑是最后将一个dsl文件拆分成多个时, 发现需要将项目转换为xtext project才能支持(Xtext cross-reference across all files in project)接着的第二个教程: 15 Minutes Tutorial - Extended, 问题多了些.“Unit Testing the Language”部分中的文件在.tests项目的src/中, 只有个小坑. 下面的parser就是原来模板文件中的parseHelper    val model = parser.parse(            entity MyEntity                 parent: MyEntity            )“Creating Custom Validation Rules”部分中的checkFeatureNameIsUnique 初一运行后, 在同一Entity内两个同名Feature没有报错, ==改为.equals()也无用. 细一看之后, 才发觉它是检查父子Entity内是否有同名Feature. 比如在Comment中添加’author’的Feature, 如期报错.这里感觉到xtend语言的特别, 发现它本身也是个JVM语言: Xtend - Modernized Java, 不过貌似远没有Kotlin的流行度(后发现本站的代码块语言选项中竟然有xtend).框架对中文的支持首先, 尝试生成中文关键词的DSL. 默认ID只包含英文,数字,下划线, 因此自定义IDENTIFIER,grammar org.example.domainmodel.Domainmodel with org.eclipse.xtext.common.Terminalsgenerate domainmodel http://www.example.org/domainmodel/Domainmodelimport http://www.eclipse.org/emf/2002/Ecore as ecoreDomainmodel:    (elements+=AbstractElement)*;PackageDeclaration:    '包' name=QualifiedName ''    (elements+=AbstractElement)*    '';AbstractElement:    PackageDeclaration | Type | Import;QualifiedName:    IDENTIFIER ('.' IDENTIFIER)*;Import:    '导入' importedNamespace=QualifiedNameWithWildcard;QualifiedNameWithWildcard:    QualifiedName '.*'?;Type:    DataType | Entity;DataType:    '数据类型' name=IDENTIFIER;Entity:    '类' name=IDENTIFIER ('扩展' superType=[Entity|QualifiedName])? ''    (features+=Feature)*    '';Feature:    (many?='复数')? name=IDENTIFIER ':' type=[Type|QualifiedName];    terminal IDENTIFIER: '^'?('#92;u4E00'..'#92;u9FA5'|'#92;uF900'..'#92;uFA2D'|'a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'#92;u4E00'..'#92;u9FA5'|'#92;uF900'..'#92;uFA2D')*;一个小问题. 由于IDENTIFIER开头支持下划线, Generate Xtext Artifacts时会警告如下, 但似乎不影响语言生成, 下划线开头支持也正确:error(208): ../org.example.mydsl/src-gen/org/example/domainmodel/parser/antlr/internal/InternalDomainmodel.g:571:1: The following token definitions can never be matched because prior tokens match the same input: RULE_IDerror(208): ../org.example.mydsl.ide/src-gen/org/example/domainmodel/ide/contentassist/antlr/internal/InternalDomainmodel.g:1258:1: The following token definitions can never be matched because prior tokens match the same input: RULE_ID另一个问题是, 语法规则中的规则名称不能用中文命名(比如Feature改为’性状’, PackageDeclaration改为’包声明’等), 否则在Generate Xtext Artifacts生成报错并中断:java.lang.RuntimeException: Problems running workflow org.xtext.example.mydsl.GenerateMyDsl: Problem parsing 'file:/Users/xuanwu/work/workspace-xtext/org.example.mydsl/../org.example.mydsl/src/org/xtext/example/mydsl/MyDsl.xtext':XtextSyntaxDiagnostic: null:10 extraneous input '包' expecting ':'经测试, DSL语言高亮在Eclipse中显示正确:并且生成Java Beans正确(需要将数据类型名称由上面的”字符串”改为”String”):另外, 经测试xtend也支持中文命名(节选DomainmodelValidator如下), 但由于xtext语法文件不支持中文标识符, 影响有限:Check    def void 检验子类无父类重名性状(Feature f)         var 父类 = (f.eContainer as Entity).superType        while (父类 !== null)             for (其他 : 父类.features)                 if (f.name == 其他.name)                     error(子类性状不能与父类中性状重名,                        DomainmodelPackage.Literals.FEATURE__NAME)                    return                                        父类 = 父类.getSuperType();            演示如下:以上xtext项目源码在program-in-chinese/xtext_tutorial_15_min_zh测试DSL项目源码: program-in-chinese/xtext_tutorial_15_min_zh初步小结长处:  工具本身和基本文档质量尚可, 基本功能(源码分析, 新代码生成), 上手还算快. 应该至少可以适用于简单DSL实验.  语法规则描述接近EBNF. 好像功能更多(equivalent BNF-grammar of grammar written in XText)短处:  最大问题是语法规则中标识符不能中文命名, 直接导致相关的代码生成器(generator)和验证器使用的多数API只能是英文(如上面的.name, .features).  Eclipse版本或者插件冲突问题需要规避  需要学习xtend语言, 虽然可能很像Java未尝试: 可否定制自动补全功能, 语法报错信息(比如下面)另外希望有机会继续尝试下一篇教程: Five simple steps to your JVM language"
    } ,
  
    {
      "title"    : "Antlr4实现简单语言之整数比较表达式",
      "category" : "语言设计",
      "description" : "为圈2语言, 添加整数比较功能. Add integer comparison to pretotype programming language quan2.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/01/17/Antlr4%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",
      "date"     : "2018-01-17 00:00:00 -0700",
      "content"  : "续上文Antlr4: 修改语法规则更接近普通BNF格式.例程为先=1为先 为2=gt; 返回false‘为’作为关键词, 与数字可以连写, 但必须与变量名用空格间隔:变量一=1变量二=2变量一×2为 变量二实现类似”求积表达式”语法规则模式, 添加如下:表达式    : 等同判断表达式;等同判断表达式    :   比较表达式    |   等同判断表达式 '==' 比较表达式    |   等同判断表达式 '为' 比较表达式    |   等同判断表达式 '!=' 比较表达式    |   等同判断表达式 '≠' 比较表达式    ;比较表达式    :   求和表达式    |   比较表达式 'lt;' 求和表达式    |   比较表达式 'gt;' 求和表达式    |   比较表达式 'lt;=' 求和表达式    |   比较表达式 'gt;=' 求和表达式    |   比较表达式 '≤' 求和表达式    |   比较表达式 '≥' 求和表达式    ;求和表达式  : 求积表达式  | 求和表达式 '+' 求积表达式  | 求和表达式 '-' 求积表达式  ;“定制访问器”中添加的部分如下, 由于语法规则模式相同, 构建树算法也相同: Override  public 节点 visit表达式(表达式Context 上下文)     return visit(上下文.等同判断表达式());    Override  public 节点 visit等同判断表达式(等同判断表达式Context 上下文)     return 以本身向右扩展为运算节点(上下文, 上下文.等同判断表达式(), 上下文.比较表达式());    Override  public 节点 visit比较表达式(比较表达式Context 上下文)     return 以本身向右扩展为运算节点(上下文, 上下文.比较表达式(), 上下文.求和表达式());    Override  public 节点 visit求和表达式(求和表达式Context 上下文)     return 以本身向右扩展为运算节点(上下文, 上下文.求和表达式(), 上下文.求积表达式());    Override  public 节点 visit求积表达式(求积表达式Context 上下文)     return 以本身向右扩展为运算节点(上下文, 上下文.求积表达式(), 上下文.最小表达式());  ...  private 节点 以本身向右扩展为运算节点(ParserRuleContext 上下文, ParserRuleContext 本身子节点, ParserRuleContext 扩展子节点)     节点 比较节点 = visit(扩展子节点);    if (本身子节点 == null)       return 比较节点;     else       return 构建运算节点(取运算符(上下文), 本身子节点, 比较节点);        // 第二个子节点为运算符  private 运算符号 取运算符(ParserRuleContext 原始表达式)     int 最后运算符 = ((TerminalNodeImpl) 原始表达式.getChild(1)).symbol.getType();    switch (最后运算符)       case 圈5Parser.T加:        return 运算符号.加;      case 圈5Parser.T減:         return 运算符号.減;      case 圈5Parser.T乘:      case 圈5Parser.T数乘:        return 运算符号.乘;      case 圈5Parser.T除:      case 圈5Parser.T数除:        return 运算符号.除;      case 圈5Parser.T相等:      case 圈5Parser.T为:        return 运算符号.相等;      default:        return null;      下面是需要细究的部分, 由于变量名包括了”为”字, 因此如果把这个词-“为”定义在”T变量名”之后, 词法分析就会有问题.T为: '为';另外, 如果不添加空格忽略规则, 如果代码里带空格, 也会词法分析错误. 加了此规则之后就支持”为先 为2”:T空格: [ ]+ -gt;skip;在”运行器”的”求值”方法中, 添加”相等”支持:case 相等: return 左结果 == 右结果;大于(等于), 小于(等于), 不等支持也是类似实现. 源码版本号: program-in-chinese/quan5"
    } ,
  
    {
      "title"    : "History in Threads: 火狐插件实现浏览历史按主题显示(树)",
      "category" : "命名, 项目",
      "description" : "用JavaScript实现的火狐插件, 代码中使用中文命名. 实现浏览历史按主题以树的形式显示. Firefox addon implemented in JavaScript, with Chinese naming, to show browsing history in threads.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E9%A1%B9%E7%9B%AE/2018/01/15/History-in-Threads-%E7%81%AB%E7%8B%90%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%8E%86%E5%8F%B2%E6%8C%89%E4%B8%BB%E9%A2%98%E6%98%BE%E7%A4%BA(%E6%A0%91).html",
      "date"     : "2018-01-15 12:00:00 -0700",
      "content"  : "History in Threads似乎是唯一一个业余项目里有确认用户的. 大部分JavaScript源码(300+行)也用了中文命名.插件功能很简单, 就是根据网页点击顺序生成树, 每个树可以认为是主题相关的. 比如, 从一个B搜索页A点开了其中一个页面B, 显示搜索结果时B就是A的子节点(如下图的”proglog nlp - 国内版 Bing”). 火狐浏览器对页面点击顺序的保存维护好像比Chrome好一些. 生成的树比较完整(相比Chrome版).最新版的界面很简陋(图源自源码库program-in-chinese/HistoryInThreads_WebExtension):这个”新版”是由于火狐浏览器旧API失效被逼出来的(port to WebExtensions · Issue #6 · nobodxbodon/HistoryInThreads). 顺便在主要算法部分改用了中文命名:  访问缓冲表.js: 主要数据结构  utils.js: 所有不依赖于浏览器API的方法, 包括树的生成, 搜索时间处理, 根据关键词高亮历史记录等等  history.js: 根据关键词获取所有可能相关的浏览历史. 由于新版火狐API除去了根据多个URL获取历史记录的功能(优化运行速度 · Issue #1 · program-in-chinese/HistoryInThreads_WebExtension), 只好搜索两次, 一次按照(搜索关键词+历史时间)搜索, 一次只按照历史时间搜索(多搜了很多, 只好用上面的缓冲表避免每次搜索时都搜几万项历史记录). 相关的部分代码如下:var 按关键词搜索历史 = function(关键词, 历史时间范围)     计时(调用前)    带关键词访问记录 = [];    未处理url数 = 0;    if (关键词 != null)       当前关键词 = 关键词;        if (当前时间范围 == null || !不需重新索引(历史时间范围, 当前时间范围))       无关键词访问记录 = [];      访问细节表 = ;      var 新回溯时间 = 取历史回溯时间(历史时间范围);      历史回溯时间 = 新回溯时间;      当前时间范围 = 历史时间范围;      // TODO: 如果先按关键词搜索, 如果没有匹配, 可以省去搜索所有历史      // 首先搜索所有浏览历史      var 无关键词搜索选项 = 生成搜索选项('', 历史回溯时间);          var 无关键词搜索 = browser.history.search(无关键词搜索选项);      无关键词搜索.then(遍历无关键词历史记录);     else       var 带关键词搜索选项 = 生成搜索选项(当前关键词, 历史回溯时间);      var 带关键词搜索 = browser.history.search(带关键词搜索选项);      带关键词搜索.then(遍历带关键词历史记录);    ;最近疏于插件开发. 如有兴趣参与, 欢迎联系."
    } ,
  
    {
      "title"    : "Antlr4: 修改语法规则更接近普通BNF格式",
      "category" : "语言设计",
      "description" : "为圈2语言, 修改语法定义规则接近BNF格式. Modify grammar definition of pretotype programming language quan2 to make it closer to BNF format.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/01/15/Antlr4-%E4%BF%AE%E6%94%B9%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%E6%9B%B4%E6%8E%A5%E8%BF%91%E6%99%AE%E9%80%9ABNF%E6%A0%BC%E5%BC%8F.html",
      "date"     : "2018-01-15 00:00:00 -0700",
      "content"  : "经 沈默 在上文Antlr4添加中文变量赋求值,括号,各种问题评论中指出, 语法规则描述依赖于Antlr4生成的语法分析器的默认分析方法, 比如运算符的左联系, 以及优先级处理等等. 于是将语法修改为下面(源码版本号: program-in-chinese/quan5):表达式: 求积表达式 (('+'|'-') 求积表达式)*;求积表达式: 最小表达式 (('*'|'/'|'×'|'÷') 最小表达式)*;最小表达式  : 字面量  | '(' 表达式 ')'  ;字面量  : T数  | T变量名  ;这样做的结果是, Antlr4会分析生成一个多叉树. 比如 1+2-3, 生成树如下:于是在生成抽象语法树时手动转换为二叉树. 代码如下:private 节点 构建二叉树(Listlt;ParseTreegt; 子节点)     if (子节点.isEmpty())       return null;     else if (子节点.size() == 1)       return visit(子节点.get(0));     else       ParseTree 最后运算符节点 = 子节点.get(子节点.size() - 2);      运算符号 运算符 = ((TerminalNodeImpl)最后运算符节点).symbol.getType() == 圈5Parser.T加 ? 运算符号.加 : 运算符号.減;      运算式节点 节点 = new 运算式节点();      节点.运算符 = 运算符;      节点.左子节点 = 构建二叉树(子节点.subList(0, 子节点.size() - 2));      节点.右子节点 = visit(子节点.get(子节点.size() - 1));      return 节点;      开发过程中发现一些坑(如果是小白错误请指出). 一个比较费解的是, 不能省去”字面量”规则如下:最小表达式  : T数  | T变量名  | '(' 表达式 ')'  ;不然生成的分析器会有编译错误:com/中文编程/圈5/分析器/圈5Parser.java:403: error: unreachable statement                enterOuterAlt(_localctx, 3);Antlr4有个github库汇集了社区维护的各种语言的语法规则文件, 其中有Java8, 根据注释说明它的语法规则描述”极度”接近Java标准, 于是参考了它的实现. 其中看到这样的模式(已转成中文):求和表达式    :    求积表达式    |    求和表达式 '+' 求积表达式    |    求和表达式 '-' 求积表达式    ;求积表达式    :    最小表达式    |    求积表达式 '*' 最小表达式    |    求积表达式 '/' 最小表达式    ;感觉这样会让语法树转换这一步的实现更加方便(应该可以省去多叉树转换成二叉树的那个递归算法). 在添加新功能之前, 打算尝试修改成这样.已完成:表达式  : 求积表达式  | 表达式 '+' 求积表达式  | 表达式 '-' 求积表达式;求积表达式  : 最小表达式  | 求积表达式 '*' 最小表达式  | 求积表达式 '/' 最小表达式  | 求积表达式 '×' 最小表达式  | 求积表达式 '÷' 最小表达式;的确省去了多叉树转换. 代码整理完毕(program-in-chinese/quan5). 接下去, 是条件判断还是函数定义?补记Antlr4自带的语法分析可视化工具, 以antlr/grammars-v4为例: alias grun='java -cp PATH_TO_antlr-4.7-complete.jar:CLASSPATH org.antlr.v4.runtime.misc.TestRig' java -cp PATH_TO_antlr-4.7-complete.jar:CLASSPATH org.antlr.v4.Tool -visitor  -no-listener Java8.g4  javac -cp PATH_TO_antlr-4.7-complete.jar:CLASSPATH Java8*.java grun Java8 expression -tree lt;--- 将输入字符串进行语法解析, 生成树结构Warning: TestRig moved to org.antlr.v4.gui.TestRig; calling automaticallyagt;1(expression (assignmentExpression (conditionalExpression (conditionalOrExpression (conditionalAndExpression (inclusiveOrExpression (exclusiveOrExpression (andExpression (equalityExpression (relationalExpression (relationalExpression (shiftExpression (additiveExpression (multiplicativeExpression (unaryExpression (unaryExpressionNotPlusMinus (postfixExpression (expressionName a)))))))) gt; (shiftExpression (additiveExpression (multiplicativeExpression (unaryExpression (unaryExpressionNotPlusMinus (postfixExpression (primary (primaryNoNewArray_lfno_primary (literal 1))))))))))))))))))) grun Java8 expression -gui lt;--- 图形化Warning: TestRig moved to org.antlr.v4.gui.TestRig; calling automatically2gt;1^D"
    } ,
  
    {
      "title"    : "Antlr4添加中文变量赋求值,括号,各种问题",
      "category" : "语言设计",
      "description" : "为圈2语言, 添加变量赋值和求值, 括号, 以及出现的各种问题. Add assigning value, parenthesis features to the pretotype programming language quan2 with Antlr4 and Java, and related issues.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/01/12/Antlr4%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E5%8F%98%E9%87%8F%E8%B5%8B%E6%B1%82%E5%80%BC,%E6%8B%AC%E5%8F%B7,%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98.html",
      "date"     : "2018-01-12 00:00:00 -0700",
      "content"  : "中文编程知乎专栏原文地址例程(更多测试用例在此):基数=100基数×(基数+1)÷2=gt; 求值为5050续上文Antlr4实现数学四则运算, 修改的语法规则部分:程序: 声明+;声明: 表达式 T新行             #求值  | T变量名 '=' 表达式 T新行    #赋值  | T新行                    #空行  ;表达式: 表达式 运算符=('*'|'/'|'×'|'÷') 表达式     #乘除  | 表达式 运算符=('+'|'-') 表达式         #加減  | T数                    #数  | T变量名                #变量  | '(' 表达式 ')'        #括号  ;T变量名: ('a' .. 'z' | 'A' .. 'Z' | '#92;u4E00'..'#92;u9FA5' | '#92;uF900'..'#92;uFA2D')+;T新行: '#92;r'?'#92;n';很明显, 变量名的范围仍需扩展, 比如数字就不支持, 而且这个字符范围应该有些过大(详见Validate a JavaScript function name), 待修正(变量字符范围 · Issue #1 · program-in-chinese/quan5).定制访问器添加的部分:private static Maplt;String, 节点gt; 变量值表 = new HashMaplt;gt;();  // 以下为声明部分  Override  public 节点 visit赋值(赋值Context 上下文)     String 变量名 = 上下文.T变量名().getText();    变量值表.put(变量名, visit(上下文.表达式()));    return null;    Override  public 节点 visit求值(求值Context 上下文)     return visit(上下文.表达式());    // 以下为表达式部分  Override  public 节点 visit变量(变量Context 上下文)     String 变量名 = 上下文.T变量名().getText();        // TODO: 添加变量检查    return 变量值表.get(变量名);    Override  public 节点 visit括号(括号Context 上下文)     return visit(上下文.表达式());  变量值表采用变量名到节点的映射, 也就是在对包含这个变量的表达式求值时才对变量对应的表达式进行求值. 这里没有对变量赋值表达式进行语法树构建 · Issue #2 · program-in-chinese/quan5, 还需更多工作. 另外一个问题, 最后的表达式求值也会对变量值重复计算. 举例:利率=1年增长率=1+利率1000×年增长率×年增长率最后语法树如下:“年增长率”应该提前求值, 以省去最后的多次计算(避免对变量重复求值 · Issue #3 · program-in-chinese/quan5)后两个问题已初步解决, 通过在”运行器”中保存变量表, 以及将各种节点的求值方法都集中到其中. 想起来在其他有些语言实现里也看到过类似结构(根据不同类型进行求值): public Object 求值(节点 节点)     if (节点 instanceof 运算式节点)       运算符号 运算符 = ((运算式节点)节点).运算符;      Object 左结果 = 求值(((运算式节点)节点).左子节点);      Object 右结果 = 求值(((运算式节点)节点).右子节点);      switch(运算符)         case 加: return (int)左结果 + (int)右结果;        case 減: return (int)左结果 - (int)右结果;        case 乘: return (int)左结果 * (int)右结果;        case 除: return (int)左结果 / (int)右结果;        case 赋值:          变量值表.put(((变量节点)((运算式节点)节点).左子节点).取变量名(), 右结果);          // 顺延        default:          return null;           else if (节点 instanceof 变量节点)       return 变量值表.get(((变量节点)节点).取变量名());     else if (节点 instanceof 数节点)       return ((数节点)节点).求值();     else       for(节点 子节点 : 节点.子节点)         返回值 = 求值(子节点);            return 返回值;      "
    } ,
  
    {
      "title"    : "Antlr4实现数学四则运算",
      "category" : "语言设计",
      "description" : "为圈2语言, 添加四则运算功能. Add add/plus and mutiple/divide features to the pretotype programming language quan2 with Antlr4 and Java.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/01/11/Antlr4%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%A6%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97.html",
      "date"     : "2018-01-11 12:00:00 -0700",
      "content"  : "中文编程知乎专栏原文地址基本参考https://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference 一书”Building a Calculator Using a Visitor”一节, 仅添加了数学乘除法符号的支持(×÷). 比如下面的算式:3×2+8÷4-2×4源码仍在program-in-chinese/quan5            相比上一版本语法文件去除了空格定义. 需要深究的是优先级问题. 是否因为”表达式 运算符=(‘*’      ’/’      ‘×’      ‘÷’) 表达式”写在了前面才使得乘除法的优先级在语法分析时更高.      至此, 感觉Antlr语法文件对中文命名的支持还是不错的. 唯一需要权宜之计的就是Token(词)规则必须要大写开头, 因此采用了前缀”T”):grammar 圈5;程序 : 表达式 ;表达式 : 表达式 运算符=('*'|'/'|'×'|'÷') 表达式     #乘除   | 表达式 运算符=('+'|'-') 表达式         #加減   | T数                    #数 ;T数 : [0-9]+ ;T加 : '+';T減 : '-';T乘 : '*';T数乘: '×';T除 : '/';T数除: '÷';第一次尝试#标号的辅助功能. 一个”表达式”语法规则生成了三个Visitor方法(如下), 访问器仍比较简单. 注: 语法规则中要么所有分支都有标号, 要么都没有. 不然生成分析器时报错:public class 定制访问器 extends 圈5BaseVisitorlt;节点gt;   Override  public 节点 visit数(数Context 上下文)     TerminalNode 数 = 上下文.T数();    return 数 instanceof ErrorNode ? null : new 数节点(数.getText());    Override  public 节点 visit加減(加減Context 上下文)     表达式节点 节点 = new 表达式节点();    节点.运算符 = 上下文.运算符.getType() == 圈5Parser.T加 ? 运算符号.加 : 运算符号.減;    节点.左子节点 = visit(上下文.表达式(0));    节点.右子节点 = visit(上下文.表达式(1));    return 节点;    Override  public 节点 visit乘除(乘除Context 上下文)     表达式节点 节点 = new 表达式节点();    int 运算符 = 上下文.运算符.getType();    节点.运算符 = (运算符 == 圈5Parser.T乘 || 运算符 == 圈5Parser.T数乘) ? 运算符号.乘 : 运算符号.除;    节点.左子节点 = visit(上下文.表达式(0));    节点.右子节点 = visit(上下文.表达式(1));    return 节点;  语法树中稍微复杂一点的”表达式”节点, 代码很冗余:public class 表达式节点 extends 节点   public 运算符号 运算符;  Override  public Object 求值()     if (运算符.equals(运算符号.加))       return (int)(左子节点.求值()) + ((int)右子节点.求值());     else if (运算符.equals(运算符号.減))       return (int)(左子节点.求值()) - ((int)右子节点.求值());     else if (运算符.equals(运算符号.乘))       return (int)(左子节点.求值()) * ((int)右子节点.求值());     else if (运算符.equals(运算符号.除))       return (int)(左子节点.求值()) / ((int)右子节点.求值());     else       return null;      已经要手动跑十个测试文件, 下面除了清理代码, 还需要加测试, 再加功能(应该是变量赋值)."
    } ,
  
    {
      "title"    : "Antlr4的分析错误处理",
      "category" : "语言设计",
      "description" : "在之前的圈2语言基础上, 添加错误处理. Add exception handling for the pretotype programming language quan2 with Antlr4 and Java.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/01/11/Antlr4%E7%9A%84%E5%88%86%E6%9E%90%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",
      "date"     : "2018-01-11 00:00:00 -0700",
      "content"  : "中文编程知乎专栏原文地址(前文通用型的中文编程语言探讨之一: 高考, 即使是这”第一步”, 即使一切顺利达到列出的功能恐怕也需要个人数年的业余时间. 看到不少乎友都远更有资本和实力更快速地完成这一工程. 希望随时告知类似项目, 省得在下作无用功)初步打算用Antlr4生成Java实现的词语法分析器, 主要是出于减少工作量的考虑, 但相应的需要深入学习这个工具. 根据至今看到的相关文档以及Antlr项目本身, 感觉还蛮实用, 可持续性也不错, 这些学习应该不会白费.之前没有实验过它对错误语法的处理. 本文实现了编程语言试验之Antlr4+Java实现”圈2”的Visitor版本. 再添加了定制的词法语法错误处理. 源码在program-in-chinese/quan5语法最简单, 只包含一个数:grammar 圈5;程序   : T数;T数 : [0-9]+ ;T空白     : [ #92;n#92;t]+ -gt; skip;定制的语法错误处理器, 只有报告功能:public class 语法错误监听器 extends BaseErrorListener   Override  public void syntaxError(Recognizerlt;?, ?gt; 识别器, Object 问题符号, int 行, int 字符在行中位置, String 信息,      RecognitionException 例外)     Listlt;Stringgt; 规则栈 = ((Parser) 识别器).getRuleInvocationStack();    Collections.reverse(规则栈);    System.err.println([语法错误] 规则栈:  + 规则栈);    System.err.println(行 + 行 + 列 + 字符在行中位置 + 非法符号:  + 问题符号 + . 原始原因: + 信息);  下面是为语法分析器添加定制的错误分析(先除去默认的错误监听器):    圈5Parser 语法分析器 = new 圈5Parser(new CommonTokenStream(词法分析器));    语法分析器.removeErrorListeners();    语法分析器.addErrorListener(语法错误处理);类似的也可以为词法分析器添加错误处理器. 其中为了取得错误的词, 没有找到现成的接口, 于是摘取了它源码一部分. 初步的感觉是, 虽然API不一定很完善(很有可能是自己不熟悉工具导致的), 但不少公开属性可以比较方便定制:public class 词法错误监听器 extends BaseErrorListener   Override  public void syntaxError(Recognizerlt;?, ?gt; 识别器, Object 问题符号, int 行, int 字符在行中位置, String 信息,      RecognitionException 例外)     Lexer 词法分析器 = (Lexer)识别器;        // 摘自org.antlr.v4.runtime.Lexer.notifyListeners    String 文本 = 词法分析器._input.getText(Interval.of(词法分析器._tokenStartCharIndex, 词法分析器._input.index()));    String 错词 = 词法分析器.getErrorDisplay(文本);    System.err.println([词法错误] 行 + 行 + 列 + 字符在行中位置 + 错误词:  + 错词);  下面是一个语法有误的文件:   a分析后的报错输出:[词法错误] 行2列3错误词: a[语法错误] 规则栈: [程序]行2列4非法符号: [0,5:4='lt;EOFgt;',lt;-1gt;,2:4]. 原始原因:missing T at 'lt;EOFgt;'"
    } ,
  
    {
      "title"    : "通用型的中文编程语言探讨之一: 高考",
      "category" : "语言设计",
      "description" : "由高考开设编程科目说开去, 设想一种通用型的中文编程语言. As university entrace exam in China starts to include programming, here we discuss about a general-purpose programming language in Chinese.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/01/05/%E9%80%9A%E7%94%A8%E5%9E%8B%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%A2%E8%AE%A8%E4%B9%8B%E4%B8%80-%E9%AB%98%E8%80%83.html",
      "date"     : "2018-01-05 00:00:00 -0700",
      "content"  : "在可预见的未来, 高考仍是最重要的也最有社会影响力的人才选拔机制. 很久没有关注, 最近得知高考自选科目中开始增加了编程一项(见如何评价2017浙江高考七选三科目中包含技术？). 虽然个人对编程是否应该进入高考仍有保留看法, 但至少全民(都应该可以)编程这一趋势已经很明显了. 这应该是中文编程兴起的另一个契机(前文中文编程兴起的必然性讨论了一些更技术性的原因).看了2017年浙江的高考卷, 感觉算法/体系/基础知识比较少, 比较偏技术. 相信以后会逐渐调整. 毕竟技术更新快, 而前者更经得起时间考验也更有含金量. 个人觉得算法在短期内仍需要一个具体的编程语言作为载体, 毕竟教学实践中不可能作纯粹的纸上算法. 那么, 一个适合算法设计和实践的中文编程语言, 假如能在高考卷中使用, 相信会是一个中文编程的里程碑.本文试图列出一些(当然绝不是全部)这一假想中的语言/开发环境的功能特性和示例, 希望抛砖引玉. 其中, 对每项功能的必需性按照一到三排列, 一最高.版权/安全  [一] 必须从开始就理清所有依赖库的版权问题, 为商用扫清顾虑  [一] 杀毒软件不能误报功能/API  [一] 可以实现所有现有语言能够完成的功能. (注: 评论指出’所有’一词有歧义. 这里原意是指它附带的API以及可使用的第三方库的功能能够覆盖大多数应用场景) 如果这一语言的主要用途只是教学(比如LOGO), 那么它应该很难被选择为教学用的语言, 毕竟现在大环境是实用至上. 因此, 即使它本身(核心库)的功能比较局限, 只要可以无缝集成其他通用语言 (比如可以调用Java库的wkgcass/Latte-lang)即可.  [一] 支持64位系统, 跨平台(Windows/Linux/Mac), 最好支持移动平台(即使不能, 最好提供基本的在线编程环境)  [二] 常用功能需要中文API, 即使是封装现有API也可. 在高考题中可以看到还是不少与UI和I/O有关, 中文化争取早日覆盖常用API.语法设计(将在program-in-chinese/overview持续改进和更新)  [一] 相对英文编程语言的直译, 语法应更接近中文自然语言语法, 并且包含的特殊符号尽量使用数学常用符号. 比如下面一种设想的语言(欢迎拍砖!), 与Python的二分查找对比.                  选择作为函数体边界, 因为数学定义中常用左大括号(如下). 暂时没有想到比添上右大括号更合适的设计. 至于是否允许省略, 倾向于不允许, 以规避歧义. 另一种可能是类似日语编程语言”抚子” - 第三版特色初探, 不用而是使用关键词作为结束标志(“直到这里”之类)            缩进量不改变语义, 仅为改进可读可选: 为避免意外的缩进错误导致的语义错误      用’为’替代==, 为避免误写为=导致的无心之失. 在数学中, =的相等意义与赋值更接近. 数学中gt;, lt;作为判断条件使用, 与代码中意义相同, 适合沿用. 至于’大/小于等于’, ‘不等于’, 个人倾向于直接用≥, ≤, ≠符号. 而不用gt;=, lt;=, !=. 至少搜狗还算容易打出, 虽然效率挺低. (后得知易语言IDE也会自动将gt;=格式化为≥)      避免//这种数学中没有的符号, 用’向下取整’是可读性优先于简短性      数组/列表下标用(), 因为它们其实是索引/下标的函数, 类似Scala设计      [三] 是否用带空格设计, 个人认为不用强求(取决于技术可行性). 下面的语法如果不带空格, 也许会貌似自然语言而语法不够自然. 当然欢迎提出不带空格的示例程序!      断句是否用换行或者特殊符号, 个人倾向于避免引入额外符号      调用对象中的方法, 没有想到比”某实例.某方法(..)”之外的方案, 去掉”.”分隔符同样会有不带空格设计类似问题, 从而间接添加了方法命名的限制      支持全/半角. 选择有, 开发环境在编辑源码时就对源码自动转换到一种格式, 或者编译时自动转换到一种格式. 个人现在感觉前者更能使源码格式统一, 但开发环境和编译器的耦合度恐怕更高. 易语言好像采用前者, 日语编程语言”抚子”-第三版实现初探好像采用后者.      定义 二分查找(数组, 目标)   左索引 = 0  右索引 = 取长度(数组) - 1  位置 = -1  当 左索引 ≤ 右索引 且 位置 为 -1     中索引 = 向下取整((左索引 + 右索引) / 2)    如果 数组(中索引) 为 目标       位置 = 中索引     否则       如果 数组(中索引) gt; 目标         右索引 = 中索引 - 1       否则         左索引 = 中索引 + 1              返回 位置Python:def binarySearch(array, key):    left = 0    right = len(array) - 1    res = -1    while left lt;= right and res == -1:        mid = (left + right) // 2        if array[mid] == key:            res = mid        else:            if array[mid] gt; key:                right = mid - 1            else:                left = mid + 1    return res性能  [一] 为了适合算法实践, 代码的运行能如实反映算法复杂度  [二] 绝对性能的优先级至少在前期不高, 最好做到与主流脚本语言性能在一个量级开发环境  [一] 界面是中文  [一] 所有反馈信息首先有中文版  [一] 编辑辅助功能: 代码补全和自动格式化  [一] 调试功能: 断点调试  [一] 完备集成最新的语言和核心库文档, 并方便在开发过程中查阅  [二] 集成定制的输入法, 为中文代码输入进行特殊优化  [二] 开发环境/语言/核心库版本都可以在开发环境中直接更新  [三] 内置代码版本控制功能项目开展与维护  [一] 开源. 除了像M这样有历史积累的公司, 很难想象官方会倚靠一个刚起步的初创公司对这种需要中长期支持的语言/开发环境进行维护. 为了尽快完善语言和工具链, 也必需倚靠开源社区的力量.  [一] 源代码中尽量以中文命名, 因为目标受众是中文使用者, 自然开发社区也会以中文母语的开发者为主, 除了开发环境, 语言本身相关工具链对外部的依赖即使有也应该可以局限到独立模块, 因此中文命名的技术障碍不大.  [一] 用哪个语言实现, 需要结合功能特性综合考虑. 一些可能的选项: C#, Java, JavaScript/TypeScript一些相关讨论和参考:讨论: 适合中文用户的编程语言和IDE, 侧重于现有语言/IDE不具备的特性 · Issue #11 · program-in-chinese/overview"
    } ,
  
    {
      "title"    : "浅尝The Little Prover一书, 重逢Chez Scheme",
      "category" : "小结",
      "description" : "The Little Prover一书第一章的读后感, 示例代码用中文命名. 另测试Chez Scheme对中文命名的支持. Notes after reading the first chapter of the book 'The Little Prover', with sample programs using Chinese naming. Together with some notes of revisiting Chez Scheme.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/2018/01/04/%E6%B5%85%E5%B0%9DThe-Little-Prover%E4%B8%80%E4%B9%A6,-%E9%87%8D%E9%80%A2Chez-Scheme.html",
      "date"     : "2018-01-04 14:00:00 -0700",
      "content"  : "书开篇之前说, 本书的目标的一个例子: 证明(reverse (reverse x))对于任何列表x, 结果总是x.(安装Chez Scheme的200字请看最后)书刚开始, 就用到一个scheme中没有的函数atom和equal, 用中文定义应是如下:注: 多谢 张砸锅 指正, 下面的”为空?”不正确, 名称应该是”不是非空列表?”. 原文用atom一词, 就不直译了. 鉴于似乎不影响本文后面的例子, 恕我不一一纠正了.(define 为空?  (lambda (列表)    (if (atom? 列表)        'nil        't)))(define 相等?  (lambda (甲 乙)    (if (equal? 甲 乙)      't      'nil)))书的第一个例子是在甲乙的值未知时, 对下面表达式求值(相等? '那个啥 (为空? (cons 甲 乙))) (cons 甲 乙) 不论甲乙值为何, 都不会为空, 因此(为空? (cons 甲 乙))返回’nil. 而(相等? ‘那个啥 ‘nil)显然返回’nil, 因此这个表达式的值必定是’nil.这里”(为空? (cons 甲 乙))肯定返回’nil”被认为是Axiom(公理). 由这个公理推导出表达式的值.第八页列出了在Scheme”世界”里与cons相关的几个公理:(定义定律 cons不为空 (甲 乙)  (相等? (为空? (cons 甲 乙)) 'nil)(定义定律 car/cons (甲 乙)  (相等? (car (cons 甲 乙)) 甲)(定义定律 cdr/cons (甲 乙)  (相等? (cdr (cons 甲 乙)) 乙)之后就是equal相关的(交换律, 自身相等). 接下去是一系列基于这几个定律的推导演绎. 而推导演绎法则(?不知说法是否恰当)本身被定义为如下:  对定律 (定义定律 名称 (x1, x2, …xn) 定律内容), “定律内容”中的x1~xn可以被任何表达式e1~en替换, 得出的新定律只要符合格式(相等? p q)或者(相等? q p), q就可以被置换为p.举例如下:之前的定律car/cons(定义定律 car/cons (甲 乙)  (相等? (car (cons 甲 乙)) 甲)可以作用于下面表达式:(为空? (car (cons (car a) (cdr b))))只要把定律内容”(相等? (car (cons 甲 乙)) 甲)”, 把”甲”替换为(car a), “乙”替换为(cdr b)之后就得出:(相等? (car (cons (car a) (cdr b))) (car a))根据推导法, (car (cons (car a) (cdr b))) 等同于 (car a), 因此表达式等同于(为空? (car a))看起来有些绕, 因此作者提供了辅助推导工具the-little-prover/j-bob. 第一章完(共十章).感觉上是把定理以及推导的方法用代码表达, 进而赋予了程序证明定理的能力.为了运行书中的代码, 决定装Chez. 上次用好像还是在学校机房, 因为当时只有Petite Scheme是免费可以装在个人机器, 而Chez还是商业软件. 几年过去, Dybvig教授离职去了思科, 而Chez Scheme随后开源了(cisco/ChezScheme). 今天尝试了下载9.5版, 在Mac上编译生成了Petite和Chez(中间碰到了这个问题).运行后的提示即眼熟又生疏. 个人的力量毕竟有限, 不知道他一开始(1985年)就把Chez开源会不会改变今天的IT格局呢? 哪位开发者穿越回去试试改变历史吧. a6osx/bin/schemeChez Scheme Version 9.5Copyright 1984-2017 Cisco Systems, Inc.当然要尝试中文标识符, 蛮好:gt; (cons '火腿 '(鸡蛋))(火腿 鸡蛋)gt; (define 阶乘    (lambda (x)      (if (zero? x)          1          (* x (阶乘 (1- x))))))gt; (阶乘 3)6发现一个小问题, 在控制台下, 在输入后括号时, 匹配前括号的光标定位有错位, 猜测是由于中文字符的宽度不同导致的. 在之后使用中, 发现对上一个命令进行编辑也有显示问题. 这使得在交互环境中使用中文命名有了不小障碍(想想在上个程序基础上任何一点修改都要重新输入整个程序). 试着在源文件中编写’阶乘’函数后导入, 发现中文文件名也不支持(多谢 Eternal Chaos 指出, 已有问题报告command-line-arguments can’t read umlauts with utf-8 encoding · Issue #81 · cisco/ChezScheme), 不过导入成功.看了一点书之后发现…好像装了也不能直接用, 没有那个J-Bob好像基本上跑不了什么东西."
    } ,
  
    {
      "title"    : "烂尾工程: Java实现的汇编语言编译器",
      "category" : "命名, 项目",
      "description" : "一个半拉子工程, 用Java实现的汇编语言编译器的介绍. 代码中使用中文命名. An unfinished project, an assembler implemented in Java, with naming in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E9%A1%B9%E7%9B%AE/2018/01/03/%E7%83%82%E5%B0%BE%E5%B7%A5%E7%A8%8B-Java%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A8.html",
      "date"     : "2018-01-03 14:00:00 -0700",
      "content"  : "在半年前的中文编程的尝试历程小记中简单介绍了这一项目. 由于短期内估计不会继续进行, 而且这个项目好像是至今个人在中文命名实践中的代码量最大的一个项目, 谨在此作一小结. 最新的源码库在program-in-chinese/assembler-in-chinese-experiment.大致设计草图以’mov rax 0x1122334455667788’指令示例如下:当前进度  仅支持两个操作数的部分指令, 第二个操作数仅支持立即数  第一个操作数可以是寄存器,或者简单的内存寻址,如[0]  支持强制类型,如add ax,strict word 5  生成空可执行文件(PE), 尚未填入生成的二进制码源码结构下面是所有文件, 希望是一目了然? “分析器类”从单行汇编指令字符串分析生成”代码行类”, “汇编器类”从”代码行类”生成二进制码. 其他主要是业务数据描述(“模型”包)和功用(utils).假如要重新继续这一项目, 下面是一些想法:  考虑使用Antlr4, 用类似antlr/grammars-v4的语法文件辅助生成分析器, 省去手动编写分析器  最好有汇编和x64指令背景的开发者"
    } ,
  
    {
      "title"    : "中文编程专栏月报：2017年12月",
      "category" : "小结",
      "description" : "中文编程知乎专栏的2017年12月月度小结, 包括所有在下了解的中文编程相关项目进展. Monthly report of column Programming in Chinese for December 2017, together with other progresses in Github organization and other channels.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/2018/01/03/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E4%B8%93%E6%A0%8F%E6%9C%88%E6%8A%A5-2017%E5%B9%B412%E6%9C%88.html",
      "date"     : "2018-01-03 00:00:00 -0700",
      "content"  : "原文知乎地址: 中文编程专栏月报：2017年12月祝各位2018年好!上次月报末尾的下一步打算:  尝试在office软件插件中实现简单的中文编程(源自讨论)          基于官方文档Walkthrough: Creating Your First VSTO Add-in for Excel, 需要付费版的VS, 暂时不具备此条件. 而且国内其他开源版本的office应该使用率很低, 因此此方向暂不继续.        汉化编程语言关键词的推敲/整理          Java关键字的汉化用词探讨. 在评论中, 有建议参考易语言的关键字. 虽有打算, 但苦于手头没有易语言平台或者文档.        继续Z语言试用          尚未进行. Z语言最新版使用了结巴分词, 个人猜想是在词法分析中添加了自然语言分析, 还需进一步学习源码. 另外, 进行了日语编程语言”抚子”-第三版实现初探. 并且与日本作者进行了初步交流(用中文!!), 不少母语编程的想法有共鸣.        继续编程语言原型实验          JavaScript实现ZLOGO: 用语法树实现多层循环. 这个JS实现ZLOGO的系列也许要暂告一段落. 个人仍然对JS实现的在线编程非常有兴趣, 但这个(2D绘制)领域没有什么个人的日常应用, 恐怕中短期内难以持续. 如有兴趣合作/创立相关或类似项目乐于帮忙. 打算重新开始简单易用的中文编程(脚本)语言原型 · Issue #33 · program-in-chinese/overview, 可能从个人常用的文件格式(如csv简单表格文件)的日常处理入手. 期待Scala/Java+Antlr的助力.        继续在现有常用框架中使用中文命名          FriceEngine试用与API中文化      基于把最常用的开源的英文API进行中文化 · Issue #9 · program-in-chinese/overview, 对PHP通用和专用框架初步试用        开发IDE插件支持根据拼音自动补全(功能参考这个插件, 实现参考官方文档)          作为准备工作, 尝试了语法高亮插件: 为新语言编写Visual Studio Code语法高亮插件. 但开发过程中, 感觉VSC对Language Server相关的示例代码和文档尚不完备, 暂不打算继续. 也许会调研一下Atom等其他框架.        就在前两天，很高兴得知新的开发中文编程工具的项目正在起步. 敬请期待试用文章.          该项目仍在完善中, 仍持续关注和测试. 一点初步的相关尝试: 手机编程环境初尝试-用AIDE开发Android应用      最近几篇文章有幸在其他专栏发布, 希望今后继续互通有无!"
    } ,
  
    {
      "title"    : "JavaScript实现ZLOGO: 用语法树实现多层循环",
      "category" : "语言设计",
      "description" : "基于JavaScript和Antlr4, 通过语法树实现多层循环. Use AST based on JavaScript and Antlr4 to achieve multi-level loops.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2018/01/02/JavaScript%E5%AE%9E%E7%8E%B0ZLOGO-%E7%94%A8%E8%AF%AD%E6%B3%95%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF.html",
      "date"     : "2018-01-02 00:00:00 -0700",
      "content"  : "照例先上演示弱效果图. 演示地址照旧:代码如下:开始  循环4次    循环4次      前进50      左转90度    到此为止  右转90度  到此为止结束如上文JavaScript实现ZLOGO子集: 测试用例末尾所言, 此文用Antlr进行代码分析生成语法树. 再通过语法树生成p5js绘制代码.Antlr支持两种代码分析方法, Visitor(监听者)和Visitor(访问者). SO上的问答Antlr4 Listeners and Visitors - which to implement?大致说明了区别. 基于有限的实践, 用Visitor方法生成语法树似乎在实现上更加方便. 尤其相比Creating a simple parser with ANTLR一文中使用监听者+栈来构建语法树.Antlr生成工具默认不生成Visitor, 添加-visitor参数后可以生成:java -cp antlr-4.7-complete.jar:CLASSPATH org.antlr.v4.Tool -Dlanguage=JavaScript -visitor 圈3.g4下面是”定制访问器.js”中构建语法树的部分, 看起来比实现前想的简单. 默认生成的’圈3Visitor’中, visitXX方法实现都是”this.visitChildren(ctx)”, 但那样会把所有的子节点返回值放进数组, 形成(至少这里是)多余的层次:定制访问器.prototype.visit程序 = function(上下文)   语法树 = 子节点: this.visit(上下文.声明());  return 语法树;;定制访问器.prototype.visit循环 = function(上下文)   return     类型: '循环',    次数: parseInt(上下文.T数().getText()),    子节点: this.visit(上下文.声明());;定制访问器.prototype.visit声明 = function(上下文)   return this.visit(上下文.getChild(0));;定制访问器.prototype.visit转向 = function(上下文)   var 方向 = 上下文.T转向().getText();  var 角度 = parseInt(上下文.T数().getText()) * (方向 === 左 ? 1 : -1);  return 类型: '转向', 参数: 角度;;定制访问器.prototype.visit前进 = function(上下文)   return 类型: '前进', 参数: parseInt(上下文.T数().getText());;上面的源码生成语法树大致如下所示. 实现上还有很多需要改进的, 比如’前进’和’转向’现在是两种’类型’, 但应该是一种; 根节点类型不应为空; 等等:下面是”编译.js”中基于语法树生成指令列表的方法, 之后就与之前一样根据指令列表生成p5js绘制函数(代码也不用修改).function 生成指令序列(节点)   var 指令序列 = [];  // TODO: 根节点类型不应为空  if (!节点.类型)     var 声明节点 = 节点.子节点;    for (var i = 0; i lt; 声明节点.length; i++)       Array.prototype.push.apply(指令序列, 生成指令序列(声明节点[i]));       else if (节点.类型 == 循环)     var 指令序列 = [];    for (var i = 0; i lt; 节点.次数; i++)       Array.prototype.push.apply(指令序列, 生成指令序列(子节点: 节点.子节点));       // TODO: 修改类型统一为'指令'  else if (节点.类型 == 前进 || 节点.类型 == 转向)     return [名称: (节点.类型 == 前进 ? 常量_指令名_前进 : 常量_指令名_转向), 参数: 节点.参数];    return 指令序列;修改相应测试用例, 以及清理不再使用的监听器代码后. 代码已从visitor分支(program-in-chinese/quan3)合并到master."
    } ,
  
    {
      "title"    : "Java关键字的汉化用词探讨",
      "category" : "语言设计, 汉化关键词",
      "description" : "讨论Java关键词的中文对应词语该如何选择. Discuss word choices for keywords in Chinese version for Java programming language.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E6%B1%89%E5%8C%96%E5%85%B3%E9%94%AE%E8%AF%8D/2017/12/26/Java%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%B1%89%E5%8C%96%E7%94%A8%E8%AF%8D%E6%8E%A2%E8%AE%A8.html",
      "date"     : "2017-12-26 00:00:00 -0700",
      "content"  : "狗屎咖啡 的为GCC添加中文关键字项目对C关键词进行了汉化. 风格比较简约, 如’if’-如, ‘else’-另. 个人感觉在中文编程语言尚未成熟之时, 不妨集思广益, 首先列出一些可选项, 然后从中选出一套或几套风格比较统一的. 这里列出了一些之前归纳的选项.本文基于此讨论组回复(中文化 C, C++, Objective-C 需要什么样的关键字? · Issue #40 · program-in-chinese/overview)尝试对Java关键词进行探讨. 可惜知乎文章不支持表格, 于是列出如下. 带*的如goto是Java实际并未使用的. 关键词的含义参考List of Java keywords, 加上一些有限的个人理解. 欢迎拍砖, 尤其是带问号的几个.多谢评论区中各位指摘, 下面有根据评论添加的部分, 恕在下不一一点名感谢了.abstract 抽象assert*** 确保 断言boolean 布尔 真假break 中止 断开 跳出byte 字节case 情况catch 一旦char 字符class 类 类型(评论中提到这与'type'含义重复) 类别const* 常量continue 继续default 默认do 运行 执行double 双浮点 双精度else 否则 不然enum**** 枚举extends 扩展 继承final 不变?finally 善后float 浮点 单精度for 对于goto* 跳转if 如果implements 实现import 导入 引用 引入instanceof 是. 这里暂时想不到其他更合适和准确的. 小黄 是 人类感觉还可以接受. 评论中有提出'类为', 可惜没包括interface部分, 也许'为'?int 整数 整型interface 接口long 长整数native 本地new 新建 新 实例化package 包private 私用 私有protected 保护?public 公用 公开return 返回short 短整数static 静态个人感觉直白但与实际用途有距离. 而且它反义的动态并没有对应的Java概念. Z语言中命名为唯一, 一定程度反映了它的特性. 个人暂时没想到更合适的.strictfp** (暂不理解)super 父类switch 开关 切换synchronized 同步this 本体 自身 本身throw 抛出. 强调的是抛出例外(Exception)的行为throws 会抛出. 强调的是会抛出某些例外的特性.transient 不序列化. 找不到合适的对应词语, 只能从功能上选词了.try 尝试void 无返回值volatile 易变 非同步? 不甚了解while (每)当 只要"
    } ,
  
    {
      "title"    : "为新语言编写Visual Studio Code语法高亮插件",
      "category" : "IDE, 插件",
      "description" : "为一个简单的实验编程语言编写Visual Studio Code插件, 实现语法高亮. Develop a plugin for Visual Studio Code, to achieve syntax highlight for a simple experimental programming language.",
      "tags"     : "",
      "url"      : "/ide/%E6%8F%92%E4%BB%B6/2017/12/24/%E4%B8%BA%E6%96%B0%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99Visual-Studio-Code%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%8F%92%E4%BB%B6.html",
      "date"     : "2017-12-24 20:00:00 -0700",
      "content"  : "本文源码库: program-in-chinese/quan4-highlighter语法高亮是一个开发环境的基本功能. 此文尝试为之前的”圈4”语言(详见编程语言试验之Antlr4+JavaScript实现圈4)编写一个高亮插件, 仅为演示之用. 参考的是Visual Studio Code官方文档: Add Themes, Snippets and Colorizers to Visual Studio Code. 首先创建插件如下, 为”.圈4”的源文件添加高亮: yo code     _-----_     ╭──────────────────────────╮    |       |    │   Welcome to the Visual  │    |--(o)--|    │   Studio Code Extension  │   `---------´   │        generator!        │    ( _´U`_ )    ╰──────────────────────────╯    /___A___#92;   /     |  ~  |        __'.___.'__    ´   `  |° ´ Y ` ? What type of extension do you want to create? New Language SupportEnter the URL (http, https) or the file path of the tmLanguage grammar or press ENTER to start with a new grammar.? URL or file to import, or none for new: ? What's the name of your extension? 圈4高亮? What's the identifier of your extension? quan4-highlighter? What's the description of your extension? 圈4语言的VS Code插件? What's your publisher name (more info: https://code.visualstudio.com/docs/tools/vscecli#_publishing-extensions)? nobodyEnter the id of the language. The id is an identifier and is single, lower-case name such as 'php', 'javascript'? Language id: quan4Enter the name of the language. The name will be shown in the VS Code editor mode selector.? Language name: 圈4Enter the file extensions of the language. Use commas to separate multiple entries (e.g. .ruby, .rb)? File extensions: .圈4Enter the root scope name of the grammar (e.g. source.ruby)? Scope names: source.圈4   create quan4-highlighter/syntaxes/quan4.tmLanguage.json   create quan4-highlighter/.vscode/launch.json   create quan4-highlighter/package.json   create quan4-highlighter/README.md   create quan4-highlighter/CHANGELOG.md   create quan4-highlighter/vsc-extension-quickstart.md   create quan4-highlighter/language-configuration.json   create quan4-highlighter/.vscodeignore   create quan4-highlighter/.gitignoreYour extension quan4-highlighter has been created!默认语法文件syntaxes/quan4.tmLanguage.json中, 关键词的模式匹配为:match: #92;#92;b(if|while|for|return)#92;#92;b直接改为:match: 求约数运行插件后(F5新运行, Command+R可以在插件修改后刷新)实现:很明显它是最直接的正则表达式匹配. 还不确定是否能做到空格敏感, 以及语法检验.这只是第一步, 之后还需对语法定义格式(TextMate Manual amp; Language Grammars)进行深入学习."
    } ,
  
    {
      "title"    : "手机编程环境初尝试-用AIDE开发Android应用",
      "category" : "命名",
      "description" : "尝试用AIDE在Android手机环境中开发最简单的Android应用. Develope a simple Android app using AIDE running on Android phone.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2017/12/24/%E6%89%8B%E6%9C%BA%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%88%9D%E5%B0%9D%E8%AF%95-%E7%94%A8AIDE%E5%BC%80%E5%8F%91Android%E5%BA%94%E7%94%A8.html",
      "date"     : "2017-12-24 00:00:00 -0700",
      "content"  : "前不久才接触到纯粹用手机进行编程的开发者, 当时颇有孤陋寡闻之感, 因为之前听说过手机编程还是一些在线编程学习网站开发的学习环境, 没有想过真的有用它做实际开发的. 此文用AIDE免费版在自己的手机上做一个最简单的应用, 参考的是AIDE官方的入门文档: AIDE - Android IDE.安装AIDE 3.2.171025(免费版)后, 选择在下面路径新建项目/Create new project(这个路径是Git客户端工具SGIT 1.3.3.final的默认git clone导出路径):弹出项目类型选择:选择New Android App后:找了一下string/hello_world定义的位置, 发现在:选择”运行”后, 结果正如预期:为检验中文命名的支持度, 将字符串键值改为了”string/问好”, 并在strings.xml中相应修改. 编译运行无误, 但开始在main.xml中的lt;TextView下有个红线警告, 也许只是延迟. 再次打开后警告消失. Java的中文命名自然支持, 就没有尝试.总的感觉开发过程比较流畅, 虽然每每有付费专业版的弹窗, 但也无可厚非.AIDE的下载量有百万之多, 让我感到手机编程环境的日益普及. 确实随着屏幕变大变清晰, 系统性能的提升, 手机现今已经离开发用机越来越近. 在手机拥有率已经远超电脑(而且不会逆转)的时代, 相信这种”移动”开发的实践只会越来越多. 新的编程语言工具对此的支持也会越来越完善, 比如之前的日语编程语言”抚子” - 第三版特色初探“对移动设备和输入法的特别优化”一节."
    } ,
  
    {
      "title"    : "日语编程语言&quot;抚子&quot;-第三版实现初探",
      "category" : "语言设计",
      "description" : "对第三版抚子语言的源代码进行初步学习. Study the source code of the 3rd version of Japanese programming language Nadesiko.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/12/22/%E6%97%A5%E8%AF%AD%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80_%E6%8A%9A%E5%AD%90_%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E7%8E%B0%E5%88%9D%E6%8E%A2.html",
      "date"     : "2017-12-22 00:00:00 -0700",
      "content"  : "前文日语编程语言”抚子” - 第三版特色初探仅对语言的语法进行了初步了解. 之前的语言原型实现尝试(如编程语言试验之Antlr4+JavaScript实现”圈4”)之后, 感觉有必要学习”抚子”的实现, 因为它也內建支持在线编程, 应该很有借鉴价值.开发环境配置主要参考 kujirahand/nadesiko3.运行”npm start”后访问”localhost:3000”就有如下开发环境界面:它也支持生成基于Electron的可以本地运行的独立程序(在Mac下测试). 运行”npm run electron”后就看到与网络界面相同的程序界面. 感觉这个方式很合理. 之后希望尝试类似途径同时实现在线和本地开发环境.它也提供一个Atom插件, 安装后(拷贝目录到~/.atom/packages下)在Atom中打开test.nako3测试文件就有语法高亮:另: 运行”npm run test”时, 发现了一个关于时间处理的bug. 将继续跟进; 暂时没有发现断点调试等功能.源码学习在/src下, 源码文件不多, 分类如下, 连同基于源码和注释个人整理的简单介绍:  编译器主程序:          nako3.js      cnako.js: 支持命令行下运行      enoko.js: 支持electron      wnako3.js: 支持web browser-浏览器        分析器实现          nako_prepare.js: 全半角字符处理; 特殊字符串处理, 比如等      nako_lexer.js: 对已经是全角的代码进行词法分析, 包括保留关键字, 分词器等等      nako_parser_base.js: 显示语法错误, NakoParserBase类      nako_parser_const.js: 定义运算符的优先级, 以及日语助词(?), 如’いて’, ‘えて’等等      nako_parser3.js: 是NakoParserBase的扩展, 实施语法分析, 生成语法树      nako_gen.js: 从语法树生成JS类        插件(功能库)          plugin_browser.js: 浏览器相关功能封装成API, 如’言’是”window.alert”(对话弹窗)      plugin_node.js: Node.js常用功能封装, 如’開’是”readFileSync”(打开文件)      plugin_system.js: JavaScript本身常用API封装, 如”割余”是”ab”(求余)      plugin_turtle.js: 类似LOGO语言的基于”抚子”语言的脚本语言. 演示在ゼロからはじめてみる日本語プログラミング「なでしこ」(3) タートルグラフィックスでお絵かきしよう(その1)        其他          index.js: 用npm模块方式使用”抚子”      repl.nako3: 用”抚子”语言本身写的一个简单的对话执行环境      时间有限, 以后再对不同模块深入学习."
    } ,
  
    {
      "title"    : "FriceEngine试用与API中文化",
      "category" : "命名, API",
      "description" : "试用游戏引擎FriceEngine, 将常用API中文化. Try out game engine FriceEngine, and create corresponding Chinese APIs.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/api/2017/12/21/FriceEngine%E8%AF%95%E7%94%A8%E4%B8%8EAPI%E4%B8%AD%E6%96%87%E5%8C%96.html",
      "date"     : "2017-12-21 00:00:00 -0700",
      "content"  : "早先就听闻FriceEngine已有中文接口版本, 可惜没有机会尝试. 经原作者 大笨蛋千里冰封 (Github账号 ice1000 )建议, 在FriceEngine的DSL封装的接口基础上, 添加了对应的中文接口.下面的代码利用了新添的中文接口, 实现了一个圆形向方块加速撞击后反弹下落的动画过程(开发环境: IntelliJ IDEA社区版, 更全的测试用例在此, 是参考了原代码中的测试用例编写的):注: FriceEngine仍在活跃开发中, 本文的接口很可能在新版本中修改. 使用时请参考最新的测试代码.接口中文化过程在命名接口与参数时, 遇到不少需要推敲的问题:  英文接口中, (x,y)在不同地方有不同含义, 比如在形状(方形/圆形)属性中, 是定位功能(左上角顶点的坐标, 都为正数). 而在速度等接口中, 表示的是横向和纵向的分量, 可以为负. 在中文命名后, 进行了区别: 左上角x/左上角y和横向速度_左负右正/纵向速度_上负下正. 后者比较累赘, 而且也许应该在注释而不是命名中说明参数的正负意义, 但鉴于IntelliJ提供了独到的参数名提示功能, 就暂时把命名的含义最大化了.  之前对其他库中文化也碰到过. 对于重载接口, 暂时还是采用了赋值对应英文接口的方式, 但其实是可以用调用中文接口实现, 比如FObject.加速(x: Int, y: Int)调用FObject.加速(x: Double, y: Double). 这决定了中文化的”深度”. 但越”深”, 越涉及到实现, 维护的工作量就越大. 个人暂时倾向于尽量”浅”地进行中文化.  暂时是将中文接口的实现放在了对应英文接口的下面, 这样的好处是关联性一目了然, 但也让它们分散在各处, 带来一些维护的难度.另一种方式也许是至少将简单的对等接口抽取出来, 用一个数据结构描述(类似下面), 然后在编译之前自动生成这些接口的实现, 但这个脑洞比较大.    whenExit(block: () -gt; Unit) -gt; 当退出时(块: () -gt; Unit)ImageObject.url(s: String) -gt; ImageObject.远程文件(网址: String)...        其他感想    IntelliJ刚开始用, Kotlin和Gradle也是初学, 在使用和开发过程中遇到不少磕碰. 在此多谢原作者的各种协助与指点. Kotlin的语言特性也让添加中文接口的实现过程不那么费劲. 比较印象深刻的是对属性的get/set  相比之前尝试的p5js的动画绘制, 感觉FriceEngine的语法更加灵活, 有不少高层接口让开发更加方便, 比如每隔(毫秒数), 以及当碰撞(某物体名), 在p5js中好像没有类似功能, 使用时需要根据帧数和帧率用算法自行实现. 而且类OO的设计(对形状可以取名)也是p5js不具备的.  个人觉得API在形式上的一致性对易用性比较重要. 作为Kotlin新手, 个人在使用时开始有些语法上的困惑, 尤其是和()的使用. 比如代码中同时有加速(0, 50)和:    加速   横向加速度_左负右正 = 20.0         强烈建议改进动画性能, 过高的CPU占用会让推广受限, 尤其是手机app上."
    } ,
  
    {
      "title"    : "中文编程专栏月报：2017年11月",
      "category" : "小结",
      "description" : "中文编程知乎专栏的月度小结, 包括所有在下了解的中文编程相关项目进展. Monthly report of column Programming in Chinese, together with other progresses in Github organization and other channels.",
      "tags"     : "",
      "url"      : "/%E5%B0%8F%E7%BB%93/2017/12/11/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E4%B8%93%E6%A0%8F%E6%9C%88%E6%8A%A5-2017%E5%B9%B411%E6%9C%88.html",
      "date"     : "2017-12-11 00:00:00 -0700",
      "content"  : "原文知乎地址: 中文编程专栏月报：2017年11月之前Github讨论组有周报，但效果一般。从周报停更/知乎专栏创建到现在一个月，特此做一小结。也包含了github讨论组以及其他参与的社区/群组的进展。欢迎对今后方向和内容多提意见。专栏内不少文章和实践是创建之前积累的. 包括这个月的内容, 很多内容由他人贡献, 或有参与/指导/建议, 请恕在下就不在这里一一点名致谢了内容难免遗漏, 欢迎指出/分享!本月新添文章使用母语作为标识符的意义  Python3选择支持非ASCII码标识符的缘由希望各位有兴趣的可以找找其他语言支持Unicode的缘由相关的官方文档.汉化现有语言  为clang添加中文关键字  为Python添加中文关键字  如何使GCC支持中文(utf-8)的变量名、函数名？  为GCC添加中文关键字中文编程语言ZLOGO的试用  中英文代码对比之ZLOGO 4 amp; LOGO  中文编程语言之Z语言初尝试: ZLOGO 4Antlr辅助实现编程语言实验  JavaScript实现ZLOGO子集: 测试用例  JavaScript实现ZLOGO子集: 单层循环功能  JavaScript实现ZLOGO子集: 前进+转向  编程语言试验之Antlr4+JavaScript实现”圈4”  编程语言试验之Antlr4+Java实现”圈2”在现有语言/框架/工具中使用中文命名  中文代码示例之5分钟入门TypeScript  编写Visual Studio Code插件初尝试  在线编程网站对中文代码的支持  在LeetCode中的解答中使用中文命名  中文代码示例之Spring Boot 1.3.3演示  中文代码示例之Vuejs入门教程(一)问题后续综合讨论(时间倒序排列)  中文编程兴起的可能途径  汉化了十数个编译器的前辈的心得体会  对中文语法的编程语言的质疑与回应  中文编程的迷思  中文编程兴起的必然性  国人创造中文编程语言的优势  中文命名实践的阻力和应对其他发现单字富指令型中文（还加韩文）编程语言 Sclipting可能的下一步入手方向(未分先后):  尝试在office软件插件中实现简单的中文编程(源自讨论)  汉化编程语言关键词的推敲/整理  继续Z语言试用  继续编程语言原型实验  继续在现有常用框架中使用中文命名  开发IDE插件支持根据拼音自动补全(功能参考这个插件, 实现参考官方文档)  就在前两天，很高兴得知新的开发中文编程工具的项目正在起步. 敬请期待试用文章."
    } ,
  
    {
      "title"    : "中文代码示例之5分钟入门TypeScript",
      "category" : "命名, 教程",
      "description" : "将TypeScript官方入门文档的示例代码进行中文命名. Use Chinese naming in the sample programs in the 5-minute tutorial from official TypeScript language website.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2017/12/10/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8B5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8TypeScript.html",
      "date"     : "2017-12-10 00:00:00 -0700",
      "content"  : "Typescript官方文档起的这个噱头名字: TypeScript in 5 minutes, 虽然光看完文章就不止5分钟…走完整个文档流水账如下(代码编辑器用的是VS Code)源码在: program-in-chinese/typescript_in_5_min_zh第一个TypeScript程序function 问好(那谁)   return 吃了么,  + 那谁;let 路人 = 打酱油的;document.body.innerHTML = 问好(路人);运行tsc 问好.ts编译生成”问好.js”文件.添加参数类型function 问好(那谁: string)    return 吃了么,  + 那谁;如果’那谁’的类型不符, 比如是数组类型[0,1,2], 编译时会报错, 挺好:问好.ts(7,30): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.添加接口interface 人   姓: string;  名: string;function 问好(那谁: 人)   return 吃了么,  + 那谁.姓 + 那谁.名;let 路人 = 姓: 大, 名: 黄;这里路人的”形状”符合”人”, 类型就被判定为相符.自己误写成了:function 问好(那谁: 人)   return 吃了么,  + 人.姓 + 人.名;编译提示’人’是个类型而不是值, 挺好:问好.ts(7,20): error TS2693: '人' only refers to a type, but is being used as a value here.添加类class 学生   全名: string;  constructor(public 姓: string, public 名: string)     this.全名 = 姓 + 名;  interface 人   姓: string;  名: string;function 问好(那谁: 人)   return 吃了么,  + 那谁.姓 + 那谁.名;let 路人 = new 学生(大, 黄);官方文档说添加class之后编译生成的js文件与没有class的相同, 这里不解, 实验结果是不同的.运行第一个网络应用为了检验js文件, 添加HTML文件:lt;!DOCTYPE htmlgt;lt;htmlgt;    lt;headgt;lt;titlegt;TypeScript你好lt;/titlegt;lt;/headgt;    lt;bodygt;        lt;script src=问好.jsgt;lt;/scriptgt;    lt;/bodygt;lt;/htmlgt;最后一个插曲:html文件在Chrome中打开显示正确:  吃了么, 大黄但在火狐(Firefox)浏览器中打开时报错:The character encoding of the HTML document was not declared. The document will render with garbled text in some browser configurations if the document contains characters from outside the US-ASCII range. The character encoding of the page must be declared in the document or in the transfer protocol.E997AEE5A5BD.html将View-gt;TextEncoding从Western改为Unicode后显示正确.后感:tsc编译好慢!TypeScript代码看起来更好理解一点, 编译期的反馈信息对于减少错误很有用."
    } ,
  
    {
      "title"    : "JavaScript实现ZLOGO子集: 测试用例",
      "category" : "语言设计",
      "description" : "为ZLOGO子集JavaScript实现添加QUnit测试用例. Add test cases in QUnit for subset of ZLOGO in JavaScript",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/12/09/JavaScript%E5%AE%9E%E7%8E%B0ZLOGO%E5%AD%90%E9%9B%86-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html",
      "date"     : "2017-12-09 00:00:00 -0700",
      "content"  : "续前文JavaScript实现ZLOGO子集: 前进+转向. 在添加新功能之前, 先添加测试用例, 以应对日益复杂的代码.选择使用QUnit编写运行测试用例. 暂时对比较复杂和I/O无关的部分进行测试.一是代码分析部分: Antlr通过生成的分析器和定制的监听器, 对原始代码进行分析和生成指令序列的部分. 下面是对循环进行测试的一个用例:QUnit.test( 分析_循环_前进1, function( assert )   assert.deepEqual(    分析(开始#92;n循环2次#92;n前进50#92;n到此为止#92;n结束#92;n).返回指令序列(),    [名称: 常量_指令名_前进, 参数: 50,      名称: 常量_指令名_前进, 参数: 50],    循环2次通过! ););“生成路径表”将指令序列转换成路点序列(经过的转折点), 其中一个测试用例如下:QUnit.test( 生成路径表_前进_左转_前进, function( assert )   assert.deepEqual(    生成路径表([名称: 常量_指令名_前进, 参数: 50,              名称: 常量_指令名_转向, 参数: 90,              名称: 常量_指令名_前进, 参数: 50], 初始前进角度),    [起点: 路点0, 终点: 路点1, 长度: 50,    起点: 路点1, 终点: 路点2, 长度: 50],    通过! ););添加测试的过程中, 再次感受代码封装的重要性. 在测试目标接口中, DOM操作都需避免(比如document, window).虽然已经添加了多层循环的代码分析部分测试用例, 但在实现时, 感觉需要语法树以便于支持更复杂的语法. 另外在现在的代码里, 已经开始需要拆分模块(“定制监听器”比较杂乱).下面需要调研语法树相关的JS库, 比如: ajaxorg/treehugger另外, 发现TypeScript也可以利用Antlr: Creating ANTLR Applications in TypeScript - Dangl.Blog();"
    } ,
  
    {
      "title"    : "JavaScript实现ZLOGO子集: 单层循环功能",
      "category" : "语言设计",
      "description" : "用JavaScript实现ZLOGO的功能子集, 添加单层循环. Implement subset of ZLOGO using JavaScript, adding single-level loop",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/12/06/JavaScript%E5%AE%9E%E7%8E%B0ZLOGO%E5%AD%90%E9%9B%86-%E5%8D%95%E5%B1%82%E5%BE%AA%E7%8E%AF%E5%8A%9F%E8%83%BD.html",
      "date"     : "2017-12-06 00:00:00 -0700",
      "content"  : "前文JavaScript实现ZLOGO子集: 前进+转向的示例代码很累赘, 因此尝试实现基本的循环功能, 使得前面的11行代码缩减为7行:开始  循环4次    前进200    左转144度  到此为止  前进200结束源码和在线演示地址同前文.修改的语法描述(圈3.g4)不多, 应该已经支持多层循环:声明 : 前进 | 转向 | 循环;循环 : '循环' T数 '次' 声明+ '到此为止' ;但实现上, 暂时先做了单层. 就是将循环体内的指令存放起来, 在循环结束时, 把它们按循环次数重复添加到最终的指令序列中:// TODO: 支持多层循环var 循环次数 = 0;var 当前循环的指令序列 = [];...定制监听器.prototype.enter循环 = function(上下文)   循环次数 = parseInt(上下文.getChild(1).getText());定制监听器.prototype.exit循环 = function(上下文)   for (var i = 0; i lt; 循环次数; i++)     for (var j = 0; j lt; 当前循环的指令序列.length; j++)       指令序列.push(当前循环的指令序列[j]);        当前循环的指令序列 = [];  循环次数 = 0;定制监听器.prototype.exit前进 = function(上下文)   ...  添加指令(名称: 常量_指令名_前进, 参数: parseInt(前进量));;定制监听器.prototype.exit转向 = function(上下文)   ...  添加指令(名称: 常量_指令名_转向, 参数: 角度);;function 添加指令(指令)   if (循环次数 gt; 0)     当前循环的指令序列.push(指令);   else     指令序列.push(指令);  在实现多层循环之前, 打算先添加测试用例. 毕竟手动测试已经开始麻烦了."
    } ,
  
    {
      "title"    : "JavaScript实现ZLOGO子集: 前进+转向",
      "category" : "语言设计",
      "description" : "用JavaScript实现ZLOGO的功能子集, 并在线演示. Implement subset of ZLOGO using JavaScript, and setup online demo",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/12/05/JavaScript%E5%AE%9E%E7%8E%B0ZLOGO%E5%AD%90%E9%9B%86-%E5%89%8D%E8%BF%9B+%E8%BD%AC%E5%90%91.html",
      "date"     : "2017-12-05 00:00:00 -0700",
      "content"  : "在前文中文编程语言之Z语言初尝试: ZLOGO 4与相关讨论后, 萌生了用JavaScript编写类似语言以便在线编程的想法. 于是使用 TKT2016 (知乎账号)的ZLOGO语法设计, 在编程语言试验之Antlr4+JavaScript实现”圈4”基础上, 通过p5js的绘图功能, 实现了基本的两个ZLOGO功能. 如图(动态效果看起来更爽一点, 当然要耐心等它画完, 请自行尝试):源码库: program-in-chinese/quan3, 导出代码到本地后, 在浏览器中打开”圈3.html”即可在本地实践编程.在线演示: 地址.由于还不支持循环, 实现这个五角星的代码很重影:开始  前进200  左转144度  前进200  左转144度  前进200  左转144度  前进200  左转144度  前进200结束下面是编程语言试验之Antlr4+JavaScript实现”圈4”之后添加的主要部分:语法文件(圈3.g4):声明 : 前进 | 转向;前进 : '前进' T数 ;转向 :  T转向 '转' T数 '度' ;T转向 : '左' | '右' ;主要修改在”定制监听器.js”:命名还比较粗糙, 一些用语最好更加一致(比如”长度”,”距离”,”前进量”虽在不同上下文, 实际指的是一个东西), 需要改进. 当然算法肯定也可以改进, 暂时是实现功能优先.var 常量_指令名_前进 = 前进;var 常量_指令名_转向 = 转向;var 序号 = 0;var 画布尺寸 = x: 1000, y: 800;var 原点 = x: 画布尺寸.x/2, y: 画布尺寸.y/2;var 前进角度 = 90; // 默认向上, 对应弧度: 90 * Math.PI / 180// 指令格式: 名称 (转向, 前进, 笔色等等); 参数 (转向角度--右为负,左为正; 前进长度-像素数等等);var 指令序列 = [];定制监听器.prototype.enter程序 = function(ctx)   重置状态();  // 只需调用一次  // https://p5js.org/reference/#/p5/setup  构图 = function()     新画布(画布尺寸.x, 画布尺寸.y);  ;function 重置状态()   序号 = 0;  原点 = x: 画布尺寸.x/2, y: 画布尺寸.y/2;  前进角度 = 90;  指令序列 = [];// 根据指令序列, 生成路径分段描述(段起止点坐标, 颜色等等)// 如: 前进50, 左转90度, 前进50 应返回(假设起点为x: 200, y: 200):// 起点: x: 200, y: 200, 终点: x: 200, y: 150, 长度: 50,// 起点: x: 200, y: 150, 终点: x: 150, y: 150, 长度: 50function 生成路径表(指令序列)   // 段: 起点: x, y, 终点: x, y, 长度, 颜色  var 路径表 = [];  var 起点 = 原点;  for(var i = 0; i lt; 指令序列.length; i++ )    var 指令 = 指令序列[i];    var 指令名 = 指令.名称;    var 段 = 起点: 起点;    if (指令名 === 常量_指令名_前进)       var 距离 = 指令.参数;      var x增量 = Math.cos(前进角度 * Math.PI / 180);      var y增量 = Math.sin(前进角度 * Math.PI / 180);      段.终点 = x: 起点.x + x增量 * 距离, y: 起点.y - y增量 * 距离;      段.长度 = 距离;      路径表.push(段);      起点 = 段.终点;     else if (指令名 === 常量_指令名_转向)       前进角度 += 指令.参数;        return 路径表;定制监听器.prototype.exit程序 = function(ctx)   var 路径表 = 生成路径表(指令序列);  绘制 = function()     var 当前序号 = 序号;    background(255, 255, 255);    for (var i = 0; i lt; 路径表.length; i++ )       var 段 = 路径表[i];      var 起点 = 段.起点;      var 终点 = 段.终点;      var 距离 = 段.长度;      if (当前序号 lt; 距离)         line(起点.x, 起点.y, 起点.x + (终点.x - 起点.x) * 当前序号 / 距离, 起点.y + (终点.y - 起点.y) * 当前序号 / 距离);        break;       else         line(起点.x, 起点.y, 终点.x, 终点.y);        当前序号 = 当前序号 - 段.长度;                  序号 ++;  ;定制监听器.prototype.exit前进 = function(上下文)   var 前进量 = 上下文.getChild(1).getText()  指令序列.push(名称: 常量_指令名_前进, 参数: parseInt(前进量));;定制监听器.prototype.exit转向 = function(上下文)   var 方向 = 上下文.getChild(0).getText();  var 角度 = parseInt(上下文.getChild(2).getText());  角度 = 角度 * (方向 === 左 ? 1 : -1);  指令序列.push(名称: 常量_指令名_转向, 参数: 角度);;"
    } ,
  
    {
      "title"    : "编写Visual Studio Code插件初尝试",
      "category" : "开发环境",
      "description" : "根据VS Code官方入门文档编写一个最简单的插件. Write a simple hello-world extension for Visual Studio Code.",
      "tags"     : "",
      "url"      : "/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2017/12/04/%E7%BC%96%E5%86%99Visual-Studio-Code%E6%8F%92%E4%BB%B6%E5%88%9D%E5%B0%9D%E8%AF%95.html",
      "date"     : "2017-12-04 00:00:00 -0700",
      "content"  : "参考官方入门: Your First Visual Studio Code Extension - Hello World源码在: program-in-chinese/vscode_helloWorld创建插件过程中, 发现identifier和publisher name不允许中文命名(报错: invalid xxx):? What type of extension do you want to create? New Extension (TypeScript)? What's the name of your extension? 吃了么? What's the identifier of your extension? hello? What's the description of your extension? 吃了么? What's your publisher name (more info: https://code.visualstudio.com/docs/tools/vscecli#_publishing-extensions)? nobody运行一下Hello World命令, 没问题.按入门教程替代extension.sayHello命令的内容, 实现显示选中文本长度的演示功能:        var 编辑器 = vscode.window.activeTextEditor;        if (!编辑器)             return; // 无打开的编辑器                        var 选中部分 = 编辑器.selection;        var 文本 = 编辑器.document.getText(选中部分);                // 显示信息框        vscode.window.showInformationMessage('选中字符数: ' + 文本.length);运行Hello World结果:顺便感受一下调试功能:"
    } ,
  
    {
      "title"    : "编程语言试验之Antlr4+JavaScript实现&quot;圈4&quot;",
      "category" : "语言设计",
      "description" : "参考网文, 倚靠Antlr生成JavaScript实现的分析器, 实现一个简单的编程语言. Implement a pretotype programming language with Antlr4 and JavaScript, based on an online article.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/12/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AF%95%E9%AA%8C%E4%B9%8BAntlr4_JavaScript%E5%AE%9E%E7%8E%B0_%E5%9C%884.html",
      "date"     : "2017-12-02 00:00:00 -0700",
      "content"  : "参考: ANTLR4: Making a compiler with the JavaScript runtime演示效果虽弱, 还是先上图吧:在线演示: 地址.源码库: program-in-chinese/quan4下载到本地后在浏览器中打开”圈4.html”就可以在本地试验.以后设计实现好语言后可以直接用静态网页作在线编程的演示, 觉得还蛮有用.注: JS代码中各种不良操作(比如全局函数定义). 请勿作为JS学习材料使用. 与前文一样, 此文的目标不是一个实用的编程语言.语法非常简单(圈4.g4), 只为演示之用. 前文编程语言试验之Antlr4+Java实现”圈2”有更多格式的解释:grammar 圈4;程序   : 求约数;求约数    : '求约数' T数 ;T数 : [0-9]+ ;T空白     : [ #92;n#92;t]+ -gt; skip;下面命令生成词法语法分析器相关JavaScript文件(圈4.tokens, 圈4Lexer.js, 圈4Lexer.tokens, 圈4Listener.js, 圈4Parser.js): java -cp antlr-4.7-complete.jar:CLASSPATH org.antlr.v4.Tool -Dlanguage=JavaScript 圈4.g4作为解释器的”定制监听器.js”:var antlr4 = require('antlr4/index');const 圈4Listener = require('./圈4Listener.js').圈4Listener定制监听器 = function ()   圈4Listener.call(this);  return this;定制监听器.prototype = Object.create(圈4Listener.prototype);定制监听器.prototype.constructor = 定制监听器;/*无需接口定义: enter程序/exit程序/enter求约数*/定制监听器.prototype.exit求约数 = function(上下文)   var 原数 = parseInt(上下文.getChild(1).getText());  document.getElementById(输出).innerHTML = 原数 + 的约数:  + 求约数(原数);;function 求约数(原数)   var 约数 = [];  for (var i = 1; i lt; 原数 - 1; i++)     if (原数  i == 0)       约数.push(i);        return 约数;exports.定制监听器 = 定制监听器;读取文件输入, 调用附着了定制监听器的分析器”代码分析.js”:const antlr4 = require(antlr4/index)const 圈4Lexer = require(./圈4Lexer.js)const 圈4Parser = require(./圈4Parser.js)const 定制监听器 = require(./定制监听器.js).定制监听器运行();// TODO: 需改进-现为全局, 由于browserifyfunction 运行()   var 代码 = document.getElementById('输入代码').value;  var 输入流 = new antlr4.InputStream(代码)  var 词法分析器 = new 圈4Lexer.圈4Lexer(输入流)  var 词 = new antlr4.CommonTokenStream(词法分析器)  var 语法分析器 = new 圈4Parser.圈4Parser(词)  语法分析器.buildParseTrees = true  antlr4.tree.ParseTreeWalker.DEFAULT.walk(new 定制监听器(), 语法分析器.程序())window.运行 = 运行;HTML界面”圈4.html”:lt;htmlgt;  lt;headgt;    lt;!-- defer原因: https://stackoverflow.com/a/26077148/1536803 不然需要document.ready判断 --gt;    lt;script src=圈4.js defergt;lt;/scriptgt;  lt;/headgt;  lt;bodygt;    lt;textarea id=输入代码gt;求约数50    lt;/textareagt;    lt;button onclick=运行()gt;运行lt;/buttongt;     lt;span id=输出gt;lt;/spangt;  lt;/bodygt;lt;/htmlgt;是的, 上面的”圈4.js”需要另行生成. 安装Browserify后运行: browserify 代码分析.js gt; 圈4.js "
    } ,
  
    {
      "title"    : "中英文代码对比之ZLOGO 4 &amp; LOGO",
      "category" : "语言设计, LOGO",
      "description" : "比较ZLOGO 4编写的中文代码和LOGO的英文代码. Compare Chinese code in ZLOGO and English code in LOGO.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/logo/2017/12/01/%E4%B8%AD%E8%8B%B1%E6%96%87%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94%E4%B9%8BZLOGO-4-&-LOGO.html",
      "date"     : "2017-12-01 00:00:00 -0700",
      "content"  : "基于前文中文编程语言之Z语言初尝试: ZLOGO 4的一些评论, 此文尝试作一个非常简单的代码对比, 使讨论更加有实例根据. 下图是节选自前文最后的示例代码, 由于选取的对照LOGO版本 (alancsmith.co.uk/logo/, 2002年第一版) 不支持单行内多条语句, 特意将所有语句分行编写. 另外, ZLOGO暂不支持循环, 因此也不使用LOGO中的循环语法.之前有评论中提到有的LOGO版本支持”FD 10”, FD应该是Forward的缩写. 在现今的代码风格中, 一般将可读性放在追求代码简短之前, 而且在硬盘价格白菜价的今天, 一般只有几KB的源代码文件完全不需要考虑占用硬盘的问题. 选取的这个版本的LOGO的关键词更可读也更与ZLOGO接近.下面是一些个人的观感:  “色”和”度”的后缀使用, 使这些操作的语义更加一目了然.          “SetPenColour 0”还需要额外记住0对应的是白色, 2是红色.      因为和”Foward 20”的结构相似性, “Left xx”给我这样的LOGO新手的第一感觉是”向左走xx(长度)”, 转念才意识到这是”左转xx度”的意思.        “前进”和”左转”这样长度相同的词语使得代码看上去相对于使用”Forward”和”Left”更加齐整.  SetPenColour这样的Camel风格是为了使一个关键字能够包含多个单词而采用的一种风格, 也在很多主流编程语言中常用, 它比全大写更加可读. 但在英文自然语言中, 这种风格几乎已经不再使用. 另外, “Left xx”在英语自然语言中是”Turn Left xx degrees”的意思, 这里已经大大简写了. 相比之下, ZLOGO中的词法语法基本与中文自然语言一致.  还是SetPenColour, 由于这个版本是英国开发者编写的, 它使用了英式英语拼写”Colour”, 而不少中国人学习的应该是美式英语, 这种微小的差别很容易导致误写.  在两者自带的几乎是纯文本编辑器的开发环境中编写代码的过程中, 代码输入的时间远小于测试/查错/调整算法的时间, 而且不少代码段是拷贝粘贴生成的. 个人感觉英文输入的笔误率大于中文的(本人的一个Forward写成了Foward).写到这里, 发现这个版本还是支持简写的, 于是一并比较(右侧):上面的#1和#3仍然适用. 另外, “FD/LT”相对于”前进/左转”, 个人觉得后者更加对中文用户友好. 当然, 以少儿的优良记忆力, 这些一眼看去无意义的缩写也可以在不明白其原意的情况下在短期内记住.但如果写了这个代码之后, 不碰LOGO语言, 半年后再看这段代码, 或者十年后再看呢? 恐怕又要重新查一遍用户手册. 当然可以说, 这只要供小学生学两个学期而已以后不可能再碰了, 但如果有一种无论放下多久再拿起时仍然一目了然的语法设计(甚至对于完全不懂LOGO的人), 又何乐而不为呢?"
    } ,
  
    {
      "title"    : "Python3选择支持非ASCII码标识符的缘由",
      "category" : "命名",
      "description" : "探究当年为何Python3选择添加对Unicode标识符的支持. Find out why Python 3 chose to add support for non-ASCII identifiers.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2017/11/30/Python3%E9%80%89%E6%8B%A9%E6%94%AF%E6%8C%81%E9%9D%9EASCII%E7%A0%81%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E7%BC%98%E7%94%B1.html",
      "date"     : "2017-11-30 00:00:00 -0700",
      "content"  : "原文在: PEP 3131 – Supporting Non-ASCII Identifiers.Python2并不支持非ASCII码标识符. PEP的全称是Python Enhancement Proposal, 即Python增强提案. 这个3131提案创建于2007年5月. Python3于2008年12月发布.Rationale一节开篇明义, 指出用母语命名标识符对代码清晰度和可维护性的提高.  Python code is written by many people in the world who are not    familiar with the English language, or even well-acquainted with the    Latin writing system. Such developers often desire to define classes    and functions with names in their native languages, rather than having    to come up with an (often incorrect) English translation of the    concept they want to name. By using identifiers in their native    language, code clarity and maintainability of the code among    speakers of that language improves.下面列出了一些质疑和回应. 其中:  People claim that they will not be able to use a library if to do so they have    to use characters they cannot type on their keyboards. However, it is the    choice of the designer of the library to decide on various constraints for using    the library: people may not be able to use the library because they cannot get    physical access to the source code (because it is not published), or because    licensing prohibits usage, or because the documentation is in a language they    cannot understand. A developer wishing to make a library widely available needs    to make a number of explicit choices (such as publication, licensing, language    of documentation, and language of identifiers). It should always be the choice    of the author to make these decisions - not the choice of the language    designers.简要翻译:有人表示库如果是其他语言命名, 不懂这一语言的使用者就不会输入API名了. 回应是库开发者有权根据需要进行设计, 这与其他制约因素(版权,文档是外文等等)类似. 开发者如果想要库被最广泛地使用, 自然会考虑到所有这些因素. 而这, 应该是开发者的决定, 而不是语言设计者的."
    } ,
  
    {
      "title"    : "在线编程网站对中文代码的支持",
      "category" : "语言设计, LOGO",
      "description" : "检验多个在线编程网站对中文标识符的支持, 包括运行和编译反馈信息. Verify support of Chinese identifiers on online programming websites, including running and compile messages.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/logo/2017/11/28/%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E7%BD%91%E7%AB%99%E5%AF%B9%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%9A%84%E6%94%AF%E6%8C%81.html",
      "date"     : "2017-11-28 00:00:00 -0700",
      "content"  : "参考哪些比较好的在线编程网站？, 测试各个网站对中文命名的代码的支持, 包括调试信息等(见向LeetCode报告编译信息中Unicode显示问题).有趣的是, 在范围有限的评测中, 国产的在线编程网站似乎对中文命名的代码普遍支持更好. 不知开发者是否对这个功能有特别的关注, 亦或实现机制更胜一筹, 或是两者皆有. 无论如何, 都值得一个赞!图片版:带链接的网页版在此附上测试用Java代码:public class 大家好   public static void main(String[] 参数)     打印(大家好);    private static void 打印(String 输出)    System.out.println(输出);  测试用JavaScript:人1=new Object();人.名=大人;人.姓=小;人.年龄=58;人.眼色=蓝色;document.write(人.名 + 已经 + 人.年龄 + 岁.);注:未实测的:dabblet.com 正式只支持HTML/CSScodecademy.com, 实验楼 - 在线做实验，高效学编程, 计蒜客 - 学习面向未来的计算机科学 都需注册"
    } ,
  
    {
      "title"    : "中文编程语言之Z语言初尝试 - ZLOGO 4",
      "category" : "语言设计, LOGO",
      "description" : "学习ZLOGO官方教程,记录过程中的发现. Follow the official tutorial of ZLOGO programming language, and share the findings during the way.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/logo/2017/11/28/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B9%8BZ%E8%AF%AD%E8%A8%80%E5%88%9D%E5%B0%9D%E8%AF%95-ZLOGO-4.html",
      "date"     : "2017-11-28 00:00:00 -0700",
      "content"  : "TKT2016 开发的Z语言(ZLOGO是它的一个部分)是本人至今看到的唯一一个仍活跃开发的开源且比较完整的中文编程语言项目. 它的源码在TKT2016/ZLanguage3.此文从用户角度尝试一下ZLOGO的功能, 并记录一些过程中的发现.首先上一个看完教程后自己写的螺旋方块演示. 源码附在最后.以下是官网的说明:  LOGO语言创始于1968年，是美国国家科学基金会所资助的一项专案研究，在麻省理工学院（MIT）的人工智能研究室完成。  ZLOGO是基于Z语言实现LOGO语言功能的编程软件，用了中文易懂的语句代替原先LOGO语言难于记忆的命令，更方便学习者掌握。官网上下载了ZLOGO4, 按照说明, 解压后就可运行.按照ZLOGO4教程, 逐步实验.第一个LOGO程序中, 有”左转60度”. 推测默认方向是朝上, 测试了一下”左转0度”, 的确如此. 推测”前进200”中的200指的是像素数. 觉得教程中最好说明这些基本的默认要素(包括画线的颜色, 粗细, 海龟行走速度等等).在运行窗口打开的情况下, 再次”运行”会打开一个新的运行窗口.代码缩进好像是不严格的. 即使每行开头没有缩进, 也照样运行(后补: 经进一步测试, 过程的第一行允许开头没有空白, 但之后的行不允许). 当然它可以使代码更可读.在第二个”显示隐藏”程序中, 逗号用来分割两个语句:    前进50,隐藏尝试把它分成两行:    前进50        隐藏运行效果相同, 但发现两个问题:  IDE里的Tab不等同于多个空格(5-6个空格之间)  如果”隐藏”之前没有空格, 就会弹出”编译信息”窗口并报错:    第4行,第3列错误:不正确,应该是:        另外, 如果海龟越出了窗口, 比如”前进”太多, 好像运行窗口不能滚动, 或者最大化.  计算功能初步尝试一些合法表达式没有问题. 不过狠了一把试了”前进(2/0)”, 好像就不显示了, 也没有报错.最后的过程部分, 才看到”过程体每一行程序必须以空格开头，使程序的开始列必须大于过程名的列号。”这就解释了上面的报错. 建议将这个警示提到文档开头, 而且反馈信息最好明确一些.学完教程之后, 试着参照p5js的一个演示程序, 写了个简单的方块螺旋效果图, 当然ZLOGO和p5js不是同类工具, 这里只是参考算法而已.最大的感触当然是过程没有参数的痛苦, 原本螺旋演示里只要定义一个过程就可以了. 暂时没有在教程中看到这一功能. 如果已经支持, 期待原作者指正.小结:虽然距离实用尚有一点距离(本身也是测试版), 但瑕不掩瑜, 已有雏形. 除了过程参数之外, LOGO的经典功能已经具备. 非常期待改进版~~附上”螺旋.zlogo”源码:说明:画螺旋开始绘图:    画正方形5    画正方形4    画正方形3    画正方形2    画正方形1画正方形1:    设置画笔颜色为白色    左转(20/2)度,前进(20/2),左转90度    设置画笔颜色为红色    前进(20/2),左转90度    前进20,左转90度    前进20,左转90度    前进20,左转90度    前进(20/2)    复位画正方形2:    设置画笔颜色为白色    左转(20*2/2)度,前进(20*2/2),左转90度    设置画笔颜色为红色    前进(20*2/2),左转90度    前进(20*2),左转90度    前进(20*2),左转90度    前进(20*2),左转90度    前进(20*2/2)    复位画正方形3:    设置画笔颜色为白色    左转(20*3/2)度,前进(20*3/2),左转90度    设置画笔颜色为红色    前进(20*3/2),左转90度    前进(20*3),左转90度    前进(20*3),左转90度    前进(20*3),左转90度    前进(20*3/2)    复位画正方形4:    设置画笔颜色为白色    左转(20*4/2)度,前进(20*4/2),左转90度    设置画笔颜色为红色    前进(20*4/2),左转90度    前进(20*4),左转90度    前进(20*4),左转90度    前进(20*4),左转90度    前进(20*4/2)    复位画正方形5:    设置画笔颜色为白色    左转(20*5/2)度,前进(20*5/2),左转90度    设置画笔颜色为红色    前进(20*5/2),左转90度    前进(20*5),左转90度    前进(20*5),左转90度    前进(20*5),左转90度    前进(20*5/2)    复位后续: ZLOGO 4与LOGO代码对比实验"
    } ,
  
    {
      "title"    : "汉化了十数个编译器的前辈的心得体会",
      "category" : "命名",
      "description" : "通过修改编译器, 实现对中文标识符支持的一位前辈的对于中文编程和中文编程语言的心得. View of programming in Chinese from a pioneer who modified a dozen compliers to add support of Chinese identifiers.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2017/11/27/%E6%B1%89%E5%8C%96%E4%BA%86%E5%8D%81%E6%95%B0%E4%B8%AA%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%89%8D%E8%BE%88%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A.html",
      "date"     : "2017-11-27 12:00:00 -0700",
      "content"  : "竹闲 的原文在【图片】回复：有筒子想用中文写汇编吗？_汇编吧_百度贴吧 63楼. 特此转载, 并向所有勇于探索的前辈们致敬!他汉化的十余个编译器: 竹闲：一般编程语言都是英文的，大家对中文编程有什么样的看法，中文编程有哪些优劣势？1)论点:应否「建立新的中文编程语言」,慎思之。2)理由:　2.1)旧编程语言的优点(代价)。　2.2)新编程语言的立足点。　2.3)旧径:绕过上述困难,直接沿用旧编程语言。　　仅「令其函数名、过程名、变量名均可用汉字」即可。3)致敬。2.1)旧的编程语言,仍在使用当中,未受淘汰。　且拥有庞大的用户群体,　多年的历史沉淀、技术支持,　出版的各种入门图书、文档、丰富详尽的函数手册,　繁杂全面的网络帮助与代码用例,　以及若干系列的测试工具(微秒级的各函数耗时百分比时间分析、　　符号级#92;源代码级别调试器、内存检查器、svn代码上传……),　全球多层面、多场合、多语言的产品测试,　完善的售後服务,　不断的根据用户反馈或硬件改革而进行软件升级,　保证20年後该产品#92;本公司依然存在。　　个人的作品与品牌公司在此得到最明显的对比:个人#92;小工作室#92;普通公司　难以提供上述任何一项,无法与之竞争。　　而且即令是完成了上述所有项的大公司,例如宝兰(borland)公司,全球320万用户,21年(1987～2008)的悠久历史,无数的测试工具……仍落得被易博龙收购的下场。所以新的编程语言,一开始就得做好亏本的打算。2.2)周思博有云,新技术若都用来解决一些「旧技术能解决的问题」,　则新技术必受诟病。老周此话原是揶揄微软,但换在编程语言身上,依然适合。　D语言与c–对于c来说,则患此弊。　甚至连ruby等新语言,亦因此被王垠将之与lisp相提并论,被批得烂额焦头。　　　所以一旦摒弃旧编程语言,则用户会循(2.1)为准　来要求新中文编程语言,　间中还夹杂着不少对中文的偏见(中国编程员对中文市场的敌视,天下知名。　无论规格书、说明书、函数手册……能不写汉字就决不用中文。　汉人学得胡儿语,却向城头骂汉人。今古皆然,不足为怪)。因而新语言的崛起,　纵不是一枝独秀、出类拔萃,也得解决一些「旧技术不能解决的问题」。　即使是内存自动回收、网络函数、反射、函数式编程……等等,都是题中　应有之义,而非亮点了。　　　此事并非苛求,因为既是一门全新的编程语言,众人当然认为作者是一位　开宗立派的大师,按《春秋》责备贤者的传统,臧否这位宗匠级别的作品而已。　　　当然,作者可以把新编程语言抛到网站上,然後撒手远飏。　通常众人亦会权当作者交了一趟作业、完成了一趟导师的论文答辩。　例如 Fabrice Bellard 的tiny cc,欠缺维护,现已少人问津了　(顺便说一句,把他的 libtcc.c#92;LIBTCCAPI TCCState *tcc_new(void)内　inline的preprocess_new()改一下,即可支持中文的标识符。　即令不改源代码、不重新编译,只把他的 libtcc.dll 相应改四十个字节,　也有同样效果)。　　　但退一步而言,如(2.1)所说,要作者熬廿年的苦日子,自费出版各种手册,　墙内墙外都租用服务器,为各国各族人民提供多语言技术支持,随时改bug,　不断推出新版本,而且这廿年很可能颗粒无收。太过强人所难了。2.3)综上所述:另起炉灶後,压力之大,无以复加;赢利之微,几乎倒贴。所以大部分人都蝇附骥尾,仅让「旧编译器在吃进中文程序时,能辨认出中文标识符,从而正常编译连接,不致报错」,就经已心满意足。　　在读秀或万方上搜索,可窥见众前贤的旧迹,谨录部分于下:　王其宏《用汉字标识符的PASCAL编译程序》,载诸《长春邮电学院学报》1987年02期,　李京　《PASCAL编译程序的改造》,载诸《计算机工程与应用》1987年09期,　苗庆斌《PASCAL语言汉化的设计与实现》,载诸《计算机工程与设计》1990年03期,　章继三《中文汇编语言编程》,载诸《软件世界》1994年06期,　黄志勇《Foxpro2.5的汉化方法》,载诸《电脑》1995年12期,　阙建军《在FOXBASE下使用汉字变量名及字段名》,载诸《中国金融电脑》1996年05期　……　　甚至连新人亦沿此旧径,例如aogo的masmplus,鼎龙的中文C++,竹闲的汉化各编译器。藉旧编程语言之势,让其函数名、过程名、变量名均可使用汉字(在此强调：均可≠均须！)。如此则旧的程序文档、编程员、代码用例……均纹风不动。　　此举虽有狐假虎威之嫌、鹊巢鸠占之喻,但终究算是把(2.1)的压力尽数卸开。然後他山之石,攻我之玉。自此,中文编程即可。终于可以不写“render_hexagon(last_descending_point)”,改为“_填6边形(_最近降点)”了。而且连接lib#92;跑lua虚拟机#92;正常运行python#92;……效果一切如常,简直有百利而无一害。　　有一害:编译器每出一趟新版本,上述工作者就须配合一版汉化包,跟游戏汉化者发行汉化包毫无区别。我这番话对游戏汉化者并无半分嘲讽之意:编译器是程序,游戏也是程序;编译器的用户(编程员)是人,游戏的用户(玩家)也是人;而且後者的市场还大些。而两厢的汉化者都在免费工作,都追赶在版本号後面而疲于奔命。　　「疲于奔命」是巫臣的原话,但汉化者的奔命何止七次,就因为他们的辛勤工作故意被原编译器作者所忽视(台面规则是编译器得支持unicode,潜规则却是欧美国家毋需理睬中文市场,例如以前 go语言组对导出中文函数名的争论,https://groups.google.com/forum/#!msg/golang-china/h_vxbPHaIvw/wFRw1Myrm3AJ该链接在墙外,不知是否失效了),就因为他们的劳动免费而不足挂齿。于是,总有人厌倦,就出手打造自己的中文编译器了。3)在此,向所有披荆斩棘的中文编程员致敬:　例如(以下并非全集,且排名不分先後):O语言的作者,标天软件的BtAsm团队,　易语言的吴涛,Python的周蟒,法国的WinDev……　　　毋论他们在商业上是胜是败,但始终他们都为中文编程作出了自己的贡献,　默默耕耘,未必收获。全凭有他们,也纔能映照出中文编程之路,何等曲折,何等漫长,　虽是一脉如丝,仍是缕缕不断。　　　勉之矣,任重而道远。"
    } ,
  
    {
      "title"    : "中文编程兴起的可能途径",
      "category" : "语言设计",
      "description" : "通过几个角度探讨中文编程的可能发展方向, 并突出开源项目的优势. Discuss possible approaches to programming in Chinese, with emphasis on advantages of open source projects.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/11/27/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E5%85%B4%E8%B5%B7%E7%9A%84%E5%8F%AF%E8%83%BD%E9%80%94%E5%BE%84.html",
      "date"     : "2017-11-27 12:00:00 -0700",
      "content"  : "前文中文编程兴起的必然性虽然阐述了长远的必然性, 但很自然地会有以下疑问:  为何至今没有看到国内大公司的任何从事中文编程的实践?  如何以较小代价实践中文编程以及创造推广中文编程语言/工具?此文从个人视野尝试解读和设想.刚刚意识到问题1的主观原因(客观原因请见中文命名实践的阻力和应对, 创建新中文编程语言也有类似问题, 而且成本和风险更大).一言蔽之, 他们最有能力实践, 但恐怕也最没有动力. 其实这和熟悉英文编程语言的程序员不少缺乏动力参与中文编程是一个道理, 只是一个是宏观, 一个是微观.国内大公司往往通过市场地位进一步占据了人力优势, 可以招纳到足够英文编程水平的开发者. 而这也是进一步巩固技术优势和领先地位的一个方面. 中文编程对他们带来的对项目本身的益处相对较小(因为人力财力足够). 而相应的另一个极端–初创公司(大多是单人或双人项目)其实是最能从代码可读性获益的(运维成本的升降往往意味着企业成败的区别), 从而也会是从中文编程获益最大的.因此, 从保证短期商业利益的角度看, 大公司创造中文编程语言/工具/框架的可能性非常小. 当然也不排除某家大公司敢于通过在中文编程上领头创新的方式获取社会效益的可能性. 即便如此, 终究是求人不如求己.下面一部分来源于讨论组话题: 如何面向中文编程(潜在)用户进行推广? · Issue #41 · program-in-chinese/overview. 无论语言/工具是开源还是闭源(免费/商业), 在推广和实践上应该有类似之处. 欢迎指正补充.潜在首批用户  编程初学者  乐于尝试的编程爱好者  想用中文编程工具开发业余/初创项目, 并且首先关注国内市场的开发方式  在开发中文编程语言/框架/API时, 尽量在技术允许的情况下(需要分享和积累, 详见中文命名实践的阻力和应对)在代码中使用中文命名. 这样对项目本身可以降低成本(详见对在代码中使用中文命名的质疑与回应 “没有好处”一节), 同时也进一步增加中文命名的技术积累  基于英文编程语言的发展史, 个人认为开源方式能够最大程度促进技术分享和进步, 中文编程方面暂时以商业软件为主, 但开源项目应该能够更加活跃, 反过来也可以促进商业软件的进步.推广  对初学者来说, 中文代码的入门教程(以英文编程语言中使用中文命名为例, 比如中文代码示例教程之Java编程一天入门), 以及对应的很容易安装使用甚至免安装的编程环境.  对于爱好者, 也许是更加贴近实际问题的一些教程和相关工具, 比如如何用汉化版TypeScript(program-in-chinese/CTS)和相关库创建一个简单的网络服务和前端.  对于目标是团队开发商用软件的用户, 则需要成熟的工具/文档, 以及及时的社区技术支持.  在社区成熟和有足够的共同开发者之前可能主要靠核心开发者. 首先单个项目建立社区, 类似于TypeScript.org, JUnit.org等等. 项目积累之后, 建立一个更广泛的中文编程相关生态圈, 类似Apache商业化  现在看到的一些开源项目的商业化方式, 以提供免费的社区版和收费的商用版进行. 社区版搜集反馈和bug, 商用版以稳定或功能或技术支持为卖点. 比如Odoo等等.正如汉化了十数个编译器的前辈的心得体会的最后所言, 任重而道远. 个人相信前途光明."
    } ,
  
    {
      "title"    : "对中文语法的编程语言的质疑与回应",
      "category" : "语言设计",
      "description" : "对常见的对中文语法的编程语言的反对声音进行小结, 并作针对回应. QA for creating programming language in Chinese grammar.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/11/27/%E5%AF%B9%E4%B8%AD%E6%96%87%E8%AF%AD%E6%B3%95%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B4%A8%E7%96%91%E4%B8%8E%E5%9B%9E%E5%BA%94.html",
      "date"     : "2017-11-27 00:43:00 -0700",
      "content"  : "有感于编程软件有没有用中文编写的？, 提取了一些比较典型的声音回应如下, 如有遗漏的论点请补充.英语和编程无关  只要会几十个英文关键词, 就可以学编程了 – 所有的API都是英文的, 看中文文档已经比直接理解API名称间接了一层, 还不用说中文文档的质量和覆盖面问题.  编程使用的符号(标识符等等), 与自然语言无关 – 参考对在代码中使用中文命名的质疑与回应一文中关于可读性的部分  编程的门槛是逻辑, 而不是英文 – 从逻辑不好会导致编程学习困难不能推导出编程入门困难的就逻辑不好. 随着编程经验的积累, 反过来肯定会使逻辑更加清晰, 而英文导致的额外入门难度本是可以避免的.  英文不会提高编程门槛 – 即使是国外开发者, 也对非英语国家学习编程的自带难度有认可. 详见吴烜：编程软件有没有用中文编写的？前半部分. 一个可能是他们都误会了, 另一个就是这个明确的中文编程语言的市场需求被出于各种原因视而不见了.很多英文编程语言都是由非英文母语的开发者创造的如: (转载)python-荷兰; pascal-瑞士; Erlang-瑞典; php-以色列; ruby-日本.回应: 与对在代码中使用中文命名的质疑与回应“芬兰人Linus，使用英语而非自己的母语来编写Linux代码”一节同理, 上述所有语言都没有与中文/英文同等量级的使用人口数量. 最接近的日语也有十几倍的差距.中文比数学表达式繁琐最常给出的例子是1+2-3*4 用中文写就是一加二减三乘以四,以此说明中文不适宜作代码.回应: 也没有英文编程语言这样设计one add two minus three multiply by four. 中国本身的平均数学水平就在第一梯队, 对阿拉伯数字和这些基本数学符号基本做到了全民普及, 为何一定要选择在编程语言中用汉字表达数学呢? 当然, 不是说不能用加 減等等作为关键字, 而是说很容易做到两种模式都支持, 根据具体情况使用.从硬件接口到语言/接口都是英文的, 不可能突破中文编程语言的设计实现, 瓶颈不在于编译器技术. 而是走出第一步, 开发一套实用的语言和配套的中文接口的标准库(后者的设计难度和实现工作量也许不亚于语言本身的设计和实现). 之后的迭代和演进将水到渠成. 当然, 突破垄断总是难的, 但技术上可行, 也已经有人才储备了.中文输入效率低见对在代码中使用中文命名的质疑与回应 “中文输入太慢, 降低开发效率”一节难以国际化首先, 对在代码中使用中文命名的质疑与回应 “不利于非中文编程者贡献”一节阐述了绝大多数国内项目的本土特性. 其次, 如果实力和需求已经达到招募国外程序员的地步, 相信国外开发者也会去学中文的. 正如孔子学院的兴起, 综合国力的提高必将催生文化输出. 中文编程语言相信会使国内的编程效率获得进一步提升, 进而提升IT行业整体的国际竞争力, 进而扭转劳力输出的趋势, 中文编程也将成为文化输出的一部分.不如做好各种文档以及编程工具的翻译这是迫于现状不得不为, 长远看只能跟着别人后面亦步亦趋.而中文编程语言是属于自己的路, 节奏和方向都在自己把握中, 也是摆脱跟跑的更可能途径(为何更难以创造新的英文编程语言请见国人创造中文编程语言的优势)需要推翻现有的一切从头来就像很多JVM语言(如Scala)都可以调用Java库, 中文编程语言一样可以在设计时就加入类似特性, 从而在创始时就可以使用所有或者部分现有语言的实用功能. 这种情境下的中英混用与在现有英文编程语言中使用中文命名同理. 在此基础上, 可以逐渐完善自身的中文接口的标准库."
    } ,
  
    {
      "title"    : "编程语言试验之Antlr4+Java实现&quot;圈2&quot;",
      "category" : "语言设计",
      "description" : "参考网文, 使用Antlr生成Java分析器, 实现一个简单的编程语言. Implement a pretotype programming language with Antlr4 and Java, based on an online article.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/11/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AF%95%E9%AA%8C%E4%B9%8BAntlr4_Java%E5%AE%9E%E7%8E%B0_%E5%9C%882.html",
      "date"     : "2017-11-26 00:00:00 -0700",
      "content"  : "“中文编程”知乎专栏原文此文涉及的源码版本: program-in-chinese/quan2声明 代码来源 How to Create Language Using Antlr4本作主要作为学习Antlr, 以及实践中文命名之用. 目标不是一个实用的编程语言.个人感觉这样可以比较容易的用原型来尝试和演示不同语法设计, 如果有更简单的途径请不吝赐教. 欢迎各种自行修改~碰到任何问题也欢迎一同探讨.下面是”圈2”语言的示例代码:开始    使 甲 为 5    使 乙 为 10    加 3 到 乙    加 乙 到 甲    加 甲 到 乙    打印 乙    打印 3结束附上需要自行编写的三个文件:Antlr4的语法定义文件:按照README说明, Antlr可以据此自动生成四个分析器相关类文件. T前缀是由于Antlr约定大写开头是Token定义. 标识符支持中文.grammar 圈2;程序   : '开始' 声明+ '结束';          声明 : 赋值 | 加 | 打印 ;赋值    : '使' T标识符 '为' (T数 | T标识符) ;打印     : '打印' (T数 | T标识符) ;加       : '加' (T数 | T标识符) '到' T标识符 ;T标识符     : ('a' .. 'z' | 'A' .. 'Z' | '#92;u4E00'..'#92;u9FA5' | '#92;uF900'..'#92;uFA2D')+ ;T数 : [0-9]+ ;T空白     : [ #92;n#92;t]+ -gt; skip;定制监听器:通过对每种语句分析后进行对应处理, 实质上起了解释器的作用.public class 定制监听器 extends 圈2BaseListener   private Maplt;String, Integergt; 变量表;  public 定制监听器()     变量表 = new HashMaplt;gt;();    Override  public void exit赋值(赋值Context 上下文)     // 赋值语句分析结束时运行此方法    String 变量名 = 上下文.T标识符(0).getText();    // 如果语句中有两个变量(标识符), 那么取第二个变量的值, 否则取数的值    int 值 = 上下文.T标识符().size() gt; 1        ? 变量表.get(上下文.T标识符(1).getText())        : Integer.parseInt(上下文.T数().getText());    // 更新变量值    变量表.put(变量名, 值);    Override  public void exit加(加Context 上下文)     // 加语句分析结束时运行此方法    String 变量名 = 上下文.T标识符().size() gt; 1 ? 上下文.T标识符(1).getText() : 上下文.T标识符(0).getText();    int 添加值 = 上下文.T标识符().size() gt; 1 ? 变量表.get(上下文.T标识符(0).getText())        : Integer.parseInt(上下文.T数().getText());    变量表.put(变量名, 变量表.get(变量名) + 添加值);    Override  public void exit打印(打印Context 上下文)     // 打印语句分析结束时运行此方法    String 输出 = 上下文.T标识符() == null ? 上下文.T数().getText() : 变量表.get(上下文.T标识符().getText()).toString();    System.out.println(输出);  运行器:读取文件输入, 调用附着了定制监听器的分析器public class 运行器   public static void main(String[] 参数)     try       ANTLRInputStream 输入 = new ANTLRInputStream(new FileInputStream(参数[0]));      圈2Lexer 词法分析器 = new 圈2Lexer(输入);      圈2Parser 语法分析器 = new 圈2Parser(new CommonTokenStream(词法分析器));      语法分析器.addParseListener(new 定制监听器());      // 开始分析      语法分析器.程序();     catch (IOException e)       e.printStackTrace();      尚未探索如何用Antlr4实现无空格语法设计(不允许标识符中出现关键字应该可以做到, 但那样限制太多)"
    } ,
  
    {
      "title"    : "中文代码示例之Spring Boot 1.3.3演示",
      "category" : "命名, Spring",
      "description" : "用一个简单的商品管理系统演示在Spring Boot最基本的功能中使用中文代码. Demostrate naming in Chinese in the basic features of Spring Boot 1.3.3, with a simple application for goods management.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/spring/2017/11/25/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BSpring-Boot-1.3.3%E6%BC%94%E7%A4%BA.html",
      "date"     : "2017-11-25 00:00:00 -0700",
      "content"  : "“中文编程”知乎专栏原文源码: program-in-chinese/jinxiaocun由于这个演示项目成型于去年(详见中文编程的尝试历程小记), Spring Boot还是老版本. 尚未将其更新到最新版本, 先将其中的一些中文命名的部分小结在此.URL如: /商品表 /单位表实现方式见最后附上的”单位控制器”源码中的:RequestMapping(value = /单位表)及protected static final String URL = 单位表;类/方法/变量用中文命名见后面附上的源码jsp文件名, 以及jsp中的变量名如”单位表.jsp”中的”单位.名称”.这需要”单位”类中的属性命名为”名称”. 由于命名约定, 需要将接口以get/set开头.数据库的表/列命名下面是mysqldump的结果(“单位”部分)DROP TABLE IF EXISTS `单位`;/*!40101 SET saved_cs_client     = character_set_client */;/*!40101 SET character_set_client = utf8 */;CREATE TABLE `单位` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `名称` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;完整schema在此编码相关注意点(现在想起的, 欢迎补遗)需要在pom.xml中添加:lt;propertiesgt;    lt;project.build.sourceEncodinggt;UTF-8lt;/project.build.sourceEncodinggt;lt;/propertiesgt;  数据库(用的Mysql)指定编码:    spring.datasource.url= jdbc:mysql://localhost:3306/jinxiaocun?useUnicode=trueamp;characterEncoding=utf8spring.datasource.sqlScriptEncoding=UTF-8        jsp文件头指定编码:    lt; page pageEncoding=UTF-8 gt;    如上面的mysqldump中所见, 表和列都设置为了utf8附上单位相关部分源码单位类:Entitypublic class 单位   private long id;  NotEmpty(message = 单位名称不可为空)  Size(max = 20, message = 单位长度不可超过20)  private String 名称;  Id  GeneratedValue(strategy = GenerationType.AUTO)  public Long getId()     return id;    public void setId(Long id)     this.id = id;    public String get名称()     return 名称;    public void set名称(String 名称)     this.名称 = 名称;  单位控制类:ControllerRequestMapping(value = /单位表)public class 单位控制   protected static final String URL = 单位表;  protected static final String 表名 = 单位表;  Autowired  private 单位库 单位库;  RequestMapping(method = RequestMethod.GET)  public String 列表(Model 模型)     Listlt;单位gt; 表 = 单位库.findAll();    if (表 != null)       模型.addAttribute(表名, 表);        // 需要初始化被校验的对象    模型.addAttribute(单位, new 单位());    return URL;    RequestMapping(method = RequestMethod.POST)  public String 添加(Valid 单位 单位, BindingResult 约束结果, Model 模型)     if (约束结果.hasErrors())       return URL;        单位库.save(单位);    return 列表(模型);  单位表.jsp:lt;bodygt;    lt;jsp:include page=置顶.jsp /gt;    lt;h2gt;单位列表lt;/h2gt;    lt;c:forEach var=单位 items=单位表gt;        lt;divgt;            lt;c:out value=单位.名称/gt;        lt;/divgt;    lt;/c:forEachgt;        lt;h3gt;添加单位lt;/h3gt;    lt;form:form method=POST modelAttribute=单位gt;        lt;form:errors path=* cssClass=errorblock element=div /gt;        lt;label for=名称gt;名称:lt;/labelgt;        lt;form:input type=text path=名称 size=50 /gt;        lt;form:errors path=名称 cssClass=error/gt;        lt;br/gt;        lt;input type=submit value=提交gt;lt;/inputgt;    lt;/form:formgt;lt;/bodygt;注演示本身非常幼稚, Spring Boot当时也是摸索学习中, 后也没有继续深入. 使用jsp而不是Thymeleaf的原因是, 后者当时不支持中文变量命名. 缘由详见业余小项目, 学用Spring boot (如对中文写代码本能排斥, 求放过)22楼."
    } ,
  
    {
      "title"    : "为GCC添加中文关键字",
      "category" : "语言设计, 汉化关键词",
      "description" : "通过修改gcc编译器源码, 添加中文关键词. Allow gcc to support unicode identifiers.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E6%B1%89%E5%8C%96%E5%85%B3%E9%94%AE%E8%AF%8D/2017/11/24/%E4%B8%BAGCC%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E5%85%B3%E9%94%AE%E5%AD%97.html",
      "date"     : "2017-11-24 01:40:00 -0700",
      "content"  : "知乎原文地址 作者:狗屎咖啡GCC不支持UTF-8字符，可以自己添加：如何使GCC支持中文(utf-8)的变量名、函数名？也可以 用脚本转换源代码，再编译：https://gcc.gnu.org/wiki/FAQ#utf8_identifiers但是强烈建议打上支持UTF-8的补丁。实例 swizl/gcn添加关键字在 gcc/c-family/c-common.c 中const struct c_common_resword c_common_reswords[] 下添加复制一行原关键字，再将字符串该成中文例如 asm,        RID_ASM,    D_ASM ,   汇编,        RID_ASM,    D_ASM ,   auto,        RID_AUTO,    0 ,   自动,        RID_AUTO,    0 ,   bool,        RID_BOOL,    D_CXXONLY | D_CXXWARN ,   布尔,        RID_BOOL,    D_CXXONLY | D_CXXWARN ,       break,        RID_BREAK,    0 ,   断,        RID_BREAK,    0 ,   case,        RID_CASE,    0 ,   例,        RID_CASE,    0 ,   catch,        RID_CATCH,    D_CXX_OBJC | D_CXXWARN ,   抓,        RID_CATCH,    D_CXX_OBJC | D_CXXWARN ,   char,        RID_CHAR,    0 ,   字,        RID_CHAR,    0 ,添加中文宏关键字在 libcpp/directives.c 中1 添加宏定义A，仿照D，加一个参数name_cn. 因为原始GCC不支持UTF-8#name 中 name为中文时无法解析，所以name_cn直接对于字符串。当然已经打了支持UTF-8的补丁，没有这个问题。兼容起见，还是按照这样改。#define D(name, t, o, f) static void do_##name (cpp_reader *);DIRECTIVE_TABLE#undef D#define D(n, tag, o, f) tag,enum  DIRECTIVE_TABLE  N_DIRECTIVES;#undef D#define D(name, t, origin, flags) #92; do_##name, (const uchar *) #name, #92;  sizeof #name - 1, origin, flags ,static const directive dtable[] =DIRECTIVE_TABLE;#undef D#define D(name, t, origin, flags) #name,static const char * const directive_names[] = DIRECTIVE_TABLE  NULL;#undef D改成#define A(name_cn, name, t, o, f)#define D(name, t, o, f) static void do_##name (cpp_reader *);DIRECTIVE_TABLE#undef D#undef A#define A(n_cn, n, tag, o, f) tag ## _CN,#define D(n, tag, o, f) tag,enum  DIRECTIVE_TABLE  N_DIRECTIVES;#undef D#undef A#define A(name_cn, name, t, origin, flags) #92; do_##name, (const uchar *) name_cn, #92;  sizeof (name_cn) - 1, origin, flags ,#define D(name, t, origin, flags) #92; do_##name, (const uchar *) #name, #92;  sizeof #name - 1, origin, flags ,static const directive dtable[] =DIRECTIVE_TABLE;#undef D#undef A#define A(name_cn, name, t, origin, flags) name_cn,#define D(name, t, origin, flags) #name,static const char * const directive_names[] = DIRECTIVE_TABLE  NULL;#undef D#undef A2 添加宏关键字在 #define DIRECTIVE_TABLE 中添加复制一行原宏关键字，该D为A，添加中文名 字符串。例如#define DIRECTIVE_TABLE                            #92;D(define,    T_DEFINE = 0,    KANDR,     IN_I)       /* 270554 */ #92;A(定义, define,    T_DEFINE,    KANDR,     IN_I)       /* 270554 */ #92;D(include,    T_INCLUDE,    KANDR,     INCL | EXPAND)  /*  52262 */ #92;A(含, include,    T_INCLUDE,    KANDR,     INCL | EXPAND)  /*  52262 */ #92;D(endif,    T_ENDIF,    KANDR,     COND)       /*  45855 */ #92;A(了如, endif,    T_ENDIF,    KANDR,     COND)       /*  45855 */ #92;D(ifdef,    T_IFDEF,    KANDR,     COND | IF_COND) /*  22000 */ #92;A(如定义, ifdef,    T_IFDEF,    KANDR,     COND | IF_COND) /*  22000 */ #92;D(if,        T_IF,        KANDR, COND | IF_COND | EXPAND) /*  18162 */ #92;A(如, if,        T_IF,        KANDR, COND | IF_COND | EXPAND) /*  18162 */ #92;D(else,        T_ELSE,        KANDR,     COND)       /*   9863 */ #92;A(另, else,        T_ELSE,        KANDR,     COND)       /*   9863 */ #92;D(ifndef,    T_IFNDEF,    KANDR,     COND | IF_COND) /*   9675 */ #92;A(如未定义, ifndef,    T_IFNDEF,    KANDR,     COND | IF_COND) /*   9675 */ #92;D(undef,    T_UNDEF,    KANDR,     IN_I)       /*   4837 */ #92;A(消定义, undef,    T_UNDEF,    KANDR,     IN_I)       /*   4837 */ #92;D(line,        T_LINE,        KANDR,     EXPAND)       /*   2465 */ #92;A(行, line,        T_LINE,        KANDR,     EXPAND)       /*   2465 */ #92;D(elif,        T_ELIF,        STDC89,    COND | EXPAND)  /*    610 */ #92;A(另如, elif,        T_ELIF,        STDC89,    COND | EXPAND)  /*    610 */ #92;D(error,    T_ERROR,    STDC89,    0)           /*    475 */ #92;A(错误, error,    T_ERROR,    STDC89,    0)           /*    475 */ #92;D(pragma,    T_PRAGMA,    STDC89,    IN_I)       /*    195 */ #92;A(杂注, pragma,    T_PRAGMA,    STDC89,    IN_I)       /*    195 */ #92;D(warning,    T_WARNING,    EXTENSION, 0)           /*     22 */ #92;A(告警, warning,    T_WARNING,    EXTENSION, 0)           /*     22 */ #92;D(include_next,    T_INCLUDE_NEXT,    EXTENSION, INCL | EXPAND)  /*     19 */ #92;A(含下个, include_next,    T_INCLUDE_NEXT,    EXTENSION, INCL | EXPAND)  /*     19 */ #92;D(ident,    T_IDENT,    EXTENSION, IN_I)           /*     11 */ #92;D(import,    T_IMPORT,    EXTENSION, INCL | EXPAND)  /* 0 ObjC */    #92;A(导入, import,    T_IMPORT,    EXTENSION, INCL | EXPAND)  /* 0 ObjC */    #92;D(assert,    T_ASSERT,    EXTENSION, DEPRECATED)       /* 0 SVR4 */    #92;A(断言, assert,    T_ASSERT,    EXTENSION, DEPRECATED)       /* 0 SVR4 */    #92;D(unassert,    T_UNASSERT,    EXTENSION, DEPRECATED)       /* 0 SVR4 */    #92;A(消断言, unassert,    T_UNASSERT,    EXTENSION, DEPRECATED)       /* 0 SVR4 */    #92;D(sccs,        T_SCCS,        EXTENSION, IN_I)           /* 0 SVR4? */make bootstrap amp;amp; make install 之后，配合支持UTF-8的补丁，就可以愉快地用中文关键字了。"
    } ,
  
    {
      "title"    : "如何使GCC支持中文(utf-8)的变量名、函数名？",
      "category" : "命名, 编译器",
      "description" : "通过修改gcc编译器源码, 使之支持中文变量名, 函数名. Allow gcc to support unicode identifiers.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%BC%96%E8%AF%91%E5%99%A8/2017/11/24/%E5%A6%82%E4%BD%95%E4%BD%BFGCC%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87(utf-8)%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D-%E5%87%BD%E6%95%B0%E5%90%8D.html",
      "date"     : "2017-11-24 00:37:00 -0700",
      "content"  : "知乎原文地址 作者:狗屎咖啡目前VS 和Clang都是支持utf-8的变量名、函数名，但 GCC不支持。有人提意见，提了好几年了：UTF-8 support for identifier names in GCCGCC并没有解决，但官方给了一个解决方案：FAQ - GCC Wiki就是用这样一条脚本语句转换一下源文件perl -pe 'BEGIN  binmode STDIN, :utf8;  s/(.)/ord(1) lt; 128 ? 1 : sprintf(#92;#92;U08x, ord(1))/ge;'这条语句的意思是将源文件按utf-8读取出来，大于128的unicode(不在ASCII里)都用16进制的#92;Uxxxxxxxx的格式替代。这种格式叫UCN。实际上gcc内部还是将UCN转换成utf-8字符串，再加到符号表。却不支持原生的UTF-8符号，这个就有点搞笑了。虽然有人会说，C、C++的标准里没有对UTF-8符号的支持，GCC不支持UTF-8符号是符合标准的。但是GCC从来就不是死守标准的乖宝宝对吧，加了不少扩展了。为啥这个不能扩展一下呢？官方不加，咱可以同人一下嘛！下面就告诉大家，怎么在GCC里加UTF-8符号的支持。在libcpp/lex.c 里1.加一个函数bool is_utf8_char(cppchar_t c)     if (c gt; 0x80) return true;    else return false;2.复制一份函数lex_identifier，命名为lex_utf8_identifierif (! starts_ucn)    while (ISIDNUM (*cur))            hash = HT_HASHSTEP (hash, *cur);        cur++;        NORMALIZE_STATE_UPDATE_IDNUM (nst, *(cur - 1));中ISIDNUM 改成 is_utf8_char:if (! starts_ucn)    while (is_utf8_char (*cur))            hash = HT_HASHSTEP (hash, *cur);        cur++;        NORMALIZE_STATE_UPDATE_IDNUM (nst, *(cur - 1));3.在函数 _cpp_lex_direct 中修改 switch 的 default    default:        create_literal (pfile, result, buffer-gt;cur - 1, 1, CPP_OTHER);        break;改为：    default:        if (is_utf8_char(c))                    struct normalize_state nst = INITIAL_NORMALIZE_STATE;            result-gt;type = CPP_NAME;            result-gt;val.node.node = lex_utf8_identifier(pfile, buffer-gt;cur - 1, false,                amp;nst, amp;result-gt;val.node.spelling);            warn_about_normalization(pfile, result, amp;nst);                else                    create_literal (pfile, result, buffer-gt;cur - 1, 1, CPP_OTHER);                break;OK！完工了。make bootstrap amp;amp; make install 吧。你就可以愉快地使用 UTF-8 变量，函数了。成品：地址"
    } ,
  
    {
      "title"    : "中文编程兴起的必然性",
      "category" : "语言设计",
      "description" : "从多个方面阐述中文编程兴起的必然性. Illustrate the inevitability of thriving of programming in Chinese.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/11/23/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E5%85%B4%E8%B5%B7%E7%9A%84%E5%BF%85%E7%84%B6%E6%80%A7.html",
      "date"     : "2017-11-23 17:05:00 -0700",
      "content"  : "“中文编程”知乎专栏原文看到国人创造中文编程语言的优势一文的评论后, 此文基于个人视野, 从几个方面阐述中文编程兴起的必然性和展望. 下面是一些近十几年中的相关趋势.对代码可读性的重视将会从大公司向小公司逐渐普及在这个2010年的Quara回答中, Google已经把可读性审核作为代码审核的一部分包括在了标准软件开发过程中, 就算国内迟十年开始, 相信不少国内大公司已经开始进行了或多或少的可读性审核, 而且已经意识到了英文水平和对单词理解偏差造成的额外开发维护成本, 只是暂时没有找到更合适和成熟的开发途径而已. 这个需求只会随着国内团队开发的日益成熟和项目生命期的变长而越来越大.开源软件/思想的推广多数现有的中文编程语言/工具都是闭源的. 而趋势是新语言从成型就开源. 国人已经有不少这样的尝试, 虽然绝大多数是英文编程语言, 但也有开源的中文编程语言了(国人创造中文编程语言的优势最后列表). 随着更多的开发者参与到中文编程语言设计的开源项目中, 诞生现象级的中文语法的编程语言只是时间问题, 个人的猜想是5-10年.新一代计算技术的兴起在量子计算领域, 中国几乎和国外处于一个起跑线. 商用虽有距离, 但相信我们这一代就可以看到. 虽然现在它的编程语言还很底层(以量子门外汉的眼光, 现在是类似于电子计算机的汇编语言时期), 但也可以开始考虑中文编程语言的设计了. 欢迎专业人士一同探讨: 为量子计算设计的中文编程语言 · Issue #29 · program-in-chinese/overview自然语言处理在软件开发/代码分析中的应用这是个尚在摇篮的领域, 但必定会随着编程语言/软件工程的演进和自然语言处理的热度而进一步发展. 比如论文: Investigating the Use of Code Analysis and NLP to Promote a Consistent Usage of Identifiers. 在这个背景下, 使用中文进行编程就有了更大的意义. 它不仅能从中文自然语言处理技术受益, 而且可以提供代码领域的独特的中文语料库(这个语料库现在基本是英文的)而反哺中文NLP技术的发展.Unicode的普及各种表现包括: Unicode在2004年之后在web的加速普及, Google Java代码风格将源码格式定为UTF8等等. 这些都更利于中文命名在源码中的实践和普及.下面是更一般和不随时间改变的:英文学习的门槛再低, 也是第二语言除非身处全英文环境, 母语是中文的少儿不可能对英文有更高的敏感度. 在可预见的将来, 中国绝大多数人还是会处于中文环境中. 更何况, 现在英文学习热潮本身就是很大程度被IT热(硅谷)催生的. 随着中国国力和科技水平逐渐和国外平齐, 这个热度从长远看只会下降.青出于蓝正如四大发明始于中国而盛于西方, 计算机系统虽然始于西方, 不意味着再发明和创造不可能发生在其他地方. 中国在系统领域(超算等等)的弯道超车就是个例子. 而软件领域的门槛其实更低. 中国占1/5的世界人口, 和越来越多希望学习中国文化的外国人, 就是中文编程最好的土壤.小结无论天时地利人和, 都越来越有利于中文编程的创造和推广.姊妹篇: 中文编程兴起的可能途径"
    } ,
  
    {
      "title"    : "中文代码示例之Vuejs入门教程(一)问题后续",
      "category" : "命名, 教程",
      "description" : "前文中文代码示例教程之Vuejs入门碰到的问题的解决. Solutions to the issues found when rewriting  sample codes in Vuejs official guide by using Chinese naming as much as possible.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2017/11/20/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BVuejs%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%80)%E9%97%AE%E9%A2%98%E5%90%8E%E7%BB%AD.html",
      "date"     : "2017-11-20 22:00:00 -0700",
      "content"  : "“中文编程”知乎专栏原文第一个issue: Error compiling template if using unicode naming as v-for alias · Issue #6971 · vuejs/vue多谢尤大搞定, 貌似是把标识符的正则表达式匹配检测去掉了. 经测试已经不再在控制台报警告.第二个issue: Unicode naming for methods seems unsupported. Some warning will be appreciated. · Issue #6975 · vuejs/vue如果要检验标识符合法性, 经社区指出严格来说需要非常长的正则表达式(11KB)才能覆盖整个范围. 而获得的好处只是能够用简写(可以用v-on:click=”倒着说” , 而不是v-on:click=”倒着说()”), 因此不值得. 就这个问题而言, 感觉合理, 不过这个问题也许只是前端框架中使用Unicode命名相关问题的冰山一角. 待以后继续实践吧.至此, 此入门教程的第一部分暂告一段落."
    } ,
  
    {
      "title"    : "国人创造中文编程语言的优势",
      "category" : "语言设计",
      "description" : "对比创造英文编程语言, 国人在创造中文编程语言时具备的优势, 以及开源的中文编程语言项目. Compared to creating English programming language, some advantages the Chinese have when creating Chinese programming languages. Also list some related open-source projects.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/11/17/%E5%9B%BD%E4%BA%BA%E5%88%9B%E9%80%A0%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BC%98%E5%8A%BF.html",
      "date"     : "2017-11-17 09:43:00 -0700",
      "content"  : "知乎原文源自: 吴烜：为什么国内创造不出很棒的编程语言？在上面的回答中, 阐述了国人创造英文编程语言以及推广的难度. 归纳如下:  母语为中文的编程语言设计者在创造英文编程语言时, 相对母语为英文的语言设计者, 在语法设计上没有明显优势  现有英文编程语言在硬功能上已经覆盖了主要的应用领域, 这也是很多人说创造新(中文)语言没有必要的一个原因  在性能和语言特性上进行竞争不是不可能, 但即使首创了很有吸引力的特性, 也很可能在聚集足够用户和开发社区之前被其他已占据市场的语言吸收类似特性而失去优势  创造英文编程语言时几乎必然选择英文编写代码, 而这对最可能参与开发的国内开发者(原因见对在代码中使用中文命名的质疑与回应“不利于非中文编程者贡献”一节)来说是个考验对应的, 创造中文语法的编程语言就有以下优势:  相对母语为英文的编程语言设计者, 语法设计有绝对优势. 而且在无空格设计上, 可以和其他的类似语言(日,韩等等)的语言设计者有技术交流(相关: 日语编程语言”抚子” - 第三版特色初探)  可能在所有应用领域上争取到足够的用户. 不言自明的原因是, 如果两种编程语言在功能和可持续性(比如有开源社区支持)上相差无几, 一种是中文语法, 一种是英文语法, 国内用户几乎肯定会首选前者. 甚至在功能有差距的情况下, 也更有耐心和兴趣尝试前者.  中文语法这一特性就足够区别于所有英文编程语言. 而它们中文化(本地化)几乎不可能达到原创中文编程语言的自然程度. 即使中文语法只是对现有语言的关键词进行汉化, 这一优势仍然存在(关键词的选取上).  中文编程语言很适合使用中文编写代码实现, 如果开源的话, 这对国内开发者(中文编程语言的使用者的主体)参与贡献会很有吸引力.顺便列出已知的开源中文编程语言项目(不分先后). 定有遗漏, 欢迎补充!  对现有语言关键词汉化:          修改clang编译器, 添加中文关键字      修改Python3编译器, 添加中文关键字      修改TypeScript编译器, 添加中文关键词和API      为GCC添加中文关键字      周蟒      中蟒        中文编程语言          Z语言第三版 - TKT2016/ZLanguage3      roundsheep/rpp      文言Perl      "
    } ,
  
    {
      "title"    : "为Python添加中文关键字",
      "category" : "语言设计, 汉化关键词",
      "description" : "通过修改Python编译器源码, 使之支持中文关键词. Add Chinese keywords to Python compiler.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E6%B1%89%E5%8C%96%E5%85%B3%E9%94%AE%E8%AF%8D/2017/11/17/%E4%B8%BAPython%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E5%85%B3%E9%94%AE%E5%AD%97.html",
      "date"     : "2017-11-17 06:34:00 -0700",
      "content"  : "知乎原文地址 作者:狗屎咖啡swizl/cnpython1.大部分语法，可以按下面方法加同义的中文token第1步. 编译pgencd到python的源代码目录下，./configuremake Parser/pgen第2步. 修改 ./Grammar/Grammar，添加同义词并生成语法代码。以while，else为例原文：while_stmt: 'while' test ':' suite ['else' ':' suite]改为：while_stmt: ('while'|当) test ':' suite [('else'|另) ':' suite]保存 ./Grammar/Grammar为UTF-8格式执行./Parser/pgen ./Grammar/Grammar ./Include/graminit.h ./Python/graminit.c虽然会提示错误，但输出是有效正确的。其实pgen不支持UTF-8，这里 中文名 不需要用单引号或双引号，利用pgen的容错性，减少工作量。2.还有一较复杂语法在/Python/ast.c 里有辅助解析例如comp_op: ... |'in'|'not' 'in'|'is'|'is' 'not'改为comp_op: ... |('in'|在)|('not' 'in'|不在)|('is'|为)|('is' 'not'|不为)在ast.c里的 ast_for_comp_op 中if (NCH(n) == 1) switch (TYPE(n))     case NAME:/******添加如下代码*******/         if (strcmp(STR(n), 在) == 0)               return In;         if (strcmp(STR(n), 不在) == 0)                return NotIn;         if (strcmp(STR(n), 为) == 0)                return Is;         if (strcmp(STR(n), 不为) == 0)                return IsNot;其实从源代码我们可以看出来，comp_op原来的判断是token有两个单词的话，第二个单词为in返回NotIn，第一个单词为is返回IsNot。另外就是 None，True，False，finally，async，await 需要添加一下。3.内置函数 中文化在/Python/bltinmodule.c中的builtin_methods[]中添加以print为例，将含”print”的一行复制粘贴，替换第二行的”print”为”打印”即可  print,           (PyCFunction)builtin_print,      METH_FASTCALL | METH_KEYWORDS, print_doc,   打印,           (PyCFunction)builtin_print,      METH_FASTCALL | METH_KEYWORDS, print_doc,其他的还有一些宏，展开看一下，就明白了。  BUILTIN_LEN_METHODDEF   长, (PyCFunction)builtin_len, METH_O, builtin_len__doc__,之后 make 编译python即可。中文的py文件也需要保存为UTF-8格式。"
    } ,
  
    {
      "title"    : "为clang添加中文关键字",
      "category" : "语言设计, 汉化关键词",
      "description" : "通过修改clang编译器源码, 使之支持中文关键词. Add Chinese keywords to clang compiler.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/%E6%B1%89%E5%8C%96%E5%85%B3%E9%94%AE%E8%AF%8D/2017/11/17/%E4%B8%BAclang%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E5%85%B3%E9%94%AE%E5%AD%97.html",
      "date"     : "2017-11-17 00:00:00 -0700",
      "content"  : "知乎原文地址 作者:狗屎咖啡以clang为基础做了一个与C++、C兼容中英文关键字的编译器swizl/cnlang原理就是加与英文关键字等效的中文关键字在/include/clang/Basic/TokenKinds.def 中用ALIAS添加中文关键字例如KEYWORD(char, KEYALL)ALIAS(字, char, KEYALL)在 /lib/Basic/IdentifierTable.cpp 中加个头文件 #include “llvm/ADT/StringSwitch.h”在 tok::PPKeywordKind IdentifierInfo::getPPKeywordID() const 里用 llvm::StringSwitch 添加 中文宏例如//default: return tok::pp_not_keyword;default: return llvm::StringSwitchlt;tok::PPKeywordKindgt;(Name).Case(如, tok::pp_if).Case(定义, tok::pp_define).Default(tok::pp_not_keyword);用上面的方式将中文关键字，编译完成后，就可以编译中文源代码了。llvm/clang的编译方法参照官网。"
    } ,
  
    {
      "title"    : "中文命名实践的阻力和应对",
      "category" : "命名",
      "description" : "探究中文命名为何还没有在商业项目中推广使用, 并提出可能的应对途径. Try to address why there's hardly any commercial projects that practise naming in Chinese, and discuss about possible approaches.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2017/11/14/%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E5%AE%9E%E8%B7%B5%E7%9A%84%E9%98%BB%E5%8A%9B%E5%92%8C%E5%BA%94%E5%AF%B9.html",
      "date"     : "2017-11-14 00:00:00 -0700",
      "content"  : "中文命名在商业项目中至今没有大规模应用. 此文试图对它的原因做些粗浅探究.讨论组中的帖子所有开发者母语都是中文时, 为什么大多数项目仍然选择英文命名? · Issue #18 · program-in-chinese/overview里初步归结出几个问题:  已有的代码风格和格式规范的文档都是基于英文命名而制定的  从别处粘贴复制代码简单(因为绝大多数找得到的代码都是英文的)  不同操作系统的默认编码方式不同, 比如代码库在Linux机器, 开发机是Windows, 容易出乱码问题  依赖的库或者工具对中文支持不佳(比如这里22楼发现的Spring的Thymeleaf不支持中文变量名), 最近的发现有Angluar对中文支持有限(中文代码示例之Angular入门教程尝试)第一条实际上是恶性循环的后果(只有英文命名的代码-gt;没有中文命名的风格-gt;难以开展中文命名实践-gt;更总结不出风格). 第二条也类似, 但相信也有迫于压力不愿分享中文命名的代码的因素. 而后两条是比较”硬”的技术原因. 第三条其实是技术上比较容易解决的, 只要把源码文件都统一编码并成为一个团队内部的共识即可, 即便如此也足够让很多团队望而却步了. 第四条是真正的直接影响在代码中使用中文的决定性因素. 一旦项目选择的框架有此类问题, 那么即使这个框架是开源的, 也几乎不大可能花时间去为了使用中文命名而改进框架. 而这个问题也间接是由中文命名的实践少而导致的. 如果自己(母语是中文的开发者)都不在这些开源框架的社区中发声的话, 国外开发者更不可能为这个需求(在框架中使用中文命名)花费额外的精力.个人感觉, 实践中文编程(即使只是用中文命名而已)在实用项目里的阻力, 不外乎一条 - 避险. 而这是非常非常合理的. 如果没有先前的亲身经验积累(确认所有外部依赖的框架/库中全面支持中文命名), 相信不会有一个产品负责人会在内外压力下决定吃螃蟹采用中文命名. 而在几乎所有公开分享的源码都是英文命名的情况下, 仅靠自己来积累这个经验教训是几乎不可能完成的任务, 即使有公司总结出了一套适合自己团队的中文命名方式, 也很可能是只适用于他们项目使用的框架/环境. 而愿意公开分享这些经验教训的毕竟是少数(也许也是中文编程的实战项目有哪些?没有回应的原因之一?). 这样又反过来使得这类实践更难以推广.中文编程专栏的一部分关注就是在现有的语言/框架/工具集中使用中文命名. 希望通过一些深浅不一的尝试, 逐渐探究出一些可行的对中文命名足够友好的开发套路, 也为有志于此类实践的同好提供一个交流分享中文代码的场所. 在此过程中, 逐渐积累中文代码的数量, 并对中文代码风格进行探讨总结. 希望能为逐步解决上面的死循环出一点力."
    } ,
  
    {
      "title"    : "中英文代码对比系列之Java一例",
      "category" : "命名, 示例",
      "description" : "比较同一段代码使用中文和英文命名的效果, 讨论代码风格. Compare one piece of code using Chinese and English namings. Discuss related code style issues.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E7%A4%BA%E4%BE%8B/2017/11/09/%E4%B8%AD%E8%8B%B1%E6%96%87%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%E4%B9%8BJava%E4%B8%80%E4%BE%8B.html",
      "date"     : "2017-11-09 00:00:00 -0700",
      "content"  : "中英文代码对比系列之Java一例 - 吴烜的文章 - 知乎http://zhuanlan.zhihu.com/p/30905033这个系列将对同一段代码进行中文命名和英文命名两个版本的比较. 目的包括, 演示中文命名, 发现命名时可能遇到的问题, 探讨代码风格(中文命名的’套路’)等. 示例中的命名风格仅基于个人非常有限的实践, 希望抛砖引玉.不在讨论范围内的是:  中英文代码的可读性孰高孰低. 个人相信用英文和中文都能写出可读性很好的代码. 区别仅在于母语不同的开发者对哪个版本更敏感, 读写维护起来更省工.  原代码本身的优化/风格问题. 如果认为有更有代表性的代码, 请不吝推荐.  代码输入的便捷性. 前作对在代码中使用中文命名的质疑与回应‘中文输入太慢, 降低开发效率’一节中有所涉及, 打算另开题探讨.下面一段代码选自Clean Code: A Handbook of Agile Software Craftsmanship一书, 19页. 已经经过了作者的命名改进. 由于本人也没有看过全书, 如果此段代码在此书之后某节仍有命名改进, 请麻烦指出.  public Listlt;Cellgt; getFlaggedCells()     Listlt;Cellgt; flaggedCells = new ArrayListlt;Cellgt;();    for (Cell cell : gameBoard)      if (cell.isFlagged())        flaggedCells.add(cell);    return flaggedCells;  中文命名版:  public Listlt;格类gt; 取被标的格()     Listlt;格类gt; 被标的格 = new ArrayListlt;格类gt;();    for (格类 某格 : 雷区)      if (某格.是被标的())        被标的格.add(某格);    return 被标的格;  这里触及了几处典型的中文命名问题. 首先, 是没有大小写区分类和变量名(Cell cell). 个人采用的是在类名中使用后缀’类’. 暂时没有发现有类名本身就用’类’结尾的情况(那样会出现XXX类类的命名), 即使如此, 应该可以用改为类型结尾来规避(就成为XXX类型类). 变量名也与类名有一致之处, 就是所有关于格类的变量都用xx格命名, 与英文命名方法相同.下面, 是单复数的区别. flaggedCells是个List, 它用复数命名的意思是”可能包含多个格”. 而实际上这个变量可能只包含一个格. 中文中的名词不分单复数, 正好符合”这个变量有可能含有单个或多个元素”这个语义. 因此命名为被标的格感觉可行. 假如语义需要强调有多个(不可能只有单个或没有), 可以考虑加上修饰如多个前缀等等.相比之下, 如何在for循环中表示单数有些麻烦. 这个for循环的语义大概是:for one/each cell in the gameboard, if the cell is flagged, add the cell to..., 原代码中没对one/each cell和the cell作出区分. 对应中文大约是对于雷区中的每一格, 如果这一格是被标的, 就把这一格加到.... 同样也很难在代码中用一个词体现每一格和这一格这两个有差别的语义. 另外可能的命名有一格, 每格, 此格, 在不需突出单数的情况下直接用格等等.get前缀的方法名, 中文采用了对应的取, 用动词短语可以和变量名区分, 这和英文命名类似. 有个潜在的技术问题, 就是Bean中get的特殊规则. 个人认为在这种情况下可以采用混用, 即get被标的格. 这个Spring Boot的演示程序中就是如此.is前缀的方法名, 一般认为是返回布尔值的方法. 这里采用的命名是被标的是个很直白的对应命名. 既保留了是作为表示返回布尔值, 也保留了被动语态. 个人觉得稍显累赘, 但与其他命名一致(取’被标的’格, ‘被标的’格), 并且易于使用在其他情况, 比如isRunning-gt;是运行中的, isTerriblyDamaged-gt;是被严重损坏的等等. 不失为一种可行的风格. 这里原本使用了是被标记的, 但感觉去掉一字也可以接受.此外, gameBoard没有采用直译, 而是用雷区, 因为这个代码在原作中是假想从一个mine sweeper game(扫雷游戏)中选取的, 因此感觉比较适合. 当然, 原代码中gameBoard也可以用mineField使这一段单独出来的代码更有语境. 但正如开头声明, 此文并不对中英文代码之间的可读性进行比较. 这里也就不拘泥于找到gameBoard的对应中文了.再次欢迎各种推敲."
    } ,
  
    {
      "title"    : "中文编程专栏介绍, 初衷和希冀",
      "category" : "综述",
      "description" : "中文编程的各个方面-1. 以中文命名标识符 2. 汉化现有库/框架的接口(API) 3. 将现有编程语言进行汉化 4. 改进现有的, 以及创立新的中文编程语言及对应的开发集成环境.",
      "tags"     : "编程语言, api, unicode, 中文命名, ide, 可读性, 业务逻辑, 维护成本, 语言设计, 新手",
      "url"      : "/%E7%BB%BC%E8%BF%B0/2017/11/09/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E4%B8%93%E6%A0%8F%E4%BB%8B%E7%BB%8D,-%E5%88%9D%E8%A1%B7%E5%92%8C%E5%B8%8C%E5%86%80.html",
      "date"     : "2017-11-09 00:00:00 -0700",
      "content"  : "经过三个多月的集体探讨, 在中文编程专栏开通之际, 将中文编程的几个方面罗列如下. 各个方面相辅相成, 没有高低之分.  以中文命名标识符. 即在代码中将业务相关的部分用中文命名. 比如类/接口名, 变/常量, 方法名, 数据库中的表/列名, HTML中的ID名等等. 意义在于, 提升代码可读性, 降低维护成本. 风险是, 代码风格需要总结, 第三方库对Unicode支持不佳, 系统编码不一致等等. 优势是, 不需依赖任何外部工具, 在支持中文命名标识符的语言中可以立刻实施.  汉化现有库/框架的接口(API), 翻译其相关文档. 上一项虽然已经包括了使用中文命名接口, 但现有的大量库和框架仍有视情况汉化的价值. 意义在于, 接口更易于学习和使用, 同样增加业务代码可读性. 风险是, 需要谨慎选择库, 确保汉化和维护的工作量可控; 另外, 统一术语用词也是挑战. 优势是, 技术门槛较低, 易于团队分工.  将现有编程语言进行汉化. 包括汉化关键词, 內建函数甚至核心库等. 意义在于, 汉化后的语言对新手更友好; 反思关键词意义; 对设计新语言提供借鉴; 积累编译器实现经验等. 风险是, 维护的工作量; 关键词推敲等. 优势是, 有不少已有的尝试可以借鉴.  改进现有的, 以及创立新的中文编程语言及对应的开发集成环境(这里包括改进现有的IDE对英文编程语言中使用中文代码的支持). 意义不言自明. 风险是, 需要和所有主流编程语言竞争. 优势是, 中文是我们的母语.希望认识对中文编程任何方面有兴趣和经验的同好, 为推进中文编程的切磋, 实践, 推广和市场化群策群力. 望各位多多进言, 踊跃投稿!"
    } ,
  
    {
      "title"    : "中文代码示例之Vuejs入门教程(一)",
      "category" : "命名, 教程",
      "description" : "中文代码示例教程之Vuejs入门, 记录过程中碰到的问题. Rewrite  sample codes in Vuejs official guide by using Chinese naming as much as possible, and take notes of issues found.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2017/11/09/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B9%8BVuejs%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%80).html",
      "date"     : "2017-11-09 00:00:00 -0700",
      "content"  : "为了检验中文命名在主流框架中的支持程度, 在vuejs官方入门教程第一部分的示例代码中尽量使用了中文命名. 所有演示都在本地测试通过, 源码在这里. 下面省略了很多原教程的说明内容, 而着重于代码示例本身. 欢迎问题/批评.声明式渲染  lt;div id=元素idgt;      lt;pgt; 问候 lt;/pgt;    lt;/divgt; var 应用1 = new Vue(  el: '#元素id',  data:     问候: '吃了么?'  )打开你的浏览器的控制台 (就在这个页面打开)，并修改应用1.问候，你将看到上例相应地更新。  lt;div id=元素id2gt;      lt;span v-bind:title=动态绑定信息gt;        鼠标悬停几秒钟查看此处动态绑定的提示信息！      lt;/spangt;    lt;/divgt; var 应用2 = new Vue(  el: '#元素id2',  data:     动态绑定信息: '页面加载于 ' + new Date().toLocaleString()  )再次打开浏览器的 JavaScript 控制台输入应用2.动态绑定信息 = '新消息'，就会再一次看到这个绑定了title属性的HTML已经进行了更新条件与循环  lt;div id=元素id3gt;      lt;p v-if=看得到gt;现在你看到我了lt;/pgt;    lt;/divgt; var 应用3 = new Vue(  el: '#元素id3',  data:     看得到: true  )继续在控制台设置 应用3.看得到 = false，你会发现“现在你看到我了”消失了。  lt;div id=元素id4gt;      lt;olgt;        lt;li v-for=任务 in 任务表gt;           任务.内容         lt;/ligt;      lt;/olgt;    lt;/divgt; var 应用4 = new Vue(  el: '#元素id4',  data:     任务表: [       内容: '学习 JavaScript' ,       内容: '学习 Vue' ,       内容: '整个牛项目'     ]  )警告如下, 但列表仍然显示. 已经在Vue项目新建issue[Vue warn]: Error compiling template:lt;div id=元素id4gt;      lt;olgt;        lt;li v-for=任务 in 任务表gt;           任务.内容         lt;/ligt;      lt;/olgt;    lt;/divgt;- invalid v-for alias 任务 in expression: v-for=任务 in 任务表(found in lt;Rootgt;)在控制台里，输入应用4.任务表.push( 内容: '新项目' )，你会发现列表中添加了一个新项。处理用户输入v-on:click支持中文方法名, 但需要(). 为此在Vue项目新建issue, 经社区建议得知并检验, 另一种方式click也支持中文命名, 同样需要().  lt;div id=元素id5gt;      lt;pgt; 问好 lt;/pgt;      lt;button click=倒着说()gt;click有效lt;/buttongt;      lt;button v-on:click=倒着说()gt;v-on:click有效lt;/buttongt;    lt;/divgt; var 应用5 = new Vue(  el: '#元素id5',  data:     问好: '你好'  ,  methods:     倒着说: function ()       this.问好 = this.问好.split('').reverse().join('')      )表单输入和应用状态之间的双向绑定:  lt;div id=元素id6gt;      lt;pgt; 问好 lt;/pgt;      lt;input v-model=问好gt;    lt;/divgt; var 应用6 = new Vue(  el: '#元素id6',  data:     问好: '你好!'  )组件化应用构建  lt;div id=元素id7gt;      lt;olgt;        lt;todo-item          v-for=物品 in 购物单          v-bind:待购=物品          v-bind:key=物品.序号gt;        lt;/todo-itemgt;      lt;/olgt;    lt;/divgt; Vue.component('todo-item',   props: ['待购'],  template: 'lt;ligt; 待购.名称 lt;/ligt;')var 应用7 = new Vue(  el: '#元素id7',  data:     购物单: [       序号: 0, 名称: '蔬菜' ,       序号: 1, 名称: '肉' ,       序号: 2, 名称: '随便啥'     ]  )这里的HTML标签todo-item和其他标签(如div, ol)一样, 不支持中文命名.核心基本功能介绍结束.后记初步看来Vuejs对中文命名的支持不错, 尤其是模板的部分. 个别改进建议已经在Vue的github库以issue的方式提出, 社区的活跃度很高, 开发者对这些issue的反应很快, 标记上了”改进”标签, 并针对一个不支持中文命名的问题提供了解决方案.感觉此类实践可以促进与其他开源社区的交流, 并推进框架的业务代码中对中文(Unicode)命名的支持程度.11/20/2017 补记:中文代码示例之Vuejs入门教程(一)问题后续"
    } ,
  
    {
      "title"    : "中文代码示例教程之Angular尝试",
      "category" : "命名, 教程",
      "description" : "试图用中文命名Angular入门代码, 模板部分对中文命名的支持非常有限. Rewrite  sample codes in Angular official tutorial by using Chinese naming as much as possible. Parts related with template has very limited support for unicode naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2017/11/07/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B%E4%B9%8BAngular%E5%B0%9D%E8%AF%95.html",
      "date"     : "2017-11-07 00:00:00 -0700",
      "content"  : "为了检验中文命名在Angular中的支持程度, 把Angular官方入门教程的示例代码中尽量使用了中文命名. 以下源码库在此.创建项目不支持中文命名: ng new 英雄榜Project name 英雄榜 is not valid. New project names must start with a letter, and must contain only alphanumeric characters or dashes. When adding a dash the segment after the dash must also start with a letter.英雄榜^文本绑定不支持中文命名变量app.component.ts:export class AppComponent   题目 = '示例';app.component.html:lt;h1gt;题目lt;/h1gt;报错:compiler.js:466 Uncaught Error: Template parse errors:Parser Error: Unexpected token Lexer Error: Unexpected character [题] at column 1 in expression [题目] at column 2 in [题目] in ng:///AppModule/AppComponent.html0:4 (lt;h1gt;[ERROR -gt;]题目lt;/h1gt;): ng:///AppModule/AppComponent.html0:4Parser Error: Lexer Error: Unexpected character [题] at column 1 in expression [题目] at column 2 in [题目] in ng:///AppModule/AppComponent.html0:4 (lt;h1gt;[ERROR -gt;]题目lt;/h1gt;): ng:///AppModule/AppComponent.html0:4Parser Error: Lexer Error: Unexpected character [目] at column 2 in expression [题目] at column 3 in [题目] in ng:///AppModule/AppComponent.html0:4 (lt;h1gt;[ERROR -gt;]题目lt;/h1gt;): ng:///AppModule/AppComponent.html0:4创建component创建新component, 貌似支持中文: ng generate component 英雄  create src/app/英雄/英雄.component.css (0 bytes)  create src/app/英雄/英雄.component.html (25 bytes)  create src/app/英雄/英雄.component.spec.ts (628 bytes)  create src/app/英雄/英雄.component.ts (310 bytes)  update src/app/app.module.ts (398 bytes)但是报错:英雄.component.ts:7 Uncaught ReferenceError: ViewEncapsulation is not defined    at eval (英雄.component.ts:7)    at eval (英雄.component.ts:18)    at Object.../../../../../src/app/英雄/英雄.component.ts (main.bundle.js:58)    at __webpack_require__ (inline.bundle.js:55)    at eval (app.module.ts:5)    at Object.../../../../../src/app/app.module.ts (main.bundle.js:36)    at __webpack_require__ (inline.bundle.js:55)    at eval (main.ts:4)    at Object.../../../../../src/main.ts (main.bundle.js:74)    at __webpack_require__ (inline.bundle.js:55)已向Angular项目提交bug report: Avoid creating component with unicode naming, instead of throwing error after finishing creation.后经指出, 上面的错误并不是由中文命名导致. 但由于HTML tag不支持中文(vuejs中也有类似问题), 需要将英雄.component.ts中:selector: 'app-英雄',改为:selector: 'app-heroes',在”app.component.html”中添加:lt;app-heroesgt;lt;/app-heroesgt;显示正常. 鉴于Angular在创建Component时自动生成selector代码, 之前的bug report仍然成立, 可以认为Angular本身不支持Component使用中文命名, 但自己修改selector后似乎仍然可用(以观后效).添加类型支持中文命名!添加src/app/英雄.ts:export class 英雄   id: number;  name: string;英雄.component.ts中:  hero: 英雄 =     id: 1,    name: '小明'  ;显示列表由于中不能用中文命名, 因此lt;li *ngFor=let hero of heroesgt;中的hero不能用中文命名, 而heroes如果改为英雄们, 会报错:Parser Error: Lexer Error: Unexpected character [们] at column 15 in expression [let hero of 英雄们] at column 16 in [let hero of 英雄们] in ng:///AppModule/__Component.html2:6 (lt;ul class=heroesgt;  lt;li *ngFor=let hero of 英雄们gt;    lt;span class=badgegt;lt;/spangt;[ERROR -gt;]   lt;/ligt;lt;/ulgt;): ng:///AppModule/__Component.html3:42小结限于时间, 评测只能暂告一段落. 在尝试的很小一部分功能中, 比较纯粹的TypeScript部分允许中文命名, 但牵涉到模板(Template)的部分对中文命名的支持非常有限."
    } ,
  
    {
      "title"    : "日语编程语言&quot;抚子&quot; - 第三版特色初探",
      "category" : "语言设计",
      "description" : "对最新版的抚子语言进行各方面学习, 此文从功能和特性开始. Study the unique features and designs from the Japanese programming language Nadesiko.",
      "tags"     : "",
      "url"      : "/%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/2017/11/06/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AF%AD%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8A%9A%E5%AD%90%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%89%88%E5%8A%9F%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7%E5%88%9D%E6%8E%A2.html",
      "date"     : "2017-11-06 00:00:00 -0700",
      "content"  : "它山之石可以攻玉. 学习其他的母语编程语言, 相信对中文编程语言的设计和实践有借鉴意义. 本人刚刚开始接触”抚子”语言, 从官方文档开始探索. 以下试图突出一些发现的特色和亮点, 更完整的语法列表请见讨论组主题帖.一些背景资料: 官方网站  第三版(最新)源码库, 用JavaScript实现, 代码提交从2017/2至今  第二版源码库, 用C#实现. 代码提交从2010/6到2016/2.  第一版源码库, 用Pascal实现, 最近仍然在更新. 最早代码提交是2008年, 但应该在更早几年前就已经成型.下面的示例代码源自第三版语法文档. 限于日语水平, 对它的示例源码也许有理解出入. 为方便理解, 已把它们转成对应的中文, 词序有不少调整. 如发现大的出入, 非常欢迎到主题帖批评指正.接近日语自然语言的语法比如它允许多种方式赋值:价格是3000    #  原代码: 値段は3000价格=2000置价格为4000   # 値段に4000を代入。很明显它支持是无空格语法, 也同时支持传统(=)赋值和接近自然语言的赋值方式. 这个风格贯穿所有语法.又如条件语句:A = 4如果A不是5   显示为「OK」如果不是   显示为「NG」直到这里。暂时不确定空格缩进是否像Python那样必须, 还是仅为了代码可读性.特别的’它’加5到30，并乘以2来显示它。加5到30。 它乘以两倍。 显示它。它的使用, 是一个特色. 个人感觉是内置的匿名变量, 并且在函数没有实参时默认使用. 这是很接近自然语言的指代用法! 例如:它是“  abc   ”   lt;--- 后面几行都省略了'它'空白删除。大写转换用“*”替换“A”显示。在函数中可以用它, 作为返回的默认值:●（A和B的）加法是    它是A + B    返回直到这里上例中即使没有返回“它”, 函数返回值仍然是它的值它也会随着函数执行而更新, 如下示例, 函数体中没有它, 但仍然显示50●（A和B的）加法是    B添加到A直到这里30和7的加法. 显示它.精简的循环‘回数’是个保留变量, 可以获得当前循环次数的序号:N=3(N)次　　显示「这是第回数次」。直到这里。也可以遍历:重复[1，2，3], 这里开始    显示对象。直到这里。上面的对象应该是类似回数的内置变量, 用以返回当前循环对应的值. (推测上面如果是显示回数的话, 应该显示0 1 2)上面也可以用显示它对象按照键遍历:OBJ = “Jan”：1，“Feb”：2，“Mar”：3，“Apr”：4重复OBJ    显示「对象键 = 对象月份」直到这里。这里也可以看到它支持JSON数据结构.显式声明变量/常量可带初始化的声明:A是变量=30B是常量=50也可以简写:变量A=30常量B=50函数支持递归和匿名函数, 后者还未来得及细究(官方文档在此)允许内嵌JavaScript这是个非常重要的功能, 虽然没有深入, 但个人理解是类似于Scala调用Java库的功能, 因而”抚子”语言可以用于所有JavaScript可用的领域(包括前后端). 因为此版是在NPM发布的, 猜测JavaScript也可以调用抚子语言的模块. 在缺乏自身的核心标准库时, 个人感觉新语言依托现有成熟语言的核心库以及丰富的第三方库对推广来说至关重要.JavaScript回调事件参数 lt;— 此处不甚理解参数这一内置变量可以以数组形式获取event参数的值。●(A和B的)加法是  它＝参数[0] + 参数[1]直到这里显示3和5的加法。对移动设备和输入法的特别优化一个很有特色的功能是, 为了简便地访问数组/对象. 因为智能手机很难输入A[n](猜想因为[]是在”符号”部分), 因此允许An. 这是第一次看到为了移动设备而设计的功能.其他字符串展开感觉类似于Scala的功能(string interpolation). 复杂的字符串可以用S…(三对以上的大括号)表示:得分是35。 评价是「A」。成绩报告是S★成績表★·他的分数是得分。·评价是评价。显示成绩报告。返回:★成績表★・他的分数是35。・评价是A。"
    } ,
  
    {
      "title"    : "中文代码示例教程之Vuejs入门&amp;后续计划",
      "category" : "命名, 教程",
      "description" : "中文代码示例教程之Vuejs入门, 之后对其他主流框架进行类似实践. Rewrite  sample codes in Vuejs official guide by using Chinese naming as much as possible. Will continue with other frameworks afterwards.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2017/10/31/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B%E4%B9%8BVuejs%E5%85%A5%E9%97%A8.html",
      "date"     : "2017-10-31 00:00:00 -0700",
      "content"  : "为了检验中文命名在主流框架中的支持程度, 这里把vuejs官方入门教程第一部分的示例代码中尽量使用了中文命名.过程中有一些发现, 初步看来Vuejs对中文命名的支持不错. 个别改进建议已经在Vue的github库以issue的方式提出, 社区的活跃度很高, 开发者对这些issue的反应很快, 标记上了”改进”标签, 并针对一个不支持中文命名的问题提供了解决方案.感觉此类实践可以促进与其他开源社区的交流, 并推进框架的业务代码中对中文(Unicode)命名的支持程度. 考虑按照框架的流行程度继续开展.根据2016年后端市场比例, 考虑从占据最大份额的PHP入手, 之后的顺序看情况定:  PHP(参考)          Laravel      Codeigniter      Symfony        ASP.NET  Java          Struts      基于之前的实验项目, Spring Boot      hibernate      Play Framework        Ruby          Rails        Python          flask      Django        Javascript          NodeJS/Express      前端框架可能目标:  Bootstrap  Angularjs"
    } ,
  
    {
      "title"    : "用中文命名API的意义和途径",
      "category" : "命名, API",
      "description" : "用中文命名API的好处和方法. Why and how to name API in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/api/2017/10/29/%E7%94%A8%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8DAPI%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E9%80%94%E5%BE%84.html",
      "date"     : "2017-10-29 00:00:00 -0700",
      "content"  : "在前文对在代码中使用中文命名的质疑与回应中阐述了在代码中使用中文命名的益处. 此文将从软件使用者的角度阐述对API中文化的意义并探讨实现途径. 当然, 文中面向的用户是以中文为母语的开发者.首先请看一个实例, 演示效果在此:这个库提供了一系列绘图相关的API. 后者是笔者将这些API封装成了中文之后的对应代码.此文的大前提是, 对以中文为母语的开发者, 中文接口版本的代码更易理解.API作为程序和程序之间交流的”语言”, 在软件生态圈中的重要性不言而喻. 拥有一套设计良好, 易于理解的API是大多数流行框架和库共有的特征. 当然, 绝大多数的API都是英文的. 导致中文用户在学习和使用时就要更多地依赖文档和注释.中文API的命名更能被中文用户接受. 它将直接降低使用者的学习门槛, 并降低维护成本. 当然, 第三方库对中文字符的支持问题仍然会对这一实践造成麻烦, 但个人认为在实践中解决这些麻烦是降低软件开发成本付出的代价, 而且解决的越早, 后人越能乘凉.现状是, 即使一些国人主创, 且几乎完全面向国内用户的框架, 也没有中文的API. 这里绝无指摘之意, 因为冰冻三尺非一日之寒, 更何况这些框架问世之时中文字符的支持程度也远不如今日.以在下浅见, 开发中文API的途径包括:  用中文封装现有的英文API  在设计时就首选中文API如果能够做到在内部代码和API都使用中文命名, 当然是最理想的, 但个人认为API的命名是更关键的一部分. 中文的命名规范几乎是空白, 这需要实践和集体智慧来填补.封装现有的英文API也许比较有争议. 常见的一种观点是”XX语言的核心库, 先汉化给我看看”. 这是一个寻找切入点的问题. 一个主流编程语言的核心库, 往往经历十数年甚至更长时间的积累, 接口不下万个. 而一些特定领域的库的API, 接口不过数十个. 领域受众也是很重要的因素. 有兴趣的请在跨界: 哪些中文非IT领域会偏好中文API, 编程/脚本语言?一起探讨."
    } ,
  
    {
      "title"    : "对在代码中使用中文命名的质疑与回应",
      "category" : "命名",
      "description" : "对常见的对在编写代码时使用中文命名的反对声音进行小结, 并作针对回应. QA of programming with naming in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2017/10/27/%E5%AF%B9%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E7%9A%84%E8%B4%A8%E7%96%91%E4%B8%8E%E5%9B%9E%E5%BA%94.html",
      "date"     : "2017-10-27 00:00:00 -0700",
      "content"  : "有一部分质疑同样适用于英文代码, 比如”从命名看不出类型”, “命名可能词不达意”等等, 另外还有未经证实的”中文代码导致的未知错误”和没有根据的”比英文代码运行慢“等等, 就不一一回应了.没有好处答：如之前的13年后的共鸣-在代码中用中文命名的优势和问题一文所述，中文命名在很多时候可以更准确，也比英文命名更轻松。如果认为API以及内部方法/变量的命名无关紧要. 有不少可读性相关的文章对这个误区进行了阐述, 比如Writing for Readability不利于非中文编程者贡献答：现状是, 中文开发者主创的开源库/框架, 绝大多数的贡献者也都是中文开发者, 即使非常流行和国际化的框架如vuejs也是如此. 原因肯定是多方面的. 能够想到的有:  有类似功能的国外开源项目. 作为外国程序员首选参与的肯定是那些  如果是和中文本身相关的库, 如结巴分词, 主要的用户也是中文开发者, 自然维护的也是个人也不赞成100的中文化. 需要和国外交流的项目肯定有. 大胆假设:以中文为母语的所有程序员,从事的项目中,90是单人项目(*),剩下的10中,90只有同样是中文为母语的程序员参与.这样,只有1的项目有用英文写代码的硬性需要.为了这1的需要,而在剩下的99中使用英文,得不偿失.注： 根据Fun with GitHub repositories statistics, github上的1-contributor repository大约是60. 当然还有很多项目没有开源. 上面的90仍然是假设.当然希望看到更多的国外开发者参与国人初创的项目. 不过，除去预测得到是否会有国外开发者参与的情况, 剩下的自己发起的项目, 首要考虑的是对自己的开发和维护最有利的编程方式. 因为在可以预见的将来, 我自己会是最主要的贡献者. 如果我自己的开发和维护成本随着项目变大而变得不可持续, 那么在项目成型和能够吸引其他开发者参与之前可能就夭折了. 个人的感觉是用中文命名是我更熟悉和容易的方式.osc上一些即使很热火的开源框架, 比如JFinal, 大多只有极少的其他开发者贡献. 个人认为一个很重要的原因, 就是代码阅读的难度, 而英文命名是一个额外的障碍. 也许对于开发者本人来说, 随着项目的开展, 一些开始时有些别扭的英文命名自己也习惯了, 但是对于刚拿到整个代码的新开发者, 任何不妥当的英文命名都会导致迷惑和时间的浪费. 为了吸引理论上的国外开发者参与, 而不优先选择对身边的中文开发者(包括自己)阅读代码有利的编程方式, 个人认为这种思路是很值得商榷和分情况探讨的.芬兰人Linus，使用英语而非自己的母语来编写Linux代码答：Linus的母语是瑞典语，根据wiki使用者是八百七千万。中文（普通话）的母语使用者是九亿五千万。这是一百倍的差距。另外，英语母语使用者是3亿六百万。更重要的是，中文母语使用者基本集中在中国，而英语分布在不同国家。西班牙语也类似。从人口基础来看，用中文编程是非常有潜力的。附上中文注释就够了答：关于注释和命名, 在个人之前的工作环境里, 是第一次接触正式的可读性审核. 有个印象是, 审核员会尽量倾向于减少注释量, 而强调代码本身的可读性(其中最重要的因素之一就是命名). 审核里会不时出现”这个方法名已经self-explaining了,注释就不用了”之类的评语. 虽然没有当面确认过, 但写注释和维护注释的额外工作量应该也是这种倾向的动因之一.绝大多数API, 包括标准库都是英文的答: 没错, 但在代码中, 自己定义的类/方法/变量占的篇幅一般都不少于依赖库(包括标准库)的方法/类所占篇幅, 欢迎提供具体统计数据. 可以看看这里的中英文代码篇幅的比例. 中文命名带来的代码改变是一目了然的. 更关键的是, 自定义的部分往往是业务逻辑最集中并且最需要可读性的部分.如果关键词还是英文, 用中文命名就没有意义答: 用中文命名带来的好处是不分编程语言的, 甚至英文关键词和中文的显著区别可能带来额外的可读性增强. 另外, 至少短期内(5-10年), 英文关键词的编程语言还将在市场中占有不可忽视的份额, 在这个阶段使用中文命名是一条代价小而收益相对立竿见影的途径.编程语言本身和英文语法无关答: 虽然和英文自然语言相去甚远, 但仍然有不少设计是带着很多英文风格的. 如: 空格作为分隔符; for…in等用法带有英文语法特色. for原意并没有循环的意思，而更接近”对于”，这在”for（A in B）“的语法中更明显，对应中文接近”对于B中的那些A“。while原意也没有‘循环’的意思，中文接近“只要”或者“当”。这恰恰说明了英文编程语言的设计与英文语法和词意的相关性。不懂英文的开发者在学习时就只能强记这些关键词（虽然也不是大麻烦），但假想这些关键词如果开始就是中文，那么肯定会更容易理解，也省去了强记的一步。中文输入太慢, 降低开发效率答: 首先, 如果考虑推敲命名的时间, 对母语是中文的程序员, 中文命名应该比能够更恰当更快, 综合各种因素哪种方式写代码更快还待实践证实. 其次, 鉴于开发过程在整个软件生存周期中只占一小部分, 其他的部分(设计,调试,测试,维护)从良好的可读性获取的利远大于开发效率可能降低的弊.为避免频繁切换中英文: 为了在输入中文的同时不用切换就可以输入特殊符号();等等, 搜狗输入法支持”中文时使用英文标点”会有各种汉字编码问题导致乱码答：汉字编码问题不仅限于代码, 使用的越少越不利于问题解决. 多数问题能通过使编码一致避免, UTF8和GBK互转的问题(实例)可能会在长时间内存在。用中文命名能使这些问题更加凸显，促进问题解决，而不是拖延回避.看多了中文程序会影响英文学习，以及程序员前程答：就像搞学术的需要的时候自然逼着看英文刊物，有硬性需要的时候自然会去看国外网站。如果这就会影响，那么也许本来就不那么需要。中英混用的问题比如Java中有个回避不掉的问题JavaBeans规范一定要使用set/get命名。maven版本号的 -SNAPSHOT 特殊语义，旧junit中需要测试的方法必须以test开头等答: 确实在实践中碰到混用的情况, 个人基本上是能用多少中文就用多少. 比如这里set/get和中文混用，个人觉得可以接受。如果想在Java里用中文编写代码, 中英混用是不可能避免的.上面列出的之外， (转载)发展中文编程的意义：让大众化编程促进软件产业的建设也对一些质疑作出了回应没有先例答: 这个 2017 年的 quora 答案(Alan Mellor’s answer to Has any serious project been written in a non-English-based programming language?)提到西门子(德)/爱立信(瑞典)内部有尽量用母语命名的 C/C++项目. 以及布拉格看到的一本编程书中的示例代码也是用母语命名.开源项目中也有不少. 这是一位台湾开发者用Python开发的自然语言处理工具: 臺灣言語工具 项目成型于2013年, 代码目测数万行.最初在编程语言中添加支持 Unicode 的功能, 也应该有各个非英语母语国家/地区开发者的推动力量.2018-07-18更新中文比英文更难以理解答: 比如假设中国人最先开发电脑和设计程序语言，那么各种程序语言会使用汉字吗？. 问题是, 无论从什么角度说, 中文也是中国人的母语, 而母语优势已经由前面的”没有好处”一节说明. 退一万步说, 即使这个命题成立, 也只能用来说明中国人用中文作为母语导致了理解效率落后. 而不能说明中文命名不适合于国人.2018-07-22更新“我们在用C++，Java，Python编程，不是在用英文编程”答: 这是很常见的一个说法, 比如这里. 之前的”没有好处”和”编程语言本身和英文语法无关”等节已经阐述了命名和编程语言语法和自然语言直接的关系. 如果还不够说服力, 也许可以看看国外非英语母语的开发者. Linus(Linux作者)的回答(原文在Interview: Linus without Linux): “我一直用英文编程”. 而且他还提到编程语言都是基于英文的. 节选如下:  Question: What language did you use in comments to Linux while you were a student?Torvalds: English. I’ve always programmed in English. All the books were in English, and the programming-languages tend to be somewhat English-based too (i.e. “while (x)  … ”)."
    } ,
  
    {
      "title"    : "13年后的共鸣-在代码中用中文命名的优势和问题",
      "category" : "命名",
      "description" : "与13年前的博文有同感, 分析在代码中用中文命名的优势和问题. Echoing a blog article 13 years ago, with the topic of pro and cons of Chinese naming in code.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2017/10/26/13%E5%B9%B4%E5%90%8E%E7%9A%84%E5%85%B1%E9%B8%A3-%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%94%A8%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E9%97%AE%E9%A2%98.html",
      "date"     : "2017-10-26 00:00:00 -0700",
      "content"  : "早在2004年的关于中文编程 - 张玮的专栏 - 博客频道 - CSDN.NET一文中非常有前瞻性地阐述了用中文编写代码对改善可读性的意义, 今日代码可读性已经越来越被业界重视而成为代码审核的一部分.文中提到的几个论点尤其有共鸣：  我经常见到为取变量名和类名查字典的情况，这还算是好的。有时候遇到不好查字典或者理解不准确甚至是心情不好，乱起一个名字，就会搞得后来读程序头痛。“道可道，非常道；名可名，非常名”。《道德经》把名放在开篇中，可见一个好的名字的重要性。我觉得名字就代表对事物本质的认识，再加上软件这样一个东西，其中的大部分事物几乎都是创造出来的，如果没有一个好的名字，就会让人很难以理解。我觉得名字差有三方面的原因：  1、名字代表程序员对事物本质的认识，一个坏的名字可能意味着概念的模糊。有可能是程序员对事物的划分不准确，这些东西在一起只是偶然的，从而取不出好的名字，因为这个事物的边界是模糊的；也有可能开始的时候是准确的，但后来随着事物的发展，这个东西的性质已经改变，原来的名字已经反映不出它的本质了。这个时候就需要改一个更准确的名字，但由于没有方法论和工具的保证，这种变动往往不太容易，因此很多人不会愿意做这种变化。…  2、认为名字不重要，这个上面我已经谈到。  3、认识也是准确的，也想取一个好名字，但是因为语言的限制，取不了好名字。  这个正是我想说的问题。因此我们就要在源代码中使用中文。那有的人说，现在的语言大多支持中文的注释，用中文注释不就OK了吗？关于这个观点，请参见Refactoring中的论述，总之，结论是，做为向高级语言进化的第一步，汇编语言中出现的关于变量名，方法名等等，正是自然的表达人的思想的地方，从这个角度上来看，注释倒反是副产品，也就是说，在用变量名，方法名，类名等等不能表达的时候，在用Refactoring不能解决问题的时候，才用注释来解决。文中提到的问题在13年后的今天也还没有完全的解决:  最现实的一个问题是：环境的支持。最基本的是运行环境和编译环境，我大部分时间都生活在Java环境中，很少数情况会有不支持的情况，我记得遇到过的不支持的情况好象是WebLogic不支持有中文方法名的EJB。总之，这方面的不支持是比较少的。IDE的支持一般也是可以的，但是对输入的支持一般都不好。比如有一个中文方法名，如果要想在弹出的选单中选中文方法名，都是很痛苦的。我能想到的比较好的方法应该是象E语言一样：象输入”中文”,只需要输入”zhongwen”或”zw”,或”zhw”即可。但现在几乎所有的开发工具都不支持，我想有一天这种输入方法应该是会被支持的。两个问题都是生态环境对中文(或者说非英文)的支持, 这需要更多在源码/文件名中使用中文来推动解决.关于中文输入法, 理想的解决方式是支持多种输入法(不仅是拼音), 而且与IDE原有的代码自动补全功能无缝集成. 通过插件在主流IDE中实现这一功能。 最近发现了一个开源实现，在TypeScript+VSCode中实现了根据拼音首字母或者拼音的部分来匹配中文标识符。虽然随着VSCode的新版本发布而失效，反映了IDE插件对IDE的依赖性问题，但仍证实了可行性，有不少借鉴意义。"
    } ,
  
    {
      "title"    : "在各种编程语言中使用中文命名",
      "category" : "命名",
      "description" : "罗列支持中文命名变量,方法,类的编程语言. List out programming languages that support naming variables, functions and classes in Chinese.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/2017/10/23/%E5%9C%A8%E5%90%84%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D.html",
      "date"     : "2017-10-23 00:00:00 -0700",
      "content"  : "许可协议: 署名-非商用-相同方式共享 4.0 转载请保留原文链接及作者多数现代编程语言都支持Unicode命名的事实，说明了这一需求的切实存在，和编程语言开发者的前瞻性。关键词为英文的编程语言对中文代码的支持(字母排序)Agda,C,C++,C#,CoffeeScript,Common Lisp,Dart,FASM,Go,Haskell,Java,JavaScript,Julia,Kotlin,MySQL,Objective-C,Perl,PHP,PowerShell,Python 3,R,Ruby,Scala,Sqlite3,Swift,VBA上面仅为测试证实过的编程语言版本。更早版本和其他语言很可能已经支持. Unicode strings - Rosetta Code列出了更多编程语言对Unicode的支持程度, 可以逐个检验.现在很欠缺的是中文代码风格文档。有些英文代码风格是没有中文替代的，比如Camel case。以后将会尝试探讨。"
    } ,
  
    {
      "title"    : "开源非英文关键词编程语言",
      "category" : "关键词",
      "description" : "非英文关键词的编程语言, 只列出了开源的. Open source Non-English-based programming languages",
      "tags"     : "",
      "url"      : "/%E5%85%B3%E9%94%AE%E8%AF%8D/2017/10/17/%E5%BC%80%E6%BA%90%E9%9D%9E%E8%8B%B1%E6%96%87%E5%85%B3%E9%94%AE%E8%AF%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.html",
      "date"     : "2017-10-17 00:00:00 -0700",
      "content"  : "世界各国的开发者都进行了基于母语设计编程语言语法的尝试. 有些已经商用且活跃至今. 这里搜集了一些开源的实现, 也许能够获取一些借鉴和启发.在Wiki上有更全面的链接.下面只列出了已确认开源的, 且不包含中文编程语言, 排序不分先后:            语法使用何种自然语言      编程语言                  日语      Nadesiko, なでしこ(抚子): 源码库              阿拉伯语      قلب              法语      Linotte: 源码库 v2.07 source zip              拉脱维亚语      Dzintars              泰米尔语      Ezhil              葡萄牙语      Potigol      "
    } ,
  
    {
      "title"    : "都市传说: &quot;部分&quot;中文出现乱码",
      "category" : "编码",
      "description" : "只有部分中文出现乱码的编码问题分析. Analysing encoding issue where only part of text displays incorrectly.",
      "tags"     : "",
      "url"      : "/%E7%BC%96%E7%A0%81/2017/10/10/%E9%83%A8%E5%88%86%E4%B8%AD%E6%96%87%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81.html",
      "date"     : "2017-10-10 00:00:00 -0700",
      "content"  : "事情起源于项目另一开发者在中文Windows下构建时遇到的部分中文出现乱码问题.当时很不解的是, 为什么会只有部分出现乱码. 第一感觉是, 如果编码转换不正确, 要么全乱码, 要么全正确. 为何会”部分”出现乱码.初步分析在此. 简单说, 就是在转码过程中, Java会把某些它不认识的部分直接用某个值代替. 至于为何不默认保留原数据, 是个好的考古研究课题.示例如下(除了”开始检”, 其他都乱码了):            编码      原字1      原字2      原字3      原字4      原字5      原字6                  原字      开      始      检      查      …      …              UTF8表示      e5 bc 80      e5 a7 8b      e6 a3 80      e6 9f a5      e2 80 a6      e2 80 a6              转为GBK后      e5 bc 3f      e5 a7 8b      e6 a3 80      e6 9f a5      e2 3f a6      e2 3f 3f              转回UTF8      �?      开      始      检      �?�      �??      网上很多资源提到字符数是奇数会有问题, 这是没错. 但实际上即使偶数也可能会有问题. 上面的转换过程中, 80不是合法GBK字符, 就被替换成3f. 而替换过后再转回UTF8当然就挂了.这个问题里的插件就是把输出字符串指定编码成了UTF8格式的数据, 但输出/解码时又用了系统默认的编码格式(GBK). 详见 GBKlt;-gt;UTF8 互转问题: Maven checkstyle输出乱码 · Issue #26 · program-in-chinese/overview, zh-cn ,,,, cmd gbk encode · Issue #3569 · checkstyle/checkstyle.个人觉得这种转码问题是除了亚洲/非洲之外的开发者很容易忽视的. UTF8的字符除了亚洲(包括中日韩)和非洲语言的字符用三字节数据表示外, 其他多数语言的字符都是用单字节或双字节. 来源). 这些UTF8中三字节的字符和GBK之类的双字节码转码时会更容易出问题.在调查过程中, 还发现了其他一些类似疑问, 比如UTF-8编码，部分中文正常，部分为乱码的问题？-CSDN论坛.直觉是也是类似问题, 但想用编码互转的方式重现未果, 参考上面的例子试了几种2次转码, 都没有重现. JDBC连接MySQL抛出异常信息乱码 - insist的专栏 - CSDN博客提到了CP1252编码, 又经过几次尝试, 才试出了这个过程: “utf-8”-gt;”windows-1252”-gt;”iso-8859-1”-gt;”utf-8”.阶段总结一下, 乱码问题的缘由都是编码互转. 全部乱码, 部分乱码都可能. 随着国外代码库/软件的编码方式更多地使用UTF8, 类似第二个问题的可能会变少, 但类似第一个的UTF8lt;-gt;GBK互转的问题也许会存在很长一段时间."
    } ,
  
    {
      "title"    : "中文代码示例教程之Java编程一天入门",
      "category" : "命名, 教程",
      "description" : "以中文编写示例代码的Java入门短教程. Short beginner's tutorial of Java programming with sample codes using Chinese naming.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/%E6%95%99%E7%A8%8B/2017/07/29/%E4%B8%AD%E6%96%87%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B%E4%B9%8BJava%E7%BC%96%E7%A8%8B%E4%B8%80%E5%A4%A9%E5%85%A5%E9%97%A8.html",
      "date"     : "2017-07-29 00:00:00 -0700",
      "content"  : "Java编程一天入门 v0.0.1 alpha共享协议 本作使用署名-非商业使用-禁止演绎协议共享。前言Java入门代码用中文写(举例如下)更能被新手理解. 由于至今没有看到类似教程, 在此抛砖引玉. 欢迎指正/批评/意见/建议.public class 小孩类 extends 人类   String 想做的事 = 大人的事;  public 小孩类(String 姓名, int 年龄)     super(姓名, 年龄);    public void 长大()     System.out.println(我要做 + 想做的事);  编程语言的语法是最机械的, 在阅读过程中, 请尽量关注于程序做了些什么, 而一些语法细节可以暂时忽略. 入门之后, 在接下去的写和读代码过程中, 语法自然会熟练起来.每一讲建议时间30分钟左右. 如果卡住(比如超过一小时), 欢迎在代码库发问. 目的是让总时间控制在8小时左右, 让”一天入门”更符合实际.目录一 准备编程二 问个好吧三 Java的现状四 用Java算术五 变量-在程序中保存修改信息六 文字七 如果…就…不然…八 直到…一直…九 造个人十 让它更像人十一 数据排排站-数组十二 更多结构十三 活久见十四 为人民服务十五 自我肯定 - 测试零 没有规矩, 不成方圆 - 代码风格(完)"
    } ,
  
    {
      "title"    : "在Maven Central发布中文API的Java库",
      "category" : "命名, API",
      "description" : "开发一个简单的Java库, 通过sonatype发布到Maven主库. Publish Java library with APIs in Chinese on Maven Central, through Sonatype.",
      "tags"     : "",
      "url"      : "/%E5%91%BD%E5%90%8D/api/2017/07/20/%E5%9C%A8Maven-Central%E5%8F%91%E5%B8%83%E4%B8%AD%E6%96%87API%E7%9A%84Java%E5%BA%93.html",
      "date"     : "2017-07-20 00:00:00 -0700",
      "content"  : "知乎原链相关问题: 哪些Java库有中文命名的API?且记下随想.之前没有发布过, 看了SO上的推荐:Publish a library to maven repositories 决定在sonatype发布. sonatype发布开源软件库的步骤写的蛮详细, 不过一些细节比如命令行指令可能有段时间没更新了. 比如有个坑是发布gpg的公开秘钥, 指定server的时候如果有hkp://前缀的话就报错 no route to host, 不知是否因为我用的gpg2, 试了各种才发现去掉前缀就行了.在命名上, API方法和参数以及类名都用了中文. 下面是Eclipse中的Javadoc弹窗:根据Guide to Naming Conventions, groupid还是沿用了域名命名, artifactiId也还是用英文. 以后可能试试中文artifactId, 应该不算”strange symbols”.发布了几个小版本, 感觉有时需要一个多小时在pom里引用, 更新还算蛮快.lt;dependencygt;  lt;groupIdgt;com.github.nobodxbodonlt;/groupIdgt;  lt;artifactIdgt;zhconverterlt;/artifactIdgt;  lt;versiongt;0.0.5lt;/versiongt;lt;/dependencygt;项目源码: program-in-chinese/zhconverter希望找到前人, 结识来者.2017.12.19今天为了尝试发布, 运行” mvn clean deploy -P release”. 但报错:    gpg: selecting openpgp failed: Operation not supported by device    gpg: signing failed: No pinentry    gpg: signing failed: No pinentry不知何故, 但重装GnuPG解决问题."
    } 
  
]